{"file_contents":{"replit.md":{"content":"# HyserCore - Plugin Completo para Spigot 1.8.8\n\n## Resumen del Proyecto\n\nHyserCore es un plugin completo de Minecraft desarrollado para Spigot 1.8.8 que integra m√∫ltiples sistemas avanzados:\n\n- **ChatGames**: Sistema de minijuegos en el chat con recompensas\n- **Sword Enchantments**: Encantamientos personalizados para espadas con efectos √∫nicos\n- **LunarWaypoints**: Sistema de waypoints integrado con UltimateClans tipo F3 rally\n- **LunarTeamViewer**: Visor de miembros del clan con separaci√≥n por mundos\n- **Anti-AutoArmor**: Sistema mejorado de detecci√≥n de auto-armor\n- **PrisonPunch**: Sistema de punch para prisi√≥n con configuraci√≥n de AzuriteSpigot\n\n## Cambios y Mejoras Implementadas\n\n### üìÅ Estructura del Proyecto\n- **COMPLETADO**: Reorganizaci√≥n completa de archivos YML en `src/main/resources/`\n- **COMPLETADO**: Estructura de proyecto Maven est√°ndar con paquetes organizados\n- **COMPLETADO**: Configuraci√≥n de compilaci√≥n autom√°tica con workflow\n\n### ‚ùÑÔ∏è IceAspect Mejorado\n- **NUEVO**: Evita colocar bloques de hielo en el piso del jugador\n- **NUEVO**: Altura m√≠nima de jaula configurable para evitar bloqueo completo\n- **NUEVO**: Creaci√≥n de huecos de aire para escapar\n- **NUEVO**: No reemplaza bloques s√≥lidos importantes\n- **MEJORADO**: Radio y duraci√≥n optimizados para mejor balance PvP\n\n### üõ°Ô∏è Sistema Anti-AutoArmor Mejorado\n- **NUEVO**: Detecci√≥n de cambios extremadamente r√°pidos (150ms)\n- **NUEVO**: Ventana de tiempo m√°s corta para mayor precisi√≥n (200ms)\n- **NUEVO**: Ignora modo creativo para evitar falsos positivos\n- **NUEVO**: Ignora re-equipar la misma armadura\n- **MEJORADO**: Seguimiento detallado de patrones de equipamiento\n\n### üèõÔ∏è Integraci√≥n UltimateClans Corregida\n- **CORREGIDO**: M√∫ltiples m√©todos de detecci√≥n de clanes\n- **NUEVO**: Fallback autom√°tico si falla el primer m√©todo\n- **MEJORADO**: Logs detallados para debugging\n- **NUEVO**: Compatibilidad con diferentes versiones de UltimateClans\n\n### üìç LunarWaypoints Tipo Rally\n- **NUEVO**: Actualizaciones autom√°ticas cada 3 segundos tipo F3\n- **NUEVO**: Separaci√≥n estricta por mundos (solo muestra del mismo mundo)\n- **NUEVO**: Sistema de timestamp para waypoints\n- **MEJORADO**: Interfaz visual mejorada con mejor formato\n- **NUEVO**: Actualizaci√≥n silenciosa en tiempo real\n\n### üë• LunarTeamViewer con Separaci√≥n por Mundos\n- **NUEVO**: Sistema completamente nuevo de visualizaci√≥n de clan\n- **CR√çTICO**: Solo muestra jugadores del mismo mundo\n- **NUEVO**: Actualizaciones autom√°ticas cada 5 segundos\n- **NUEVO**: Interfaz dedicada con informaci√≥n de distancia y direcci√≥n\n- **NUEVO**: Toggle individual por jugador\n\n### üìö Sistema de Libros de Encantamiento Corregido\n- **CORREGIDO**: Los libros ahora aplican efectos correctamente\n- **NUEVO**: Detecci√≥n autom√°tica de espadas en el inventario\n- **NUEVO**: Tasa de √©xito configurable para libros\n- **NUEVO**: Consumo autom√°tico de libros despu√©s del uso\n- **MEJORADO**: Validaci√≥n completa de libros de encantamiento\n\n### ü•ä Sistema PrisonPunch (NUEVO)\n- **NUEVO**: Configuraci√≥n exacta de AzuriteSpigot para knockback realista\n- **NUEVO**: Modo boost tipo flecha en lugar de hit tradicional\n- **NUEVO**: Configuraci√≥n simple y avanzada de knockback personalizable\n- **NUEVO**: Sistema de delay entre hits para prevenir spam\n- **NUEVO**: Soporte para zonas seguras y de miner√≠a\n- **NUEVO**: Part√≠culas y sonidos personalizables\n- **NUEVO**: Comandos completos de gesti√≥n y configuraci√≥n\n\n## Estructura T√©cnica\n\n### Comandos Disponibles\n- `/chatgames [reload|start|stop|status|stats]` - Gesti√≥n de ChatGames\n- `/swordenchant <tipo>` - Aplicar encantamientos a espadas\n- `/enchantbook <tipo>` - Crear libros de encantamiento\n- `/waypoints [set|list|remove]` - Gesti√≥n de waypoints de clan\n- `/teamviewer [on|off|list]` - Control del teamviewer lunar\n- `/prisonpunch [reload|enable|disable|status|test|config]` - Sistema de punch para prisi√≥n\n\n### Archivos de Configuraci√≥n\n- `config.yml` - Configuraci√≥n principal del plugin\n- `chatgames.yml` - Configuraci√≥n completa de ChatGames\n- `swordenchants.yml` - Configuraci√≥n de encantamientos y anti-autoarmor\n- `prisonpunch.yml` - Configuraci√≥n de sistema de punch con valores de AzuriteSpigot\n\n### Permisos\n- `hysercore.admin` - Acceso completo a todos los comandos\n- `hysercore.participate` - Participar en ChatGames\n- `hysercore.swordenchant` - Usar encantamientos de espada\n- `hysercore.waypoints` - Usar waypoints de clan\n- `hysercore.teamviewer` - Usar teamviewer lunar\n- `hysercore.prisonpunch` - Gestionar sistema de punch para prisi√≥n\n\n## Entorno de Desarrollo Replit\n\n### Estado del Proyecto\n- **CONFIGURADO**: Entorno Java con GraalVM 19 (compatible con Java 8)\n- **CONFIGURADO**: Maven 3.8.6 para compilaci√≥n autom√°tica\n- **CONFIGURADO**: Workflow de build que genera `hysercore-1.0.0.jar`\n- **CONFIGURADO**: Configuraci√≥n de deployment para distribuci√≥n\n- **CORREGIDO**: Error de sintaxis en ItemAbilityManager.java\n\n### Compilaci√≥n\n```bash\nmvn clean package -DskipTests\n```\nEl archivo JAR se genera en: `target/hysercore-1.0.0.jar`\n\n### Para Usar el Plugin\n1. Compilar usando el workflow \"Build HyserCore\" o comando Maven\n2. Copiar `target/hysercore-1.0.0.jar` a la carpeta `plugins/` de tu servidor Spigot 1.8.8\n3. Reiniciar el servidor Minecraft\n4. El plugin se iniciar√° autom√°ticamente\n\n## Compatibilidad\n\n- **Spigot**: 1.8.8 (optimizado)\n- **Java**: 8+ (compilado y probado con GraalVM 19)\n- **Dependencias Opcionales**: UltimateClans (para waypoints y teamviewer)\n- **Maven**: 3.6+ (usando 3.8.6 en Replit)\n\n## Instalaci√≥n y Uso\n\n1. Coloca el archivo `hysercore-1.0.0.jar` en la carpeta `plugins/` de tu servidor\n2. Reinicia el servidor para generar archivos de configuraci√≥n\n3. Configura `UltimateClans` si deseas usar waypoints y teamviewer\n4. Ajusta configuraciones en los archivos YML seg√∫n tus necesidades\n5. Recarga el plugin con `/chatgames reload`\n\n## Caracter√≠sticas √önicas\n\n- **Separaci√≥n por Mundos**: Los sistemas no muestran informaci√≥n entre mundos diferentes\n- **Integraci√≥n Inteligente**: M√∫ltiples m√©todos de detecci√≥n para UltimateClans\n- **Anti-Griefing**: IceAspect no puede griefear estructuras importantes\n- **Rendimiento Optimizado**: Actualizaciones eficientes y c√≥digo optimizado para 1.8.8\n\n---\n\n*Plugin desarrollado con arquitectura modular y c√≥digo limpio para m√°ximo rendimiento en Minecraft 1.8.8*","size_bytes":6441},"attached_assets/ChatGameListener_1756880000427.java":{"content":"package com.hyser.hysercore.listeners;\n\nimport com.hyser.hysercore.managers.ChatGameManager;\nimport org.bukkit.event.Listener;\n\n/**\n * Listener dedicado para ChatGames\n * En este caso, la funcionalidad de listener est√° incluida en ChatGameManager,\n * pero esta clase puede usarse para listeners adicionales en el futuro.\n */\npublic class ChatGameListener implements Listener {\n    \n    private ChatGameManager gameManager;\n    \n    public ChatGameListener(ChatGameManager gameManager) {\n        this.gameManager = gameManager;\n    }\n    \n    // Aqu√≠ se pueden agregar listeners adicionales si es necesario\n    // Por ejemplo: eventos de join/quit de jugadores, eventos de mundo, etc.\n}","size_bytes":687},"attached_assets/ChatGameManager_1756879996497.java":{"content":"package com.hyser.hysercore.managers;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.games.ChatGame;\nimport com.hyser.hysercore.games.MathGame;\nimport com.hyser.hysercore.games.WordGame;\nimport com.hyser.hysercore.games.TriviaGame;\nimport com.hyser.hysercore.games.CompleteGame;\nimport com.hyser.hysercore.games.NumberGame;\nimport com.hyser.hysercore.utils.PlayerStats;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.AsyncPlayerChatEvent;\nimport org.bukkit.scheduler.BukkitRunnable;\nimport org.bukkit.scheduler.BukkitTask;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ChatGameManager implements Listener {\n    \n    private HyserCore plugin;\n    private FileConfiguration config;\n    private ChatGame currentGame;\n    private BukkitTask gameTask;\n    private BukkitTask intervalTask;\n    private PlayerStats playerStats;\n    \n    public ChatGameManager(HyserCore plugin) {\n        this.plugin = plugin;\n        this.playerStats = new PlayerStats();\n        loadConfig();\n        startGameInterval();\n    }\n    \n    public void loadConfig() {\n        File configFile = new File(plugin.getDataFolder(), \"chatgames.yml\");\n        if (!configFile.exists()) {\n            plugin.saveResource(\"chatgames.yml\", false);\n        }\n        config = YamlConfiguration.loadConfiguration(configFile);\n    }\n    \n    public void reloadConfig() {\n        loadConfig();\n        restartGameInterval();\n        plugin.getLogger().info(\"Configuraci√≥n de ChatGames recargada\");\n    }\n    \n    private void startGameInterval() {\n        if (!config.getBoolean(\"general.enabled\", true)) {\n            return;\n        }\n        \n        int minInterval = config.getInt(\"general.interval.min\", 300);\n        int maxInterval = config.getInt(\"general.interval.max\", 600);\n        int interval = ThreadLocalRandom.current().nextInt(minInterval, maxInterval + 1);\n        \n        intervalTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                startRandomGame();\n                startGameInterval(); // Programar el siguiente juego\n            }\n        }.runTaskLater(plugin, interval * 20L);\n    }\n    \n    private void restartGameInterval() {\n        if (intervalTask != null) {\n            intervalTask.cancel();\n        }\n        startGameInterval();\n    }\n    \n    private void startRandomGame() {\n        if (currentGame != null) {\n            return; // Ya hay un juego en progreso\n        }\n        \n        int minPlayers = config.getInt(\"general.min-players\", 3);\n        if (Bukkit.getOnlinePlayers().size() < minPlayers) {\n            if (config.getBoolean(\"advanced.cancel-if-not-enough-players\", true)) {\n                return;\n            }\n        }\n        \n        String gameType = selectRandomGameType();\n        if (gameType == null) {\n            return;\n        }\n        \n        currentGame = createGame(gameType);\n        if (currentGame != null) {\n            startGame();\n        }\n    }\n    \n    private String selectRandomGameType() {\n        List<String> availableTypes = new ArrayList<>();\n        Map<String, Integer> weights = new HashMap<>();\n        \n        if (config.getBoolean(\"game-types.math.enabled\", true)) {\n            int weight = config.getInt(\"game-types.math.weight\", 30);\n            weights.put(\"math\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"math\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.word.enabled\", true)) {\n            int weight = config.getInt(\"game-types.word.weight\", 25);\n            weights.put(\"word\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"word\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.trivia.enabled\", true)) {\n            int weight = config.getInt(\"game-types.trivia.weight\", 20);\n            weights.put(\"trivia\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"trivia\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.complete.enabled\", true)) {\n            int weight = config.getInt(\"game-types.complete.weight\", 15);\n            weights.put(\"complete\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"complete\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.number.enabled\", true)) {\n            int weight = config.getInt(\"game-types.number.weight\", 10);\n            weights.put(\"number\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"number\");\n            }\n        }\n        \n        if (availableTypes.isEmpty()) {\n            return null;\n        }\n        \n        return availableTypes.get(ThreadLocalRandom.current().nextInt(availableTypes.size()));\n    }\n    \n    private ChatGame createGame(String type) {\n        switch (type.toLowerCase()) {\n            case \"math\":\n                return new MathGame(config);\n            case \"word\":\n                return new WordGame(config);\n            case \"trivia\":\n                return new TriviaGame(config);\n            case \"complete\":\n                return new CompleteGame(config);\n            case \"number\":\n                return new NumberGame(config);\n            default:\n                return null;\n        }\n    }\n    \n    private void startGame() {\n        if (currentGame == null) {\n            return;\n        }\n        \n        // Anunciar inicio del juego\n        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n        String gameStarting = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-starting\", \"\"));\n        String gameType = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-type\", \"\").replace(\"{type}\", currentGame.getTypeName()));\n        int duration = config.getInt(\"general.duration\", 60);\n        String gameDuration = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-duration\", \"\").replace(\"{duration}\", String.valueOf(duration)));\n        int reward = config.getInt(\"rewards.winner.money\", 1000);\n        String gameReward = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-reward\", \"\").replace(\"{reward}\", String.valueOf(reward)));\n        \n        Bukkit.broadcastMessage(prefix + gameStarting);\n        Bukkit.broadcastMessage(prefix + gameType);\n        Bukkit.broadcastMessage(prefix + gameDuration);\n        Bukkit.broadcastMessage(prefix + gameReward);\n        \n        // Mostrar pregunta\n        String question = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.question\", \"\").replace(\"{question}\", currentGame.getQuestion()));\n        Bukkit.broadcastMessage(prefix + question);\n        \n        // Programar avisos de tiempo\n        scheduleTimeWarnings(duration);\n        \n        // Programar fin del juego\n        gameTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                endGame(null);\n            }\n        }.runTaskLater(plugin, duration * 20L);\n    }\n    \n    private void scheduleTimeWarnings(int duration) {\n        // Aviso a los 30 segundos si la duraci√≥n es mayor a 30\n        if (duration > 30) {\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (currentGame != null) {\n                        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n                        String timeLeft = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.time-left\", \"\").replace(\"{time}\", \"30\"));\n                        Bukkit.broadcastMessage(prefix + timeLeft);\n                    }\n                }\n            }.runTaskLater(plugin, (duration - 30) * 20L);\n        }\n        \n        // Aviso a los 10 segundos\n        if (duration > 10) {\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (currentGame != null) {\n                        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n                        String timeLeft = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.time-left\", \"\").replace(\"{time}\", \"10\"));\n                        Bukkit.broadcastMessage(prefix + timeLeft);\n                    }\n                }\n            }.runTaskLater(plugin, (duration - 10) * 20L);\n        }\n    }\n    \n    @EventHandler\n    public void onPlayerChat(AsyncPlayerChatEvent event) {\n        if (currentGame == null) {\n            return;\n        }\n        \n        Player player = event.getPlayer();\n        String message = event.getMessage().trim();\n        \n        if (!player.hasPermission(\"hysercore.participate\")) {\n            return;\n        }\n        \n        if (currentGame.checkAnswer(message)) {\n            // Cancelar el evento para evitar que se muestre en el chat\n            event.setCancelled(true);\n            \n            // Ejecutar en el hilo principal\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n                    endGame(player);\n                }\n            }.runTask(plugin);\n        }\n    }\n    \n    private void endGame(Player winner) {\n        if (currentGame == null) {\n            return;\n        }\n        \n        // Cancelar task del juego\n        if (gameTask != null) {\n            gameTask.cancel();\n        }\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n        \n        if (winner != null) {\n            // Hay ganador\n            String winnerMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.winner\", \"\")\n                    .replace(\"{player}\", winner.getName())\n                    .replace(\"{answer}\", currentGame.getAnswer()));\n            Bukkit.broadcastMessage(prefix + winnerMessage);\n            \n            // Dar recompensas\n            giveRewards(winner, true);\n            \n            // Actualizar estad√≠sticas\n            playerStats.addWin(winner.getUniqueId());\n        } else {\n            // No hay ganador\n            String noWinnerMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.no-winner\", \"\").replace(\"{answer}\", currentGame.getAnswer()));\n            Bukkit.broadcastMessage(prefix + noWinnerMessage);\n        }\n        \n        String gameEnded = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-ended\", \"\"));\n        Bukkit.broadcastMessage(prefix + gameEnded);\n        \n        // Actualizar estad√≠sticas para todos los jugadores que participaron\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            if (player.hasPermission(\"hysercore.participate\")) {\n                playerStats.addGame(player.getUniqueId());\n                if (winner == null || !player.equals(winner)) {\n                    giveRewards(player, false);\n                }\n            }\n        }\n        \n        currentGame = null;\n    }\n    \n    private void giveRewards(Player player, boolean isWinner) {\n        String rewardType = isWinner ? \"winner\" : \"participation\";\n        \n        // Recompensa de dinero (requiere Vault)\n        int money = config.getInt(\"rewards.\" + rewardType + \".money\", 0);\n        if (money > 0) {\n            // Aqu√≠ se integrar√≠a con Vault para dar dinero\n            String moneyReward = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.money-reward\", \"\").replace(\"{amount}\", String.valueOf(money)));\n            player.sendMessage(moneyReward);\n        }\n        \n        // Recompensa de experiencia\n        int experience = config.getInt(\"rewards.\" + rewardType + \".experience\", 0);\n        if (experience > 0) {\n            player.giveExp(experience);\n            String expReward = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.exp-reward\", \"\").replace(\"{amount}\", String.valueOf(experience)));\n            player.sendMessage(expReward);\n        }\n        \n        // Comandos de recompensa\n        List<String> commands = config.getStringList(\"rewards.\" + rewardType + \".commands\");\n        for (String command : commands) {\n            command = command.replace(\"{player}\", player.getName());\n            Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command);\n        }\n        \n        String rewardGiven = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.reward-given\", \"\"));\n        player.sendMessage(rewardGiven);\n    }\n    \n    public void forceStartGame(String type) {\n        if (currentGame != null) {\n            endGame(null);\n        }\n        \n        currentGame = createGame(type);\n        if (currentGame != null) {\n            startGame();\n        }\n    }\n    \n    public void stopCurrentGame() {\n        if (currentGame != null) {\n            endGame(null);\n        }\n    }\n    \n    public boolean isGameActive() {\n        return currentGame != null;\n    }\n    \n    public PlayerStats getPlayerStats() {\n        return playerStats;\n    }\n    \n    public void shutdown() {\n        if (gameTask != null) {\n            gameTask.cancel();\n        }\n        if (intervalTask != null) {\n            intervalTask.cancel();\n        }\n        if (currentGame != null) {\n            endGame(null);\n        }\n    }\n}","size_bytes":13918},"attached_assets/ChatGame_1756880005305.java":{"content":"package com.hyser.hysercore.games;\n\npublic abstract class ChatGame {\n    \n    protected String question;\n    protected String answer;\n    protected String typeName;\n    protected String[] hints;\n    \n    public ChatGame(String typeName) {\n        this.typeName = typeName;\n        this.hints = new String[0];\n    }\n    \n    public abstract void generateQuestion();\n    \n    public boolean checkAnswer(String playerAnswer) {\n        if (answer == null || playerAnswer == null) {\n            return false;\n        }\n        \n        String cleanAnswer = answer.toLowerCase().trim().replaceAll(\"[^a-zA-Z0-9√°√©√≠√≥√∫√±√º ]\", \"\");\n        String cleanPlayerAnswer = playerAnswer.toLowerCase().trim().replaceAll(\"[^a-zA-Z0-9√°√©√≠√≥√∫√±√º ]\", \"\");\n        \n        return cleanAnswer.equals(cleanPlayerAnswer);\n    }\n    \n    public String getQuestion() {\n        return question;\n    }\n    \n    public String getAnswer() {\n        return answer;\n    }\n    \n    public String getTypeName() {\n        return typeName;\n    }\n    \n    public String[] getHints() {\n        return hints;\n    }\n    \n    public String getHint(int index) {\n        if (hints == null || index < 0 || index >= hints.length) {\n            return null;\n        }\n        return hints[index];\n    }\n}","size_bytes":1266},"attached_assets/ChatGamesCommand_1756880049044.java":{"content":"package com.hyser.hysercore.commands;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.managers.ChatGameManager;\nimport com.hyser.hysercore.utils.PlayerStats;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class ChatGamesCommand implements CommandExecutor, TabCompleter {\n    \n    private HyserCore plugin;\n    private ChatGameManager gameManager;\n    \n    public ChatGamesCommand(HyserCore plugin, ChatGameManager gameManager) {\n        this.plugin = plugin;\n        this.gameManager = gameManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                plugin.getChatGamesConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            sender.sendMessage(noPermission);\n            return true;\n        }\n        \n        if (args.length == 0) {\n            sendHelp(sender);\n            return true;\n        }\n        \n        String subCommand = args[0].toLowerCase();\n        \n        switch (subCommand) {\n            case \"reload\":\n                handleReload(sender);\n                break;\n            case \"start\":\n                handleStart(sender, args);\n                break;\n            case \"stop\":\n                handleStop(sender);\n                break;\n            case \"status\":\n                handleStatus(sender);\n                break;\n            case \"stats\":\n                handleStats(sender, args);\n                break;\n            case \"enable\":\n                handleEnable(sender);\n                break;\n            case \"disable\":\n                handleDisable(sender);\n                break;\n            case \"help\":\n            default:\n                sendHelp(sender);\n                break;\n        }\n        \n        return true;\n    }\n    \n    private void handleReload(CommandSender sender) {\n        gameManager.reloadConfig();\n        String reloadMessage = ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.plugin-reloaded\", \"&aConfiguraci√≥n de ChatGames recargada correctamente.\"));\n        sender.sendMessage(reloadMessage);\n    }\n    \n    private void handleStart(CommandSender sender, String[] args) {\n        if (gameManager.isGameActive()) {\n            sender.sendMessage(ChatColor.RED + \"Ya hay un ChatGame activo.\");\n            return;\n        }\n        \n        String gameType = \"random\";\n        if (args.length > 1) {\n            gameType = args[1].toLowerCase();\n        }\n        \n        if (gameType.equals(\"random\")) {\n            gameManager.forceStartGame(null);\n        } else {\n            List<String> validTypes = Arrays.asList(\"math\", \"word\", \"trivia\", \"complete\", \"number\");\n            if (!validTypes.contains(gameType)) {\n                sender.sendMessage(ChatColor.RED + \"Tipo de juego inv√°lido. Tipos v√°lidos: \" + String.join(\", \", validTypes));\n                return;\n            }\n            gameManager.forceStartGame(gameType);\n        }\n        \n        sender.sendMessage(ChatColor.GREEN + \"ChatGame iniciado manualmente.\");\n    }\n    \n    private void handleStop(CommandSender sender) {\n        if (!gameManager.isGameActive()) {\n            sender.sendMessage(ChatColor.RED + \"No hay ning√∫n ChatGame activo.\");\n            return;\n        }\n        \n        gameManager.stopCurrentGame();\n        sender.sendMessage(ChatColor.GREEN + \"ChatGame detenido.\");\n    }\n    \n    private void handleStatus(CommandSender sender) {\n        boolean enabled = plugin.getChatGamesConfig().getBoolean(\"general.enabled\", true);\n        boolean gameActive = gameManager.isGameActive();\n        int onlinePlayers = Bukkit.getOnlinePlayers().size();\n        int minPlayers = plugin.getChatGamesConfig().getInt(\"general.min-players\", 3);\n        \n        sender.sendMessage(ChatColor.GOLD + \"=== Estado de ChatGames ===\");\n        sender.sendMessage(ChatColor.YELLOW + \"Sistema: \" + (enabled ? ChatColor.GREEN + \"Habilitado\" : ChatColor.RED + \"Deshabilitado\"));\n        sender.sendMessage(ChatColor.YELLOW + \"Juego activo: \" + (gameActive ? ChatColor.GREEN + \"S√≠\" : ChatColor.RED + \"No\"));\n        sender.sendMessage(ChatColor.YELLOW + \"Jugadores online: \" + ChatColor.WHITE + onlinePlayers + \"/\" + minPlayers + \" (m√≠nimo)\");\n        \n        if (enabled && !gameActive) {\n            int minInterval = plugin.getChatGamesConfig().getInt(\"general.interval.min\", 300);\n            int maxInterval = plugin.getChatGamesConfig().getInt(\"general.interval.max\", 600);\n            sender.sendMessage(ChatColor.YELLOW + \"Pr√≥ximo juego: \" + ChatColor.WHITE + \"Entre \" + minInterval + \" y \" + maxInterval + \" segundos\");\n        }\n    }\n    \n    private void handleStats(CommandSender sender, String[] args) {\n        if (args.length > 1) {\n            // Estad√≠sticas de un jugador espec√≠fico\n            String playerName = args[1];\n            Player target = Bukkit.getPlayer(playerName);\n            if (target == null) {\n                sender.sendMessage(ChatColor.RED + \"Jugador no encontrado o no est√° online.\");\n                return;\n            }\n            \n            showPlayerStats(sender, target);\n        } else {\n            // Ranking general\n            showTopPlayers(sender);\n        }\n    }\n    \n    private void showPlayerStats(CommandSender sender, Player target) {\n        PlayerStats stats = gameManager.getPlayerStats();\n        UUID playerId = target.getUniqueId();\n        \n        int gamesPlayed = stats.getGamesPlayed(playerId);\n        int gamesWon = stats.getGamesWon(playerId);\n        double winRate = stats.getWinRate(playerId);\n        int totalRewards = stats.getTotalRewards(playerId);\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', plugin.getChatGamesConfig().getString(\"general.prefix\", \"\"));\n        \n        sender.sendMessage(prefix + ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-header\", \"&8&m----------&r &6Estad√≠sticas &8&m----------\")));\n        sender.sendMessage(ChatColor.YELLOW + \"Jugador: \" + ChatColor.WHITE + target.getName());\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-games-played\", \"&7Juegos jugados: &e{games}\").replace(\"{games}\", String.valueOf(gamesPlayed))));\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-games-won\", \"&7Juegos ganados: &a{wins}\").replace(\"{wins}\", String.valueOf(gamesWon))));\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-win-rate\", \"&7Tasa de victoria: &b{rate}%\").replace(\"{rate}\", String.format(\"%.1f\", winRate))));\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-total-rewards\", \"&7Recompensas totales: &6${rewards}\").replace(\"{rewards}\", String.valueOf(totalRewards))));\n    }\n    \n    private void showTopPlayers(CommandSender sender) {\n        PlayerStats stats = gameManager.getPlayerStats();\n        Map<UUID, Integer> topPlayers = stats.getTopPlayers(10);\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', plugin.getChatGamesConfig().getString(\"general.prefix\", \"\"));\n        \n        sender.sendMessage(prefix + ChatColor.GOLD + \"=== Top 10 Jugadores ===\");\n        \n        if (topPlayers.isEmpty()) {\n            sender.sendMessage(ChatColor.GRAY + \"No hay estad√≠sticas disponibles.\");\n            return;\n        }\n        \n        int position = 1;\n        for (Map.Entry<UUID, Integer> entry : topPlayers.entrySet()) {\n            Player player = Bukkit.getPlayer(entry.getKey());\n            String playerName = player != null ? player.getName() : \"Jugador desconocido\";\n            int wins = entry.getValue();\n            int totalGames = stats.getGamesPlayed(entry.getKey());\n            double winRate = stats.getWinRate(entry.getKey());\n            \n            sender.sendMessage(ChatColor.YELLOW + \"#\" + position + \" \" + ChatColor.WHITE + playerName + \n                ChatColor.GRAY + \" - \" + ChatColor.GREEN + wins + \" victorias \" + \n                ChatColor.GRAY + \"(\" + String.format(\"%.1f\", winRate) + \"% de \" + totalGames + \" juegos)\");\n            position++;\n        }\n    }\n    \n    private void handleEnable(CommandSender sender) {\n        plugin.getChatGamesConfig().set(\"general.enabled\", true);\n        plugin.saveChatGamesConfig();\n        gameManager.reloadConfig();\n        \n        String enabledMessage = ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.games-enabled\", \"&aChatGames han sido habilitados.\"));\n        sender.sendMessage(enabledMessage);\n    }\n    \n    private void handleDisable(CommandSender sender) {\n        plugin.getChatGamesConfig().set(\"general.enabled\", false);\n        plugin.saveChatGamesConfig();\n        \n        if (gameManager.isGameActive()) {\n            gameManager.stopCurrentGame();\n        }\n        \n        gameManager.reloadConfig();\n        \n        String disabledMessage = ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.games-disabled\", \"&cChatGames han sido deshabilitados.\"));\n        sender.sendMessage(disabledMessage);\n    }\n    \n    private void sendHelp(CommandSender sender) {\n        sender.sendMessage(ChatColor.GOLD + \"=== Comandos de ChatGames ===\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames reload\" + ChatColor.GRAY + \" - Recargar configuraci√≥n\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames start [tipo]\" + ChatColor.GRAY + \" - Iniciar juego manualmente\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames stop\" + ChatColor.GRAY + \" - Detener juego actual\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames status\" + ChatColor.GRAY + \" - Ver estado del sistema\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames stats [jugador]\" + ChatColor.GRAY + \" - Ver estad√≠sticas\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames enable\" + ChatColor.GRAY + \" - Habilitar sistema\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames disable\" + ChatColor.GRAY + \" - Deshabilitar sistema\");\n        sender.sendMessage(ChatColor.GRAY + \"Tipos de juego: math, word, trivia, complete, number\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] subCommands = {\"reload\", \"start\", \"stop\", \"status\", \"stats\", \"enable\", \"disable\", \"help\"};\n            for (String subCommand : subCommands) {\n                if (subCommand.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(subCommand);\n                }\n            }\n        } else if (args.length == 2) {\n            if (args[0].equalsIgnoreCase(\"start\")) {\n                String[] gameTypes = {\"math\", \"word\", \"trivia\", \"complete\", \"number\", \"random\"};\n                for (String gameType : gameTypes) {\n                    if (gameType.toLowerCase().startsWith(args[1].toLowerCase())) {\n                        completions.add(gameType);\n                    }\n                }\n            } else if (args[0].equalsIgnoreCase(\"stats\")) {\n                for (Player player : Bukkit.getOnlinePlayers()) {\n                    if (player.getName().toLowerCase().startsWith(args[1].toLowerCase())) {\n                        completions.add(player.getName());\n                    }\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":12460},"attached_assets/CompleteGame_1756880005306.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class CompleteGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public CompleteGame(FileConfiguration config) {\n        super(\"Completar Frase\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        List<Map<?, ?>> completeQuestions = (List<Map<?, ?>>) config.getList(\"questions.complete\");\n        \n        if (completeQuestions == null || completeQuestions.isEmpty()) {\n            generateDefaultQuestion();\n            return;\n        }\n        \n        Map<?, ?> selectedQuestion = completeQuestions.get(ThreadLocalRandom.current().nextInt(completeQuestions.size()));\n        \n        question = (String) selectedQuestion.get(\"question\");\n        answer = (String) selectedQuestion.get(\"answer\");\n        \n        List<String> hintsList = (List<String>) selectedQuestion.get(\"hints\");\n        if (hintsList != null) {\n            hints = hintsList.toArray(new String[0]);\n        } else {\n            hints = new String[]{\"Es un refr√°n\", \"Piensa en el significado\", \"La respuesta es: \" + answer};\n        }\n    }\n    \n    private void generateDefaultQuestion() {\n        String[][] questions = {\n            {\"M√°s vale p√°jaro en mano que...\", \"ciento volando\", \"Es un refr√°n\", \"Habla de n√∫meros\", \"...ciento volando\"},\n            {\"En casa de herrero, cuchillo de...\", \"palo\", \"Es un refr√°n\", \"Material opuesto\", \"...de palo\"},\n            {\"A caballo regalado no se le mira el...\", \"diente\", \"Es un refr√°n\", \"Parte de la boca\", \"...el diente\"},\n            {\"Ojos que no ven, coraz√≥n que no...\", \"siente\", \"Es un refr√°n\", \"Emoci√≥n\", \"...que no siente\"},\n            {\"Agua que no has de beber...\", \"dejala correr\", \"Es un refr√°n\", \"No interferir\", \"...d√©jala correr\"},\n            {\"Camar√≥n que se duerme...\", \"se lo lleva la corriente\", \"Es un refr√°n\", \"Sobre el r√≠o\", \"...se lo lleva la corriente\"},\n            {\"El que madruga...\", \"dios le ayuda\", \"Es un refr√°n\", \"Sobre levantarse temprano\", \"...Dios le ayuda\"},\n            {\"No por mucho madrugar...\", \"amanece mas temprano\", \"Es un refr√°n\", \"Sobre el tiempo\", \"...amanece m√°s temprano\"},\n            {\"A quien madruga...\", \"dios le ayuda\", \"Es un refr√°n\", \"Sobre levantarse temprano\", \"...Dios le ayuda\"},\n            {\"Dime con qui√©n andas y te dir√©...\", \"quien eres\", \"Es un refr√°n\", \"Sobre las amistades\", \"...qui√©n eres\"},\n            {\"En boca cerrada...\", \"no entran moscas\", \"Es un refr√°n\", \"Sobre el silencio\", \"...no entran moscas\"},\n            {\"Perro que ladra...\", \"no muerde\", \"Es un refr√°n\", \"Sobre amenazas\", \"...no muerde\"},\n            {\"A mal tiempo...\", \"buena cara\", \"Es un refr√°n\", \"Sobre el optimismo\", \"...buena cara\"},\n            {\"M√°s vale tarde...\", \"que nunca\", \"Es un refr√°n\", \"Sobre el tiempo\", \"...que nunca\"},\n            {\"No hay mal que...\", \"por bien no venga\", \"Es un refr√°n\", \"Sobre las adversidades\", \"...por bien no venga\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n}","size_bytes":3404},"attached_assets/EnchantBookCommand_1756880012090.java":{"content":"package com.hyser.hysercore.enchantments.commands;\n\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class EnchantBookCommand implements CommandExecutor, TabCompleter {\n    \n    private SwordEnchantmentManager enchantmentManager;\n    \n    public EnchantBookCommand(SwordEnchantmentManager enchantmentManager) {\n        this.enchantmentManager = enchantmentManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Este comando solo puede ser usado por jugadores.\");\n            return true;\n        }\n        \n        Player player = (Player) sender;\n        \n        if (!player.hasPermission(\"hysercore.admin\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            player.sendMessage(noPermission);\n            return true;\n        }\n        \n        if (args.length == 0) {\n            sendHelp(player);\n            return true;\n        }\n        \n        String enchantType = args[0].toLowerCase();\n        SwordEnchantment enchantment = null;\n        \n        switch (enchantType) {\n            case \"dash\":\n                enchantment = enchantmentManager.getEnchantment(\"dash\");\n                break;\n            case \"iceaspect\":\n            case \"ice_aspect\":\n                enchantment = enchantmentManager.getEnchantment(\"ice_aspect\");\n                break;\n            case \"sharpness\":\n                enchantment = enchantmentManager.getEnchantment(\"sharpness\");\n                break;\n            case \"lifesteal\":\n                enchantment = enchantmentManager.getEnchantment(\"lifesteal\");\n                break;\n            case \"vampire\":\n                enchantment = enchantmentManager.getEnchantment(\"vampire\");\n                break;\n            case \"bleeding\":\n                enchantment = enchantmentManager.getEnchantment(\"bleeding\");\n                break;\n            case \"explosive\":\n                enchantment = enchantmentManager.getEnchantment(\"explosive\");\n                break;\n            case \"executioner\":\n                enchantment = enchantmentManager.getEnchantment(\"executioner\");\n                break;\n            default:\n                player.sendMessage(ChatColor.RED + \"Tipo de encantamiento inv√°lido: \" + enchantType);\n                sendHelp(player);\n                return true;\n        }\n        \n        if (enchantment == null) {\n            player.sendMessage(ChatColor.RED + \"El encantamiento \" + enchantType + \" no est√° disponible.\");\n            return true;\n        }\n        \n        // Crear libro de encantamiento\n        ItemStack book = createEnchantmentBook(enchantment);\n        \n        // Dar el libro al jugador\n        if (player.getInventory().firstEmpty() == -1) {\n            player.getWorld().dropItem(player.getLocation(), book);\n            player.sendMessage(ChatColor.YELLOW + \"Tu inventario est√° lleno. El libro se ha dejado caer en el suelo.\");\n        } else {\n            player.getInventory().addItem(book);\n        }\n        \n        String successMessage = ChatColor.translateAlternateColorCodes('&', \n            \"&a¬°Libro de encantamiento &f{enchant} &acreado exitosamente!\")\n            .replace(\"{enchant}\", enchantment.getDisplayName());\n        player.sendMessage(successMessage);\n        \n        return true;\n    }\n    \n    private ItemStack createEnchantmentBook(SwordEnchantment enchantment) {\n        ItemStack book = new ItemStack(Material.BOOK);\n        ItemMeta meta = book.getItemMeta();\n        \n        String bookName = ChatColor.translateAlternateColorCodes('&', \n            \"&6Libro de &e\" + enchantment.getDisplayName());\n        meta.setDisplayName(bookName);\n        \n        List<String> lore = new ArrayList<>();\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Libro de encantamiento\"));\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&8Haz click derecho con una espada\"));\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&8en tu inventario para aplicar.\"));\n        lore.add(\"\");\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&b‚ö° \" + enchantment.getLoreText()));\n        \n        // Agregar descripci√≥n espec√≠fica del encantamiento\n        switch (enchantment.getName()) {\n            case \"dash\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Impulso a√©reo hacia adelante\"));\n                break;\n            case \"ice_aspect\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Efectos de hielo al atacar\"));\n                break;\n            case \"sharpness\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Aumenta el da√±o de ataque\"));\n                break;\n            case \"lifesteal\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Roba vida de los enemigos\"));\n                break;\n            case \"vampire\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Regeneraci√≥n al atacar\"));\n                break;\n            case \"bleeding\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Causa sangrado continuo\"));\n                break;\n            case \"explosive\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Knockback explosivo\"));\n                break;\n            case \"executioner\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7M√°s da√±o a enemigos heridos\"));\n                break;\n        }\n        \n        meta.setLore(lore);\n        book.setItemMeta(meta);\n        \n        return book;\n    }\n    \n    private void sendHelp(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"general.prefix\", \"&8[&bSwordEnchant&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Comandos de Libros de Encantamiento ===\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook dash\" + ChatColor.GRAY + \" - Crear libro de Dash\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook iceaspect\" + ChatColor.GRAY + \" - Crear libro de Ice Aspect\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook sharpness\" + ChatColor.GRAY + \" - Crear libro de Sharpness+\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook lifesteal\" + ChatColor.GRAY + \" - Crear libro de Lifesteal\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook vampire\" + ChatColor.GRAY + \" - Crear libro de Vampire\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook bleeding\" + ChatColor.GRAY + \" - Crear libro de Bleeding\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook explosive\" + ChatColor.GRAY + \" - Crear libro de Explosive\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook executioner\" + ChatColor.GRAY + \" - Crear libro de Executioner\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] enchantTypes = {\"dash\", \"iceaspect\", \"sharpness\", \"lifesteal\", \"vampire\", \"bleeding\", \"explosive\", \"executioner\"};\n            for (String type : enchantTypes) {\n                if (type.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(type);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":8375},"attached_assets/HyserCore_1756879987055.java":{"content":"package com.hyser.hysercore;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport com.hyser.hysercore.managers.ChatGameManager;\nimport com.hyser.hysercore.commands.ChatGamesCommand;\nimport com.hyser.hysercore.utils.PlayerStats;\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.commands.SwordEnchantCommand;\nimport com.hyser.hysercore.enchantments.commands.EnchantBookCommand;\nimport com.hyser.hysercore.enchantments.listeners.SwordEnchantmentListener;\nimport com.hyser.hysercore.enchantments.listeners.AntiAutoArmorListener;\nimport com.hyser.hysercore.enchantments.listeners.EnchantmentBookListener;\nimport com.hyser.hysercore.waypoints.LunarWaypoints;\nimport com.hyser.hysercore.waypoints.WaypointsCommand;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class HyserCore extends JavaPlugin implements Listener {\n\n    private ChatGameManager gameManager;\n    private ChatGamesCommand chatGamesCommand;\n    private FileConfiguration chatGamesConfig;\n    private File chatGamesConfigFile;\n    private SwordEnchantmentManager enchantmentManager;\n    private LunarWaypoints waypointManager;\n\n    @Override\n    public void onEnable() {\n        // Registrar eventos\n        getServer().getPluginManager().registerEvents(this, this);\n        \n        // Crear directorio de configuraci√≥n si no existe\n        if (!getDataFolder().exists()) {\n            getDataFolder().mkdirs();\n        }\n        \n        // Cargar configuraciones\n        saveDefaultConfig();\n        loadChatGamesConfig();\n        \n        // Inicializar sistema de ChatGames\n        gameManager = new ChatGameManager(this);\n        getServer().getPluginManager().registerEvents(gameManager, this);\n        \n        // Inicializar sistema de Sword Enchantments\n        enchantmentManager = new SwordEnchantmentManager(this);\n        getServer().getPluginManager().registerEvents(new SwordEnchantmentListener(enchantmentManager), this);\n        getServer().getPluginManager().registerEvents(new AntiAutoArmorListener(enchantmentManager.getConfig()), this);\n        getServer().getPluginManager().registerEvents(new EnchantmentBookListener(enchantmentManager), this);\n        \n        // Inicializar sistema de LunarWaypoints\n        waypointManager = new LunarWaypoints(this);\n        \n        // Registrar comandos\n        chatGamesCommand = new ChatGamesCommand(this, gameManager);\n        getCommand(\"chatgames\").setExecutor(chatGamesCommand);\n        getCommand(\"chatgames\").setTabCompleter(chatGamesCommand);\n        \n        SwordEnchantCommand enchantCommand = new SwordEnchantCommand(this, enchantmentManager);\n        getCommand(\"swordenchant\").setExecutor(enchantCommand);\n        getCommand(\"swordenchant\").setTabCompleter(enchantCommand);\n        \n        EnchantBookCommand bookCommand = new EnchantBookCommand(enchantmentManager);\n        getCommand(\"enchantbook\").setExecutor(bookCommand);\n        getCommand(\"enchantbook\").setTabCompleter(bookCommand);\n        \n        WaypointsCommand waypointsCommand = new WaypointsCommand(this, waypointManager);\n        getCommand(\"waypoints\").setExecutor(waypointsCommand);\n        getCommand(\"waypoints\").setTabCompleter(waypointsCommand);\n        \n        // Mensaje de inicio\n        getLogger().info(\"=================================\");\n        getLogger().info(\"     HyserCore ChatGames v1.0.0\");\n        getLogger().info(\"=================================\");\n        getLogger().info(\"Plugin habilitado correctamente!\");\n        getLogger().info(\"Sistema de ChatGames cargado.\");\n        getLogger().info(\"Sistema de Sword Enchantments cargado.\");\n        getLogger().info(\"Sistema de LunarWaypoints cargado.\");\n        \n        boolean enabled = chatGamesConfig.getBoolean(\"general.enabled\", true);\n        getLogger().info(\"ChatGames: \" + (enabled ? \"HABILITADO\" : \"DESHABILITADO\"));\n        \n        if (enabled) {\n            int minPlayers = chatGamesConfig.getInt(\"general.min-players\", 3);\n            int minInterval = chatGamesConfig.getInt(\"general.interval.min\", 300);\n            int maxInterval = chatGamesConfig.getInt(\"general.interval.max\", 600);\n            getLogger().info(\"Intervalo de juegos: \" + minInterval + \"-\" + maxInterval + \" segundos\");\n            getLogger().info(\"Jugadores m√≠nimos: \" + minPlayers);\n        }\n        \n        getLogger().info(\"Tipos de juegos disponibles:\");\n        if (chatGamesConfig.getBoolean(\"game-types.math.enabled\", true)) {\n            getLogger().info(\"- Matem√°ticas\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.word.enabled\", true)) {\n            getLogger().info(\"- Palabras\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.trivia.enabled\", true)) {\n            getLogger().info(\"- Trivia\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.complete.enabled\", true)) {\n            getLogger().info(\"- Completar frases\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.number.enabled\", true)) {\n            getLogger().info(\"- Adivinar n√∫meros\");\n        }\n        \n        getLogger().info(\"=================================\");\n    }\n\n    @Override\n    public void onDisable() {\n        getLogger().info(\"Deshabilitando HyserCore ChatGames...\");\n        \n        if (gameManager != null) {\n            gameManager.shutdown();\n        }\n        \n        // Guardar configuraciones\n        saveChatGamesConfig();\n        \n        getLogger().info(\"HyserCore ChatGames deshabilitado correctamente!\");\n    }\n    \n    private void loadChatGamesConfig() {\n        chatGamesConfigFile = new File(getDataFolder(), \"chatgames.yml\");\n        if (!chatGamesConfigFile.exists()) {\n            saveResource(\"chatgames.yml\", false);\n        }\n        chatGamesConfig = YamlConfiguration.loadConfiguration(chatGamesConfigFile);\n        \n        // Verificar integridad de la configuraci√≥n\n        validateConfig();\n    }\n    \n    private void validateConfig() {\n        boolean needsSave = false;\n        \n        // Verificar configuraci√≥n general\n        if (!chatGamesConfig.contains(\"general.enabled\")) {\n            chatGamesConfig.set(\"general.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.prefix\")) {\n            chatGamesConfig.set(\"general.prefix\", \"&7[&6ChatGames&7] &r\");\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.interval.min\")) {\n            chatGamesConfig.set(\"general.interval.min\", 300);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.interval.max\")) {\n            chatGamesConfig.set(\"general.interval.max\", 600);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.duration\")) {\n            chatGamesConfig.set(\"general.duration\", 60);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.min-players\")) {\n            chatGamesConfig.set(\"general.min-players\", 3);\n            needsSave = true;\n        }\n        \n        // Verificar tipos de juegos\n        if (!chatGamesConfig.contains(\"game-types.math.enabled\")) {\n            chatGamesConfig.set(\"game-types.math.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.word.enabled\")) {\n            chatGamesConfig.set(\"game-types.word.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.trivia.enabled\")) {\n            chatGamesConfig.set(\"game-types.trivia.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.complete.enabled\")) {\n            chatGamesConfig.set(\"game-types.complete.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.number.enabled\")) {\n            chatGamesConfig.set(\"game-types.number.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (needsSave) {\n            saveChatGamesConfig();\n            getLogger().info(\"Configuraci√≥n de ChatGames actualizada con valores por defecto.\");\n        }\n    }\n    \n    public void saveChatGamesConfig() {\n        try {\n            chatGamesConfig.save(chatGamesConfigFile);\n        } catch (IOException e) {\n            getLogger().severe(\"No se pudo guardar chatgames.yml: \" + e.getMessage());\n        }\n    }\n    \n    public FileConfiguration getChatGamesConfig() {\n        return chatGamesConfig;\n    }\n    \n    public void reloadChatGamesConfig() {\n        chatGamesConfig = YamlConfiguration.loadConfiguration(chatGamesConfigFile);\n        validateConfig();\n    }\n\n    @EventHandler\n    public void onPlayerJoin(PlayerJoinEvent event) {\n        Player player = event.getPlayer();\n        \n        // Verificar si los mensajes de bienvenida est√°n habilitados\n        if (!getConfig().getBoolean(\"show-welcome-message\", true)) {\n            return;\n        }\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            chatGamesConfig.getString(\"general.prefix\", \"&7[&6ChatGames&7] &r\"));\n        \n        // Enviar mensaje de bienvenida con informaci√≥n sobre ChatGames\n        player.sendMessage(prefix + ChatColor.GOLD + \"¬°Bienvenido al servidor!\");\n        \n        if (chatGamesConfig.getBoolean(\"general.enabled\", true)) {\n            player.sendMessage(prefix + ChatColor.AQUA + \"¬°Los ChatGames est√°n activos! Participa y gana recompensas.\");\n            \n            // Mostrar estad√≠sticas del jugador si existen\n            if (gameManager != null) {\n                PlayerStats stats = gameManager.getPlayerStats();\n                int gamesPlayed = stats.getGamesPlayed(player.getUniqueId());\n                if (gamesPlayed > 0) {\n                    int gamesWon = stats.getGamesWon(player.getUniqueId());\n                    double winRate = stats.getWinRate(player.getUniqueId());\n                    player.sendMessage(prefix + ChatColor.YELLOW + \"Tus estad√≠sticas: \" + \n                        ChatColor.WHITE + gamesPlayed + \" jugados, \" + \n                        ChatColor.GREEN + gamesWon + \" ganados \" +\n                        ChatColor.GRAY + \"(\" + String.format(\"%.1f\", winRate) + \"%)\");\n                }\n            }\n        }\n        \n        // Log para el servidor\n        getLogger().info(\"Jugador \" + player.getName() + \" se ha conectado al servidor\");\n    }\n    \n    // Comando de informaci√≥n adicional (opcional)\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        // Este m√©todo puede manejar comandos adicionales si es necesario\n        // Por ahora, todos los comandos principales son manejados por ChatGamesCommand\n        return false;\n    }\n    \n    // M√©todos de utilidad para otros plugins o expansiones futuras\n    public ChatGameManager getGameManager() {\n        return gameManager;\n    }\n    \n    public boolean isGameActive() {\n        return gameManager != null && gameManager.isGameActive();\n    }\n    \n    public void forceStartGame(String gameType) {\n        if (gameManager != null) {\n            gameManager.forceStartGame(gameType);\n        }\n    }\n    \n    public void stopCurrentGame() {\n        if (gameManager != null) {\n            gameManager.stopCurrentGame();\n        }\n    }\n    \n    // M√©todo para obtener estad√≠sticas de un jugador (API para otros plugins)\n    public PlayerStats getPlayerStats() {\n        return gameManager != null ? gameManager.getPlayerStats() : null;\n    }\n    \n    // M√©todo para comprobar si los ChatGames est√°n habilitados\n    public boolean isChatGamesEnabled() {\n        return chatGamesConfig.getBoolean(\"general.enabled\", true);\n    }\n    \n    // M√©todo para habilitar/deshabilitar ChatGames program√°ticamente\n    public void setChatGamesEnabled(boolean enabled) {\n        chatGamesConfig.set(\"general.enabled\", enabled);\n        saveChatGamesConfig();\n        if (gameManager != null) {\n            gameManager.reloadConfig();\n        }\n    }\n}","size_bytes":12538},"attached_assets/LunarWaypoints_1756879982454.java":{"content":"package com.hyser.hysercore.waypoints;\n\nimport com.hyser.hysercore.HyserCore;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Location;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class LunarWaypoints {\n    \n    private HyserCore plugin;\n    private FileConfiguration config;\n    private Map<UUID, Location> clanWaypoints;\n    private Plugin ultimateClans;\n    \n    public LunarWaypoints(HyserCore plugin) {\n        this.plugin = plugin;\n        this.config = plugin.getConfig();\n        this.clanWaypoints = new HashMap<>();\n        \n        // Verificar si UltimateClans est√° disponible\n        this.ultimateClans = Bukkit.getPluginManager().getPlugin(\"UltimateClans\");\n        if (ultimateClans == null) {\n            plugin.getLogger().warning(\"UltimateClans no encontrado. LunarWaypoints funcionar√° sin integraci√≥n de clanes.\");\n        } else {\n            plugin.getLogger().info(\"UltimateClans detectado. Integraci√≥n activada.\");\n        }\n    }\n    \n    public boolean setWaypoint(Player player, String waypointName, Location location) {\n        if (!config.getBoolean(\"lunar-waypoints.enabled\", true)) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.system-disabled\", \n                \"&cEl sistema de waypoints est√° deshabilitado.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        // Verificar permisos\n        if (!player.hasPermission(\"hysercore.waypoints\") && !player.hasPermission(\"hysercore.admin\")) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-permission\", \n                \"&cNo tienes permisos para usar waypoints.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        String clanName = getClanName(player);\n        if (clanName == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-clan\", \n                \"&cDebes estar en un clan para establecer waypoints.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        // Generar clave √∫nica para el waypoint del clan\n        String waypointKey = clanName + \":\" + waypointName;\n        \n        // Verificar l√≠mite de waypoints por clan\n        int maxWaypoints = config.getInt(\"lunar-waypoints.max-waypoints-per-clan\", 3);\n        long currentWaypoints = clanWaypoints.entrySet().stream()\n            .filter(entry -> getClanName(Bukkit.getPlayer(entry.getKey())) != null && \n                            getClanName(Bukkit.getPlayer(entry.getKey())).equals(clanName))\n            .count();\n        \n        if (currentWaypoints >= maxWaypoints && !clanWaypoints.containsKey(player.getUniqueId())) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.max-waypoints\", \n                \"&cTu clan ya tiene el m√°ximo de waypoints permitidos ({max}).\")\n                .replace(\"{max}\", String.valueOf(maxWaypoints)));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        // Establecer waypoint\n        clanWaypoints.put(player.getUniqueId(), location.clone());\n        \n        String successMessage = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lunar-waypoints.messages.waypoint-set\", \n            \"&a¬°Waypoint '{name}' establecido para el clan {clan}!\")\n            .replace(\"{name}\", waypointName)\n            .replace(\"{clan}\", clanName));\n        player.sendMessage(successMessage);\n        \n        return true;\n    }\n    \n    public void showWaypoints(Player player) {\n        if (!config.getBoolean(\"lunar-waypoints.enabled\", true)) {\n            return;\n        }\n        \n        String clanName = getClanName(player);\n        if (clanName == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-clan\", \n                \"&cDebes estar en un clan para ver waypoints.\"));\n            player.sendMessage(message);\n            return;\n        }\n        \n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&b&l                    WAYPOINTS DEL CLAN \" + clanName.toUpperCase()));\n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n        \n        boolean foundWaypoints = false;\n        for (Player clanMember : Bukkit.getOnlinePlayers()) {\n            String memberClan = getClanName(clanMember);\n            if (memberClan != null && memberClan.equals(clanName)) {\n                Location waypoint = clanWaypoints.get(clanMember.getUniqueId());\n                if (waypoint != null) {\n                    // Verificar que el waypoint est√© en el mismo mundo\n                    if (!waypoint.getWorld().getName().equals(player.getWorld().getName())) {\n                        continue; // No mostrar waypoints de otros mundos\n                    }\n                    \n                    double distance = player.getLocation().distance(waypoint);\n                    String direction = getDirection(player.getLocation(), waypoint);\n                    \n                    String waypointInfo = ChatColor.translateAlternateColorCodes('&', \n                        config.getString(\"lunar-waypoints.messages.waypoint-info\", \n                        \"&f‚óè &b{player} &7- &e{distance}m &7{direction}\")\n                        .replace(\"{player}\", clanMember.getName())\n                        .replace(\"{distance}\", String.format(\"%.1f\", distance))\n                        .replace(\"{direction}\", direction));\n                    \n                    player.sendMessage(waypointInfo);\n                    foundWaypoints = true;\n                }\n            }\n        }\n        \n        if (!foundWaypoints) {\n            player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-waypoints\", \n                \"&7No hay waypoints establecidos en tu clan.\")));\n        }\n        \n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n    }\n    \n    public boolean removeWaypoint(Player player) {\n        if (clanWaypoints.containsKey(player.getUniqueId())) {\n            clanWaypoints.remove(player.getUniqueId());\n            \n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.waypoint-removed\", \n                \"&cWaypoint eliminado.\"));\n            player.sendMessage(message);\n            return true;\n        }\n        \n        String message = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lunar-waypoints.messages.no-waypoint\", \n            \"&cNo tienes ning√∫n waypoint establecido.\"));\n        player.sendMessage(message);\n        return false;\n    }\n    \n    private String getClanName(Player player) {\n        if (ultimateClans == null || player == null) {\n            return null;\n        }\n        \n        try {\n            // Usar reflexi√≥n para acceder a la API de UltimateClans\n            Class<?> ultimateClansAPI = Class.forName(\"me.ulrichbg.UltimateClans.API.UltimateClansAPI\");\n            Object apiInstance = ultimateClansAPI.getMethod(\"getInstance\").invoke(null);\n            Object clan = ultimateClansAPI.getMethod(\"getPlayerClan\", UUID.class).invoke(apiInstance, player.getUniqueId());\n            \n            if (clan != null) {\n                return (String) clan.getClass().getMethod(\"getName\").invoke(clan);\n            }\n        } catch (Exception e) {\n            // Si falla la integraci√≥n, intentar m√©todo alternativo\n            plugin.getLogger().warning(\"Error al acceder a UltimateClans API: \" + e.getMessage());\n        }\n        \n        return null;\n    }\n    \n    private String getDirection(Location from, Location to) {\n        double dx = to.getX() - from.getX();\n        double dz = to.getZ() - from.getZ();\n        \n        double angle = Math.atan2(dz, dx) * 180 / Math.PI;\n        \n        if (angle < 0) {\n            angle += 360;\n        }\n        \n        if (angle >= 337.5 || angle < 22.5) {\n            return \"‚Üí Este\";\n        } else if (angle >= 22.5 && angle < 67.5) {\n            return \"‚Üò Sureste\";\n        } else if (angle >= 67.5 && angle < 112.5) {\n            return \"‚Üì Sur\";\n        } else if (angle >= 112.5 && angle < 157.5) {\n            return \"‚Üô Suroeste\";\n        } else if (angle >= 157.5 && angle < 202.5) {\n            return \"‚Üê Oeste\";\n        } else if (angle >= 202.5 && angle < 247.5) {\n            return \"‚Üñ Noroeste\";\n        } else if (angle >= 247.5 && angle < 292.5) {\n            return \"‚Üë Norte\";\n        } else {\n            return \"‚Üó Noreste\";\n        }\n    }\n}","size_bytes":9901},"attached_assets/MathGame_1756880005306.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class MathGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public MathGame(FileConfiguration config) {\n        super(\"Matem√°ticas\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        String[] difficulties = {\"easy\", \"medium\", \"hard\"};\n        String difficulty = difficulties[ThreadLocalRandom.current().nextInt(difficulties.length)];\n        \n        String[] operations = config.getStringList(\"game-types.math.difficulty.\" + difficulty + \".operations\").toArray(new String[0]);\n        int[] range = config.getIntegerList(\"game-types.math.difficulty.\" + difficulty + \".range\").stream().mapToInt(i -> i).toArray();\n        \n        if (operations.length == 0) {\n            operations = new String[]{\"suma\", \"resta\", \"multiplicacion\"};\n        }\n        if (range.length < 2) {\n            range = new int[]{1, 50};\n        }\n        \n        String operation = operations[ThreadLocalRandom.current().nextInt(operations.length)];\n        \n        int num1 = ThreadLocalRandom.current().nextInt(range[0], range[1] + 1);\n        int num2 = ThreadLocalRandom.current().nextInt(range[0], range[1] + 1);\n        int result;\n        \n        switch (operation.toLowerCase()) {\n            case \"suma\":\n                result = num1 + num2;\n                question = \"¬øCu√°nto es \" + num1 + \" + \" + num2 + \"?\";\n                break;\n            case \"resta\":\n                if (num1 < num2) {\n                    int temp = num1;\n                    num1 = num2;\n                    num2 = temp;\n                }\n                result = num1 - num2;\n                question = \"¬øCu√°nto es \" + num1 + \" - \" + num2 + \"?\";\n                break;\n            case \"multiplicacion\":\n                // Para multiplicaci√≥n, usar n√∫meros m√°s peque√±os\n                num1 = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 15));\n                num2 = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 15));\n                result = num1 * num2;\n                question = \"¬øCu√°nto es \" + num1 + \" √ó \" + num2 + \"?\";\n                break;\n            case \"division\":\n                // Para divisi√≥n, asegurar que sea exacta\n                num2 = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 10));\n                result = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 20));\n                num1 = num2 * result;\n                question = \"¬øCu√°nto es \" + num1 + \" √∑ \" + num2 + \"?\";\n                break;\n            default:\n                result = num1 + num2;\n                question = \"¬øCu√°nto es \" + num1 + \" + \" + num2 + \"?\";\n                break;\n        }\n        \n        answer = String.valueOf(result);\n        hints = new String[]{\n            \"Es un n√∫mero \" + (result % 2 == 0 ? \"par\" : \"impar\"),\n            \"Est√° entre \" + Math.max(0, result - 10) + \" y \" + (result + 10),\n            \"La respuesta es \" + result\n        };\n    }\n}","size_bytes":3157},"attached_assets/NumberGame_1756880005307.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class NumberGame extends ChatGame {\n    \n    private FileConfiguration config;\n    private int targetNumber;\n    \n    public NumberGame(FileConfiguration config) {\n        super(\"Adivinar N√∫mero\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        int[] range = config.getIntegerList(\"game-types.number.range\").stream().mapToInt(i -> i).toArray();\n        if (range.length < 2) {\n            range = new int[]{1, 1000};\n        }\n        \n        targetNumber = ThreadLocalRandom.current().nextInt(range[0], range[1] + 1);\n        answer = String.valueOf(targetNumber);\n        \n        question = \"Adivina el n√∫mero entre \" + range[0] + \" y \" + range[1];\n        \n        // Generar pistas matem√°ticas\n        String parity = targetNumber % 2 == 0 ? \"par\" : \"impar\";\n        String range1 = \"Est√° entre \" + Math.max(range[0], targetNumber - 50) + \" y \" + Math.min(range[1], targetNumber + 50);\n        String range2 = \"Est√° entre \" + Math.max(range[0], targetNumber - 20) + \" y \" + Math.min(range[1], targetNumber + 20);\n        \n        // Pistas adicionales basadas en propiedades del n√∫mero\n        String divisibility = \"\";\n        if (targetNumber % 10 == 0) {\n            divisibility = \"Es m√∫ltiplo de 10\";\n        } else if (targetNumber % 5 == 0) {\n            divisibility = \"Es m√∫ltiplo de 5\";\n        } else if (targetNumber % 3 == 0) {\n            divisibility = \"Es m√∫ltiplo de 3\";\n        } else {\n            divisibility = \"No es m√∫ltiplo de 5\";\n        }\n        \n        hints = new String[]{\n            \"Es un n√∫mero \" + parity,\n            divisibility,\n            range1,\n            range2,\n            \"El n√∫mero es \" + targetNumber\n        };\n    }\n    \n    @Override\n    public boolean checkAnswer(String playerAnswer) {\n        try {\n            int playerNumber = Integer.parseInt(playerAnswer.trim());\n            return playerNumber == targetNumber;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n}","size_bytes":2207},"attached_assets/PlayerStats_1756879991341.java":{"content":"package com.hyser.hysercore.utils;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class PlayerStats {\n    \n    private Map<UUID, Integer> gamesPlayed;\n    private Map<UUID, Integer> gamesWon;\n    private Map<UUID, Integer> totalRewards;\n    \n    public PlayerStats() {\n        this.gamesPlayed = new HashMap<>();\n        this.gamesWon = new HashMap<>();\n        this.totalRewards = new HashMap<>();\n    }\n    \n    public void addGame(UUID playerId) {\n        gamesPlayed.put(playerId, gamesPlayed.getOrDefault(playerId, 0) + 1);\n    }\n    \n    public void addWin(UUID playerId) {\n        gamesWon.put(playerId, gamesWon.getOrDefault(playerId, 0) + 1);\n    }\n    \n    public void addReward(UUID playerId, int amount) {\n        totalRewards.put(playerId, totalRewards.getOrDefault(playerId, 0) + amount);\n    }\n    \n    public int getGamesPlayed(UUID playerId) {\n        return gamesPlayed.getOrDefault(playerId, 0);\n    }\n    \n    public int getGamesWon(UUID playerId) {\n        return gamesWon.getOrDefault(playerId, 0);\n    }\n    \n    public int getTotalRewards(UUID playerId) {\n        return totalRewards.getOrDefault(playerId, 0);\n    }\n    \n    public double getWinRate(UUID playerId) {\n        int played = getGamesPlayed(playerId);\n        if (played == 0) {\n            return 0.0;\n        }\n        return (double) getGamesWon(playerId) / played * 100.0;\n    }\n    \n    public Map<UUID, Integer> getTopPlayers(int limit) {\n        return gamesWon.entrySet().stream()\n            .sorted(Map.Entry.<UUID, Integer>comparingByValue().reversed())\n            .limit(limit)\n            .collect(java.util.stream.Collectors.toMap(\n                Map.Entry::getKey,\n                Map.Entry::getValue,\n                (e1, e2) -> e1,\n                java.util.LinkedHashMap::new\n            ));\n    }\n}","size_bytes":1839},"attached_assets/SwordEnchantCommand_1756880012090.java":{"content":"package com.hyser.hysercore.enchantments.commands;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SwordEnchantCommand implements CommandExecutor, TabCompleter {\n    \n    private HyserCore plugin;\n    private SwordEnchantmentManager enchantmentManager;\n    \n    public SwordEnchantCommand(HyserCore plugin, SwordEnchantmentManager enchantmentManager) {\n        this.plugin = plugin;\n        this.enchantmentManager = enchantmentManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Este comando solo puede ser usado por jugadores.\");\n            return true;\n        }\n        \n        Player player = (Player) sender;\n        \n        if (!player.hasPermission(\"hysercore.swordenchant\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            player.sendMessage(noPermission);\n            return true;\n        }\n        \n        if (args.length == 0) {\n            sendHelp(player);\n            return true;\n        }\n        \n        String subCommand = args[0].toLowerCase();\n        \n        switch (subCommand) {\n            case \"reload\":\n                handleReload(player);\n                break;\n            case \"list\":\n                handleList(player);\n                break;\n            case \"dash\":\n                enchantmentManager.applySwordEnchantment(player, \"dash\");\n                break;\n            case \"ice_aspect\":\n            case \"iceaspect\":\n                enchantmentManager.applySwordEnchantment(player, \"ice_aspect\");\n                break;\n            case \"sharpness\":\n                enchantmentManager.applySwordEnchantment(player, \"sharpness\");\n                break;\n            case \"lifesteal\":\n                enchantmentManager.applySwordEnchantment(player, \"lifesteal\");\n                break;\n            case \"vampire\":\n                enchantmentManager.applySwordEnchantment(player, \"vampire\");\n                break;\n            case \"bleeding\":\n                enchantmentManager.applySwordEnchantment(player, \"bleeding\");\n                break;\n            case \"explosive\":\n                enchantmentManager.applySwordEnchantment(player, \"explosive\");\n                break;\n            case \"executioner\":\n                enchantmentManager.applySwordEnchantment(player, \"executioner\");\n                break;\n            case \"help\":\n            default:\n                sendHelp(player);\n                break;\n        }\n        \n        return true;\n    }\n    \n    private void handleReload(CommandSender sender) {\n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            sender.sendMessage(noPermission);\n            return;\n        }\n        \n        enchantmentManager.reloadConfig();\n        String reloadMessage = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"messages.config-reloaded\", \"&aConfiguraci√≥n de Sword Enchantments recargada correctamente.\"));\n        sender.sendMessage(reloadMessage);\n    }\n    \n    private void handleList(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"general.prefix\", \"&8[&bSwordEnchant&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Encantamientos Disponibles ===\");\n        \n        for (SwordEnchantment enchant : enchantmentManager.getAllEnchantments().values()) {\n            player.sendMessage(ChatColor.YELLOW + \"‚Ä¢ \" + ChatColor.WHITE + enchant.getDisplayName() + \n                ChatColor.GRAY + \" - \" + enchant.getLoreText());\n        }\n        \n        player.sendMessage(ChatColor.GRAY + \"Uso: /swordenchant <tipo>\");\n    }\n    \n    private void sendHelp(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"general.prefix\", \"&8[&bSwordEnchant&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Comandos de Sword Enchantments ===\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant dash\" + ChatColor.GRAY + \" - Aplicar encantamiento Dash\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant iceaspect\" + ChatColor.GRAY + \" - Aplicar encantamiento Ice Aspect\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant sharpness\" + ChatColor.GRAY + \" - Aplicar encantamiento Sharpness+\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant lifesteal\" + ChatColor.GRAY + \" - Aplicar encantamiento Lifesteal\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant vampire\" + ChatColor.GRAY + \" - Aplicar encantamiento Vampire\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant bleeding\" + ChatColor.GRAY + \" - Aplicar encantamiento Bleeding\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant explosive\" + ChatColor.GRAY + \" - Aplicar encantamiento Explosive\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant executioner\" + ChatColor.GRAY + \" - Aplicar encantamiento Executioner\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant list\" + ChatColor.GRAY + \" - Ver encantamientos disponibles\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant reload\" + ChatColor.GRAY + \" - Recargar configuraci√≥n\");\n        player.sendMessage(ChatColor.GRAY + \"Necesitas tener una espada en la mano para aplicar encantamientos.\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.swordenchant\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] subCommands = {\"dash\", \"iceaspect\", \"ice_aspect\", \"sharpness\", \"lifesteal\", \"vampire\", \"bleeding\", \"explosive\", \"executioner\", \"list\", \"help\"};\n            \n            // Agregar reload si tiene permisos de admin\n            if (sender.hasPermission(\"hysercore.admin\")) {\n                List<String> allCommands = new ArrayList<>(Arrays.asList(subCommands));\n                allCommands.add(\"reload\");\n                subCommands = allCommands.toArray(new String[0]);\n            }\n            \n            for (String subCommand : subCommands) {\n                if (subCommand.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(subCommand);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":7453},"attached_assets/SwordEnchantmentManager_1756880022071.java":{"content":"package com.hyser.hysercore.enchantments.managers;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.enchantments.types.DashEnchantment;\nimport com.hyser.hysercore.enchantments.types.IceAspectEnchantment;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\nimport com.hyser.hysercore.enchantments.types.SharpnessEnchantment;\nimport com.hyser.hysercore.enchantments.types.LifestealEnchantment;\nimport com.hyser.hysercore.enchantments.types.VampireEnchantment;\nimport com.hyser.hysercore.enchantments.types.BleedingEnchantment;\nimport com.hyser.hysercore.enchantments.types.ExplosiveEnchantment;\nimport com.hyser.hysercore.enchantments.types.ExecutionerEnchantment;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SwordEnchantmentManager {\n    \n    private HyserCore plugin;\n    private FileConfiguration config;\n    private Map<String, SwordEnchantment> enchantments;\n    \n    public SwordEnchantmentManager(HyserCore plugin) {\n        this.plugin = plugin;\n        this.enchantments = new HashMap<>();\n        loadConfig();\n        registerEnchantments();\n    }\n    \n    public void loadConfig() {\n        File configFile = new File(plugin.getDataFolder(), \"swordenchants.yml\");\n        if (!configFile.exists()) {\n            plugin.saveResource(\"swordenchants.yml\", false);\n        }\n        config = YamlConfiguration.loadConfiguration(configFile);\n    }\n    \n    public void reloadConfig() {\n        loadConfig();\n        enchantments.clear();\n        registerEnchantments();\n        plugin.getLogger().info(\"Configuraci√≥n de Sword Enchantments recargada\");\n    }\n    \n    private void registerEnchantments() {\n        // Registrar Dash\n        if (config.getBoolean(\"enchantments.dash.enabled\", true)) {\n            DashEnchantment dash = new DashEnchantment(config);\n            enchantments.put(\"dash\", dash);\n        }\n        \n        // Registrar Ice Aspect\n        if (config.getBoolean(\"enchantments.ice-aspect.enabled\", true)) {\n            IceAspectEnchantment iceAspect = new IceAspectEnchantment(config, plugin);\n            enchantments.put(\"ice_aspect\", iceAspect);\n        }\n        \n        // Registrar Sharpness+\n        if (config.getBoolean(\"enchantments.sharpness.enabled\", true)) {\n            SharpnessEnchantment sharpness = new SharpnessEnchantment(config);\n            enchantments.put(\"sharpness\", sharpness);\n        }\n        \n        // Registrar Lifesteal\n        if (config.getBoolean(\"enchantments.lifesteal.enabled\", true)) {\n            LifestealEnchantment lifesteal = new LifestealEnchantment(config);\n            enchantments.put(\"lifesteal\", lifesteal);\n        }\n        \n        // Registrar Vampire\n        if (config.getBoolean(\"enchantments.vampire.enabled\", true)) {\n            VampireEnchantment vampire = new VampireEnchantment(config);\n            enchantments.put(\"vampire\", vampire);\n        }\n        \n        // Registrar Bleeding\n        if (config.getBoolean(\"enchantments.bleeding.enabled\", true)) {\n            BleedingEnchantment bleeding = new BleedingEnchantment(config, plugin);\n            enchantments.put(\"bleeding\", bleeding);\n        }\n        \n        // Registrar Explosive\n        if (config.getBoolean(\"enchantments.explosive.enabled\", true)) {\n            ExplosiveEnchantment explosive = new ExplosiveEnchantment(config);\n            enchantments.put(\"explosive\", explosive);\n        }\n        \n        // Registrar Executioner\n        if (config.getBoolean(\"enchantments.executioner.enabled\", true)) {\n            ExecutionerEnchantment executioner = new ExecutionerEnchantment(config);\n            enchantments.put(\"executioner\", executioner);\n        }\n        \n        plugin.getLogger().info(\"Registrados \" + enchantments.size() + \" encantamientos de espada\");\n    }\n    \n    public boolean applySwordEnchantment(Player player, String enchantmentName) {\n        ItemStack item = player.getItemInHand();\n        \n        // Verificar que tenga una espada\n        if (!isSword(item)) {\n            String noSwordMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.no-sword\", \"&cDebes tener una espada en la mano.\"));\n            player.sendMessage(noSwordMessage);\n            return false;\n        }\n        \n        // Verificar que el encantamiento existe\n        SwordEnchantment enchantment = enchantments.get(enchantmentName.toLowerCase());\n        if (enchantment == null) {\n            String unknownEnchantMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.unknown-enchantment\", \"&cEncantamiento desconocido: {enchant}\")\n                .replace(\"{enchant}\", enchantmentName));\n            player.sendMessage(unknownEnchantMessage);\n            return false;\n        }\n        \n        // Verificar que no tenga ya el encantamiento\n        if (hasEnchantment(item, enchantment)) {\n            String alreadyHasMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.already-has-enchantment\", \"&cEsta espada ya tiene el encantamiento {enchant}.\")\n                .replace(\"{enchant}\", enchantment.getDisplayName()));\n            player.sendMessage(alreadyHasMessage);\n            return false;\n        }\n        \n        // Aplicar encantamiento\n        addEnchantmentToSword(item, enchantment);\n        \n        String successMessage = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"messages.enchantment-applied\", \"&aEncantamiento {enchant} aplicado exitosamente!\")\n            .replace(\"{enchant}\", enchantment.getDisplayName()));\n        player.sendMessage(successMessage);\n        \n        return true;\n    }\n    \n    private boolean isSword(ItemStack item) {\n        if (item == null || item.getType() == Material.AIR) {\n            return false;\n        }\n        \n        Material type = item.getType();\n        return type == Material.WOOD_SWORD || \n               type == Material.STONE_SWORD || \n               type == Material.IRON_SWORD || \n               type == Material.GOLD_SWORD || \n               type == Material.DIAMOND_SWORD ||\n               type.toString().contains(\"SWORD\");\n    }\n    \n    private boolean hasEnchantment(ItemStack item, SwordEnchantment enchantment) {\n        if (!item.hasItemMeta()) {\n            return false;\n        }\n        \n        ItemMeta meta = item.getItemMeta();\n        if (!meta.hasLore()) {\n            return false;\n        }\n        \n        List<String> lore = meta.getLore();\n        String enchantLore = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lore-format\", \"&b{enchant}\").replace(\"{enchant}\", enchantment.getLoreText()));\n        \n        for (String line : lore) {\n            if (ChatColor.stripColor(line).equals(ChatColor.stripColor(enchantLore))) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void addEnchantmentToSword(ItemStack item, SwordEnchantment enchantment) {\n        ItemMeta meta = item.getItemMeta();\n        if (meta == null) {\n            meta = item.getItemMeta(); // Crear meta si no existe\n        }\n        \n        List<String> lore = meta.hasLore() ? new ArrayList<>(meta.getLore()) : new ArrayList<>();\n        \n        String enchantLore = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lore-format\", \"&b{enchant}\").replace(\"{enchant}\", enchantment.getLoreText()));\n        lore.add(enchantLore);\n        \n        meta.setLore(lore);\n        item.setItemMeta(meta);\n    }\n    \n    public SwordEnchantment getEnchantment(String name) {\n        return enchantments.get(name.toLowerCase());\n    }\n    \n    public List<SwordEnchantment> getEnchantsOnSword(ItemStack sword) {\n        List<SwordEnchantment> foundEnchants = new ArrayList<>();\n        \n        if (!isSword(sword) || !sword.hasItemMeta() || !sword.getItemMeta().hasLore()) {\n            return foundEnchants;\n        }\n        \n        List<String> lore = sword.getItemMeta().getLore();\n        \n        for (SwordEnchantment enchant : enchantments.values()) {\n            String enchantLore = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lore-format\", \"&b{enchant}\").replace(\"{enchant}\", enchant.getLoreText()));\n            \n            for (String line : lore) {\n                if (ChatColor.stripColor(line).equals(ChatColor.stripColor(enchantLore))) {\n                    foundEnchants.add(enchant);\n                    break;\n                }\n            }\n        }\n        \n        return foundEnchants;\n    }\n    \n    public Map<String, SwordEnchantment> getAllEnchantments() {\n        return new HashMap<>(enchantments);\n    }\n    \n    public FileConfiguration getConfig() {\n        return config;\n    }\n}","size_bytes":9177},"attached_assets/TriviaGame_1756880005307.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class TriviaGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public TriviaGame(FileConfiguration config) {\n        super(\"Trivia\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        List<String> categories = config.getStringList(\"game-types.trivia.categories\");\n        if (categories.isEmpty()) {\n            categories = List.of(\"general\", \"minecraft\", \"historia\", \"ciencia\");\n        }\n        \n        String category = categories.get(ThreadLocalRandom.current().nextInt(categories.size()));\n        ConfigurationSection questionsSection = config.getConfigurationSection(\"questions.trivia.\" + category);\n        \n        if (questionsSection == null) {\n            generateDefaultQuestion(category);\n            return;\n        }\n        \n        List<Map<?, ?>> questionsList = (List<Map<?, ?>>) config.getList(\"questions.trivia.\" + category);\n        if (questionsList == null || questionsList.isEmpty()) {\n            generateDefaultQuestion(category);\n            return;\n        }\n        \n        Map<?, ?> selectedQuestion = questionsList.get(ThreadLocalRandom.current().nextInt(questionsList.size()));\n        \n        question = (String) selectedQuestion.get(\"question\");\n        answer = (String) selectedQuestion.get(\"answer\");\n        \n        List<String> hintsList = (List<String>) selectedQuestion.get(\"hints\");\n        if (hintsList != null) {\n            hints = hintsList.toArray(new String[0]);\n        } else {\n            hints = new String[]{\"Piensa bien\", \"Es de la categor√≠a \" + category, \"La respuesta es: \" + answer};\n        }\n    }\n    \n    private void generateDefaultQuestion(String category) {\n        switch (category.toLowerCase()) {\n            case \"minecraft\":\n                generateMinecraftQuestion();\n                break;\n            case \"general\":\n                generateGeneralQuestion();\n                break;\n            case \"historia\":\n                generateHistoryQuestion();\n                break;\n            case \"ciencia\":\n                generateScienceQuestion();\n                break;\n            default:\n                generateGeneralQuestion();\n                break;\n        }\n    }\n    \n    private void generateMinecraftQuestion() {\n        String[][] questions = {\n            {\"¬øQui√©n cre√≥ Minecraft?\", \"notch\", \"Su nombre real es Markus\", \"Fund√≥ Mojang\", \"La respuesta es Notch\"},\n            {\"¬øCu√°ntos ojos de ender necesitas para el portal?\", \"12\", \"Es un n√∫mero par\", \"M√°s de 10\", \"Son doce\"},\n            {\"¬øQu√© mob explota?\", \"creeper\", \"Es verde\", \"Hace sss\", \"Es un Creeper\"},\n            {\"¬øCu√°l es el bloque m√°s resistente?\", \"bedrock\", \"No se puede romper\", \"Est√° en el fondo\", \"Es Bedrock\"},\n            {\"¬øEn qu√© dimensi√≥n est√° el Wither?\", \"nether\", \"Es roja y caliente\", \"Hay lava\", \"Es el Nether\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n    \n    private void generateGeneralQuestion() {\n        String[][] questions = {\n            {\"¬øCu√°l es la capital de Espa√±a?\", \"madrid\", \"Es europea\", \"Empieza por M\", \"Es Madrid\"},\n            {\"¬øCu√°ntos continentes hay?\", \"7\", \"Es impar\", \"Menos de 10\", \"Son siete\"},\n            {\"¬øCu√°l es el planeta m√°s grande?\", \"jupiter\", \"Es gaseoso\", \"Empieza por J\", \"Es J√∫piter\"},\n            {\"¬øCu√°l es el oc√©ano m√°s grande?\", \"pacifico\", \"Entre Asia y Am√©rica\", \"Significa pac√≠fico\", \"Es el Pac√≠fico\"},\n            {\"¬øCu√°ntos d√≠as tiene un a√±o?\", \"365\", \"M√°s de 300\", \"Menos de 400\", \"Son 365\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n    \n    private void generateHistoryQuestion() {\n        String[][] questions = {\n            {\"¬øEn qu√© a√±o comenz√≥ la Segunda Guerra Mundial?\", \"1939\", \"Siglo XX\", \"D√©cada del 30\", \"Fue en 1939\"},\n            {\"¬øQui√©n fue el primer emperador romano?\", \"augusto\", \"Era Octavio\", \"Sobrino de C√©sar\", \"Fue Augusto\"},\n            {\"¬øEn qu√© a√±o descubri√≥ Am√©rica Col√≥n?\", \"1492\", \"Siglo XV\", \"D√©cada del 90\", \"Fue en 1492\"},\n            {\"¬øQui√©n pint√≥ la Mona Lisa?\", \"leonardo\", \"Fue italiano\", \"Del Renacimiento\", \"Leonardo da Vinci\"},\n            {\"¬øEn qu√© a√±o cay√≥ el Muro de Berl√≠n?\", \"1989\", \"Siglo XX\", \"D√©cada del 80\", \"Fue en 1989\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n    \n    private void generateScienceQuestion() {\n        String[][] questions = {\n            {\"¬øCu√°l es el elemento m√°s abundante en el universo?\", \"hidrogeno\", \"Es el m√°s ligero\", \"Su s√≠mbolo es H\", \"Es hidr√≥geno\"},\n            {\"¬øCu√°ntos huesos tiene el cuerpo humano?\", \"206\", \"M√°s de 200\", \"Menos de 210\", \"Son 206\"},\n            {\"¬øCu√°l es la velocidad de la luz?\", \"300000000\", \"300 millones\", \"Metros por segundo\", \"300.000.000 m/s\"},\n            {\"¬øCu√°l es el gas m√°s abundante en la atm√≥sfera?\", \"nitrogeno\", \"No es ox√≠geno\", \"Empieza por N\", \"Es nitr√≥geno\"},\n            {\"¬øCu√°ntos cromosomas tiene el ser humano?\", \"46\", \"Es par\", \"M√°s de 40\", \"Son 46\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n}","size_bytes":6131},"attached_assets/WaypointsCommand_1756879982457.java":{"content":"package com.hyser.hysercore.waypoints;\n\nimport com.hyser.hysercore.HyserCore;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class WaypointsCommand implements CommandExecutor, TabCompleter {\n    \n    private HyserCore plugin;\n    private LunarWaypoints waypointManager;\n    \n    public WaypointsCommand(HyserCore plugin, LunarWaypoints waypointManager) {\n        this.plugin = plugin;\n        this.waypointManager = waypointManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Este comando solo puede ser usado por jugadores.\");\n            return true;\n        }\n        \n        Player player = (Player) sender;\n        \n        if (args.length == 0) {\n            sendHelp(player);\n            return true;\n        }\n        \n        switch (args[0].toLowerCase()) {\n            case \"set\":\n                if (args.length < 2) {\n                    player.sendMessage(ChatColor.RED + \"Uso: /waypoints set <nombre>\");\n                    return true;\n                }\n                String waypointName = args[1];\n                waypointManager.setWaypoint(player, waypointName, player.getLocation());\n                break;\n                \n            case \"list\":\n            case \"show\":\n                waypointManager.showWaypoints(player);\n                break;\n                \n            case \"remove\":\n            case \"delete\":\n                waypointManager.removeWaypoint(player);\n                break;\n                \n            case \"help\":\n            default:\n                sendHelp(player);\n                break;\n        }\n        \n        return true;\n    }\n    \n    private void sendHelp(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            plugin.getConfig().getString(\"lunar-waypoints.messages.prefix\", \"&8[&bWaypoints&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Comandos de LunarWaypoints ===\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints set <nombre>\" + ChatColor.GRAY + \" - Establecer waypoint\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints list\" + ChatColor.GRAY + \" - Ver waypoints del clan\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints remove\" + ChatColor.GRAY + \" - Eliminar tu waypoint\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints help\" + ChatColor.GRAY + \" - Ver esta ayuda\");\n        player.sendMessage(ChatColor.GRAY + \"Los waypoints solo funcionan en el mismo mundo.\");\n        player.sendMessage(ChatColor.GRAY + \"Requiere estar en un clan (UltimateClans).\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.waypoints\") && !sender.hasPermission(\"hysercore.admin\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] subCommands = {\"set\", \"list\", \"show\", \"remove\", \"delete\", \"help\"};\n            for (String subCommand : subCommands) {\n                if (subCommand.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(subCommand);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":3717},"attached_assets/WordGame_1756880005308.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class WordGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public WordGame(FileConfiguration config) {\n        super(\"Palabras\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        List<String> words = config.getStringList(\"questions.words\");\n        if (words.isEmpty()) {\n            words = getDefaultWords();\n        }\n        \n        String originalWord = words.get(ThreadLocalRandom.current().nextInt(words.size()));\n        answer = originalWord.toLowerCase();\n        \n        String[] gameTypes = {\"scramble\", \"reverse\", \"riddle\"};\n        String gameType = gameTypes[ThreadLocalRandom.current().nextInt(gameTypes.length)];\n        \n        switch (gameType) {\n            case \"scramble\":\n                generateScrambleQuestion(originalWord);\n                break;\n            case \"reverse\":\n                generateReverseQuestion(originalWord);\n                break;\n            case \"riddle\":\n                generateRiddleQuestion(originalWord);\n                break;\n            default:\n                generateScrambleQuestion(originalWord);\n                break;\n        }\n    }\n    \n    private void generateScrambleQuestion(String word) {\n        List<Character> letters = new ArrayList<>();\n        for (char c : word.toCharArray()) {\n            letters.add(c);\n        }\n        Collections.shuffle(letters);\n        \n        StringBuilder scrambled = new StringBuilder();\n        for (char c : letters) {\n            scrambled.append(c);\n        }\n        \n        question = \"Ordena las letras: \" + scrambled.toString().toUpperCase();\n        hints = new String[]{\n            \"Es una palabra de \" + word.length() + \" letras\",\n            \"Empieza por \" + Character.toString(word.charAt(0)).toUpperCase(),\n            \"La palabra es: \" + word\n        };\n    }\n    \n    private void generateReverseQuestion(String word) {\n        StringBuilder reversed = new StringBuilder(word);\n        reversed.reverse();\n        \n        question = \"¬øQu√© palabra es al rev√©s? \" + reversed.toString().toUpperCase();\n        hints = new String[]{\n            \"Es una palabra de \" + word.length() + \" letras\",\n            \"Termina en \" + Character.toString(word.charAt(word.length() - 1)).toUpperCase(),\n            \"La palabra es: \" + word\n        };\n    }\n    \n    private void generateRiddleQuestion(String word) {\n        String riddle = generateRiddle(word.toLowerCase());\n        question = riddle;\n        hints = new String[]{\n            \"Es una palabra de \" + word.length() + \" letras\",\n            \"Empieza por \" + Character.toString(word.charAt(0)).toUpperCase(),\n            \"La palabra es: \" + word\n        };\n    }\n    \n    private String generateRiddle(String word) {\n        switch (word.toLowerCase()) {\n            case \"creeper\":\n                return \"Soy verde y exploto, ¬øqui√©n soy?\";\n            case \"enderdragon\":\n                return \"Soy el jefe final del End, ¬øqui√©n soy?\";\n            case \"diamante\":\n                return \"Soy azul y muy valioso en las minas, ¬øqu√© soy?\";\n            case \"redstone\":\n                return \"Soy rojo y conduzco electricidad en Minecraft, ¬øqu√© soy?\";\n            case \"nether\":\n                return \"Soy una dimensi√≥n roja y caliente, ¬øqu√© soy?\";\n            case \"zombie\":\n                return \"Camino lento y digo 'grrr', ¬øqui√©n soy?\";\n            case \"skeleton\":\n                return \"Disparo flechas y soy de huesos, ¬øqui√©n soy?\";\n            case \"spider\":\n                return \"Tengo ocho patas y trepo paredes, ¬øqui√©n soy?\";\n            case \"agua\":\n                return \"Soy l√≠quida y azul, ¬øqu√© soy?\";\n            case \"fuego\":\n                return \"Soy caliente y quemo, ¬øqu√© soy?\";\n            case \"monta√±a\":\n                return \"Soy alta y rocosa, ¬øqu√© soy?\";\n            case \"oc√©ano\":\n                return \"Soy grande y lleno de agua, ¬øqu√© soy?\";\n            case \"sol\":\n                return \"Ilumino el d√≠a, ¬øqu√© soy?\";\n            case \"luna\":\n                return \"Ilumino la noche, ¬øqu√© soy?\";\n            case \"estrella\":\n                return \"Brillo en el cielo nocturno, ¬øqu√© soy?\";\n            default:\n                return \"Adivina la palabra relacionada con: \" + word.substring(0, 1).toUpperCase() + \"_\".repeat(word.length() - 1);\n        }\n    }\n    \n    private List<String> getDefaultWords() {\n        List<String> defaultWords = new ArrayList<>();\n        defaultWords.add(\"minecraft\");\n        defaultWords.add(\"creeper\");\n        defaultWords.add(\"diamante\");\n        defaultWords.add(\"redstone\");\n        defaultWords.add(\"nether\");\n        defaultWords.add(\"portal\");\n        defaultWords.add(\"zombie\");\n        defaultWords.add(\"skeleton\");\n        defaultWords.add(\"spider\");\n        defaultWords.add(\"agua\");\n        defaultWords.add(\"fuego\");\n        defaultWords.add(\"tierra\");\n        defaultWords.add(\"aire\");\n        return defaultWords;\n    }\n}","size_bytes":5267},"src/main/java/com/hyser/hysercore/HyserCore.java":{"content":"package com.hyser.hysercore;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport com.hyser.hysercore.managers.ChatGameManager;\nimport com.hyser.hysercore.commands.ChatGamesCommand;\nimport com.hyser.hysercore.utils.PlayerStats;\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.commands.SwordEnchantCommand;\nimport com.hyser.hysercore.enchantments.commands.EnchantBookCommand;\nimport com.hyser.hysercore.enchantments.listeners.SwordEnchantmentListener;\nimport com.hyser.hysercore.enchantments.listeners.AntiAutoArmorListener;\nimport com.hyser.hysercore.enchantments.listeners.EnchantmentBookListener;\nimport com.hyser.hysercore.waypoints.LunarWaypoints;\nimport com.hyser.hysercore.waypoints.WaypointsCommand;\nimport com.hyser.hysercore.teamviewer.LunarTeamViewer;\nimport com.hyser.hysercore.teamviewer.TeamViewerCommand;\nimport com.hyser.hysercore.abilities.AbilityManager;\nimport com.hyser.hysercore.abilities.AbilityListener;\nimport com.hyser.hysercore.abilities.AbilityCommand;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class HyserCore extends JavaPlugin implements Listener {\n\n    private ChatGameManager gameManager;\n    private ChatGamesCommand chatGamesCommand;\n    private FileConfiguration chatGamesConfig;\n    private File chatGamesConfigFile;\n    private SwordEnchantmentManager enchantmentManager;\n    private LunarWaypoints waypointManager;\n    private LunarTeamViewer teamViewerManager;\n    private AbilityManager abilityManager;\n\n    @Override\n    public void onEnable() {\n        // Registrar eventos\n        getServer().getPluginManager().registerEvents(this, this);\n        \n        // Crear directorio de configuraci√≥n si no existe\n        if (!getDataFolder().exists()) {\n            getDataFolder().mkdirs();\n        }\n        \n        // Cargar configuraciones\n        saveDefaultConfig();\n        loadChatGamesConfig();\n        \n        // Inicializar sistema de ChatGames\n        gameManager = new ChatGameManager(this);\n        getServer().getPluginManager().registerEvents(gameManager, this);\n        \n        // Inicializar sistema de Sword Enchantments MEJORADO\n        enchantmentManager = new SwordEnchantmentManager(this);\n        getServer().getPluginManager().registerEvents(new SwordEnchantmentListener(enchantmentManager), this);\n        getServer().getPluginManager().registerEvents(new AntiAutoArmorListener(enchantmentManager.getConfig()), this);\n        getServer().getPluginManager().registerEvents(new EnchantmentBookListener(enchantmentManager), this);\n        \n        // Inicializar sistema de LunarWaypoints MEJORADO\n        waypointManager = new LunarWaypoints(this);\n        \n        // Inicializar sistema de LunarTeamViewer NUEVO\n        teamViewerManager = new LunarTeamViewer(this);\n        \n        // Inicializar sistema de Abilities NUEVO\n        abilityManager = new AbilityManager(this);\n        getServer().getPluginManager().registerEvents(new AbilityListener(abilityManager), this);\n        \n        \n        // Registrar comandos\n        chatGamesCommand = new ChatGamesCommand(this, gameManager);\n        getCommand(\"chatgames\").setExecutor(chatGamesCommand);\n        getCommand(\"chatgames\").setTabCompleter(chatGamesCommand);\n        \n        SwordEnchantCommand enchantCommand = new SwordEnchantCommand(this, enchantmentManager);\n        getCommand(\"swordenchant\").setExecutor(enchantCommand);\n        getCommand(\"swordenchant\").setTabCompleter(enchantCommand);\n        \n        EnchantBookCommand bookCommand = new EnchantBookCommand(enchantmentManager);\n        getCommand(\"enchantbook\").setExecutor(bookCommand);\n        getCommand(\"enchantbook\").setTabCompleter(bookCommand);\n        \n        WaypointsCommand waypointsCommand = new WaypointsCommand(this, waypointManager);\n        getCommand(\"waypoints\").setExecutor(waypointsCommand);\n        getCommand(\"waypoints\").setTabCompleter(waypointsCommand);\n        \n        TeamViewerCommand teamViewerCommand = new TeamViewerCommand(this, teamViewerManager);\n        getCommand(\"teamviewer\").setExecutor(teamViewerCommand);\n        getCommand(\"teamviewer\").setTabCompleter(teamViewerCommand);\n        \n        AbilityCommand abilityCommand = new AbilityCommand(this, abilityManager);\n        getCommand(\"abilities\").setExecutor(abilityCommand);\n        getCommand(\"abilities\").setTabCompleter(abilityCommand);\n        \n        \n        // Mensaje de inicio\n        getLogger().info(\"=================================\");\n        getLogger().info(\"     HyserCore v1.0.0 MEJORADO\");\n        getLogger().info(\"=================================\");\n        getLogger().info(\"Plugin habilitado correctamente!\");\n        getLogger().info(\"Sistema de ChatGames cargado.\");\n        getLogger().info(\"Sistema de Sword Enchantments cargado.\");\n        getLogger().info(\"Sistema de LunarWaypoints cargado.\");\n        getLogger().info(\"Sistema de LunarTeamViewer cargado.\");\n        getLogger().info(\"Sistema de Abilities Din√°micas cargado.\");\n        \n        boolean enabled = chatGamesConfig.getBoolean(\"general.enabled\", true);\n        getLogger().info(\"ChatGames: \" + (enabled ? \"HABILITADO\" : \"DESHABILITADO\"));\n        \n        if (enabled) {\n            int minPlayers = chatGamesConfig.getInt(\"general.min-players\", 3);\n            int minInterval = chatGamesConfig.getInt(\"general.interval.min\", 300);\n            int maxInterval = chatGamesConfig.getInt(\"general.interval.max\", 600);\n            getLogger().info(\"Intervalo de juegos: \" + minInterval + \"-\" + maxInterval + \" segundos\");\n            getLogger().info(\"Jugadores m√≠nimos: \" + minPlayers);\n        }\n        \n        getLogger().info(\"Tipos de juegos disponibles:\");\n        if (chatGamesConfig.getBoolean(\"game-types.math.enabled\", true)) {\n            getLogger().info(\"- Matem√°ticas\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.word.enabled\", true)) {\n            getLogger().info(\"- Palabras\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.trivia.enabled\", true)) {\n            getLogger().info(\"- Trivia\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.complete.enabled\", true)) {\n            getLogger().info(\"- Completar frases\");\n        }\n        if (chatGamesConfig.getBoolean(\"game-types.number.enabled\", true)) {\n            getLogger().info(\"- Adivinar n√∫meros\");\n        }\n        \n        getLogger().info(\"=================================\");\n    }\n\n    @Override\n    public void onDisable() {\n        getLogger().info(\"Deshabilitando HyserCore...\");\n        \n        if (gameManager != null) {\n            gameManager.shutdown();\n        }\n        \n        \n        // Guardar configuraciones\n        saveChatGamesConfig();\n        \n        getLogger().info(\"HyserCore deshabilitado correctamente!\");\n    }\n    \n    private void loadChatGamesConfig() {\n        chatGamesConfigFile = new File(getDataFolder(), \"chatgames.yml\");\n        if (!chatGamesConfigFile.exists()) {\n            saveResource(\"chatgames.yml\", false);\n        }\n        chatGamesConfig = YamlConfiguration.loadConfiguration(chatGamesConfigFile);\n        \n        // Verificar integridad de la configuraci√≥n\n        validateConfig();\n    }\n    \n    private void validateConfig() {\n        boolean needsSave = false;\n        \n        // Verificar configuraci√≥n general\n        if (!chatGamesConfig.contains(\"general.enabled\")) {\n            chatGamesConfig.set(\"general.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.prefix\")) {\n            chatGamesConfig.set(\"general.prefix\", \"&7[&6ChatGames&7] &r\");\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.interval.min\")) {\n            chatGamesConfig.set(\"general.interval.min\", 300);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.interval.max\")) {\n            chatGamesConfig.set(\"general.interval.max\", 600);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.duration\")) {\n            chatGamesConfig.set(\"general.duration\", 60);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"general.min-players\")) {\n            chatGamesConfig.set(\"general.min-players\", 3);\n            needsSave = true;\n        }\n        \n        // Verificar tipos de juegos\n        if (!chatGamesConfig.contains(\"game-types.math.enabled\")) {\n            chatGamesConfig.set(\"game-types.math.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.word.enabled\")) {\n            chatGamesConfig.set(\"game-types.word.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.trivia.enabled\")) {\n            chatGamesConfig.set(\"game-types.trivia.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.complete.enabled\")) {\n            chatGamesConfig.set(\"game-types.complete.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (!chatGamesConfig.contains(\"game-types.number.enabled\")) {\n            chatGamesConfig.set(\"game-types.number.enabled\", true);\n            needsSave = true;\n        }\n        \n        if (needsSave) {\n            saveChatGamesConfig();\n            getLogger().info(\"Configuraci√≥n de ChatGames actualizada con valores por defecto.\");\n        }\n    }\n    \n    public void saveChatGamesConfig() {\n        try {\n            chatGamesConfig.save(chatGamesConfigFile);\n        } catch (IOException e) {\n            getLogger().severe(\"No se pudo guardar chatgames.yml: \" + e.getMessage());\n        }\n    }\n    \n    public FileConfiguration getChatGamesConfig() {\n        return chatGamesConfig;\n    }\n    \n    public void reloadChatGamesConfig() {\n        chatGamesConfig = YamlConfiguration.loadConfiguration(chatGamesConfigFile);\n        validateConfig();\n    }\n\n    @EventHandler\n    public void onPlayerJoin(PlayerJoinEvent event) {\n        Player player = event.getPlayer();\n        \n        // Verificar si los mensajes de bienvenida est√°n habilitados\n        if (!getConfig().getBoolean(\"settings.show-welcome-message\", true)) {\n            return;\n        }\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            chatGamesConfig.getString(\"general.prefix\", \"&7[&6ChatGames&7] &r\"));\n        \n        // Enviar mensaje de bienvenida con informaci√≥n sobre ChatGames\n        player.sendMessage(prefix + ChatColor.GOLD + \"¬°Bienvenido al servidor!\");\n        \n        if (chatGamesConfig.getBoolean(\"general.enabled\", true)) {\n            player.sendMessage(prefix + ChatColor.AQUA + \"¬°Los ChatGames est√°n activos! Participa y gana recompensas.\");\n            \n            // Mostrar estad√≠sticas del jugador si existen\n            if (gameManager != null) {\n                PlayerStats stats = gameManager.getPlayerStats();\n                int gamesPlayed = stats.getGamesPlayed(player.getUniqueId());\n                if (gamesPlayed > 0) {\n                    int gamesWon = stats.getGamesWon(player.getUniqueId());\n                    double winRate = stats.getWinRate(player.getUniqueId());\n                    player.sendMessage(prefix + ChatColor.YELLOW + \"Tus estad√≠sticas: \" + \n                        ChatColor.WHITE + gamesPlayed + \" jugados, \" + \n                        ChatColor.GREEN + gamesWon + \" ganados \" +\n                        ChatColor.GRAY + \"(\" + String.format(\"%.1f\", winRate) + \"%)\");\n                }\n            }\n        }\n        \n        // Log para el servidor\n        getLogger().info(\"Jugador \" + player.getName() + \" se ha conectado al servidor\");\n    }\n    \n    // Comando de informaci√≥n adicional (opcional)\n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        // Este m√©todo puede manejar comandos adicionales si es necesario\n        // Por ahora, todos los comandos principales son manejados por ChatGamesCommand\n        return false;\n    }\n    \n    // M√©todos de utilidad para otros plugins o expansiones futuras\n    public ChatGameManager getGameManager() {\n        return gameManager;\n    }\n    \n    public SwordEnchantmentManager getEnchantmentManager() {\n        return enchantmentManager;\n    }\n    \n    public LunarWaypoints getWaypointManager() {\n        return waypointManager;\n    }\n    \n    public LunarTeamViewer getTeamViewerManager() {\n        return teamViewerManager;\n    }\n    \n    public AbilityManager getAbilityManager() {\n        return abilityManager;\n    }\n    \n    \n    public boolean isGameActive() {\n        return gameManager != null && gameManager.isGameActive();\n    }\n    \n    public void forceStartGame(String gameType) {\n        if (gameManager != null) {\n            gameManager.forceStartGame(gameType);\n        }\n    }\n    \n    public void stopCurrentGame() {\n        if (gameManager != null) {\n            gameManager.stopCurrentGame();\n        }\n    }\n    \n    // M√©todo para obtener estad√≠sticas de un jugador (API para otros plugins)\n    public PlayerStats getPlayerStats() {\n        return gameManager != null ? gameManager.getPlayerStats() : null;\n    }\n    \n    // M√©todo para comprobar si los ChatGames est√°n habilitados\n    public boolean isChatGamesEnabled() {\n        return chatGamesConfig.getBoolean(\"general.enabled\", true);\n    }\n    \n    // M√©todo para habilitar/deshabilitar ChatGames program√°ticamente\n    public void setChatGamesEnabled(boolean enabled) {\n        chatGamesConfig.set(\"general.enabled\", enabled);\n        saveChatGamesConfig();\n        if (gameManager != null) {\n            gameManager.reloadConfig();\n        }\n    }\n}","size_bytes":14241},"src/main/java/com/hyser/hysercore/abilities/Ability.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ArrayList;\n\npublic class Ability {\n    private String id;\n    private String name;\n    private List<String> description;\n    private String permission;\n    private int cooldown;\n    private boolean enabled;\n    private List<Object> triggers;\n    private List<Object> actions;\n    private List<Object> conditions;\n    \n    public Ability(String id, ConfigurationSection config) {\n        this.id = id;\n        this.name = config.getString(\"name\", id);\n        // Soporte para descriptions multil√≠nea\n        if (config.isList(\"description\")) {\n            this.description = config.getStringList(\"description\");\n        } else {\n            this.description = new ArrayList<>();\n            String singleDesc = config.getString(\"description\", \"\");\n            if (!singleDesc.isEmpty()) {\n                this.description.add(singleDesc);\n            }\n        }\n        this.permission = config.getString(\"permission\", \"hysercore.ability.\" + id);\n        this.cooldown = config.getInt(\"cooldown\", 0);\n        this.enabled = config.getBoolean(\"enabled\", true);\n    }\n    \n    public boolean canUse(Player player) {\n        if (!enabled) return false;\n        // Permisos removidos - todas las abilities disponibles para todos\n        \n        // Las condiciones se verifican en el manager\n        \n        return true;\n    }\n    \n    public void execute(Player player) {\n        // Las acciones se ejecutan en el manager\n    }\n    \n    // Getters\n    public String getId() { return id; }\n    public String getName() { return name; }\n    public List<String> getDescription() { return description; }\n    \n    public String getDescriptionAsString() {\n        if (description == null || description.isEmpty()) {\n            return \"\";\n        }\n        return String.join(\" \", description);\n    }\n    public String getPermission() { return permission; }\n    public int getCooldown() { return cooldown; }\n    public boolean isEnabled() { return enabled; }\n    public List<Object> getTriggers() { return triggers; }\n    public List<Object> getActions() { return actions; }\n    public List<Object> getConditions() { return conditions; }\n    \n    // Setters\n    public void setTriggers(List<Object> triggers) { this.triggers = triggers; }\n    public void setActions(List<Object> actions) { this.actions = actions; }\n    public void setConditions(List<Object> conditions) { this.conditions = conditions; }\n}","size_bytes":2587},"src/main/java/com/hyser/hysercore/abilities/AbilityManager.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.abilities.triggers.*;\nimport com.hyser.hysercore.abilities.triggers.ItemUseTrigger;\nimport org.bukkit.scheduler.BukkitRunnable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport com.hyser.hysercore.abilities.actions.*;\nimport com.hyser.hysercore.abilities.conditions.*;\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class AbilityManager {\n    private final HyserCore plugin;\n    private FileConfiguration abilityConfig;\n    private File abilityConfigFile;\n    private Map<String, Ability> abilities;\n    private Map<UUID, Map<String, Long>> cooldowns;\n    \n    // Optimizaciones de rendimiento\n    private final Map<String, List<AbilityTrigger>> triggerCache = new ConcurrentHashMap<>();\n    private final Map<String, List<AbilityAction>> actionCache = new ConcurrentHashMap<>();\n    private ItemAbilityManager itemManager;\n    private boolean enabled;\n    private String prefix;\n    \n    public AbilityManager(HyserCore plugin) {\n        this.plugin = plugin;\n        this.abilities = new HashMap<>();\n        this.cooldowns = new HashMap<>();\n        this.itemManager = new ItemAbilityManager(plugin, this);\n        loadConfig();\n        loadAbilities();\n    }\n    \n    private void loadConfig() {\n        abilityConfigFile = new File(plugin.getDataFolder(), \"ability.yml\");\n        if (!abilityConfigFile.exists()) {\n            plugin.saveResource(\"ability.yml\", false);\n        }\n        \n        abilityConfig = YamlConfiguration.loadConfiguration(abilityConfigFile);\n        this.enabled = abilityConfig.getBoolean(\"ability-system.enabled\", true);\n        this.prefix = ChatColor.translateAlternateColorCodes('&',\n            abilityConfig.getString(\"ability-system.prefix\", \"&8[&dAbilities&8]&r \"));\n        \n        plugin.getLogger().info(\"Ability system: \" + (enabled ? \"ENABLED\" : \"DISABLED\"));\n    }\n    \n    private void loadAbilities() {\n        abilities.clear();\n        \n        if (!enabled) {\n            plugin.getLogger().info(\"Abilities disabled, skipping load.\");\n            return;\n        }\n        \n        ConfigurationSection abilitiesSection = abilityConfig.getConfigurationSection(\"ability-items\");\n        if (abilitiesSection == null) {\n            plugin.getLogger().warning(\"No ability-items section found in ability.yml\");\n            return;\n        }\n        \n        int loadedCount = 0;\n        for (String abilityId : abilitiesSection.getKeys(false)) {\n            ConfigurationSection abilitySection = abilitiesSection.getConfigurationSection(abilityId);\n            if (abilitySection == null) continue;\n            \n            try {\n                Ability ability = new Ability(abilityId, abilitySection);\n                \n                        // Cargar triggers y cachearlos\n                List<AbilityTrigger> triggers = loadTriggers(abilitySection);\n                ability.setTriggers((List<Object>)(List<?>) triggers);\n                triggerCache.put(abilityId, triggers);\n                \n                // Cargar actions y cachearlas\n                List<AbilityAction> actions = loadActions(abilitySection);\n                ability.setActions((List<Object>)(List<?>) actions);\n                actionCache.put(abilityId, actions);\n                \n                // Cargar conditions\n                List<AbilityCondition> conditions = loadConditions(abilitySection);\n                ability.setConditions((List<Object>)(List<?>) conditions);\n                \n                abilities.put(abilityId, ability);\n                loadedCount++;\n                \n                plugin.getLogger().info(\"Loaded ability: \" + abilityId + \" (\" + ability.getName() + \")\");\n                \n            } catch (Exception e) {\n                plugin.getLogger().warning(\"Failed to load ability: \" + abilityId + \" - \" + e.getMessage());\n                if (abilityConfig.getBoolean(\"ability-system.debug\", false)) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        \n        plugin.getLogger().info(\"Loaded \" + loadedCount + \" abilities successfully.\");\n    }\n    \n    private List<AbilityTrigger> loadTriggers(ConfigurationSection abilitySection) {\n        List<AbilityTrigger> triggers = new ArrayList<>();\n        \n        if (!abilitySection.contains(\"triggers\")) {\n            return triggers;\n        }\n        \n        List<Map<?, ?>> triggersList = abilitySection.getMapList(\"triggers\");\n        for (Map<?, ?> triggerMap : triggersList) {\n            String type = (String) triggerMap.get(\"type\");\n            if (type == null) continue;\n            \n            // Convertir Map a ConfigurationSection\n            ConfigurationSection triggerConfig = abilityConfig.createSection(\"temp\");\n            for (Map.Entry<?, ?> entry : triggerMap.entrySet()) {\n                triggerConfig.set(entry.getKey().toString(), entry.getValue());\n            }\n            \n            AbilityTrigger trigger = createTrigger(type, triggerConfig);\n            if (trigger != null) {\n                triggers.add(trigger);\n            }\n        }\n        \n        return triggers;\n    }\n    \n    private List<AbilityAction> loadActions(ConfigurationSection abilitySection) {\n        List<AbilityAction> actions = new ArrayList<>();\n        \n        if (!abilitySection.contains(\"actions\")) {\n            return actions;\n        }\n        \n        List<Map<?, ?>> actionsList = abilitySection.getMapList(\"actions\");\n        for (Map<?, ?> actionMap : actionsList) {\n            String type = (String) actionMap.get(\"type\");\n            if (type == null) continue;\n            \n            // Convertir Map a ConfigurationSection\n            ConfigurationSection actionConfig = abilityConfig.createSection(\"temp\");\n            for (Map.Entry<?, ?> entry : actionMap.entrySet()) {\n                actionConfig.set(entry.getKey().toString(), entry.getValue());\n            }\n            \n            AbilityAction action = createAction(type, actionConfig);\n            if (action != null) {\n                actions.add(action);\n            }\n        }\n        \n        return actions;\n    }\n    \n    private List<AbilityCondition> loadConditions(ConfigurationSection abilitySection) {\n        List<AbilityCondition> conditions = new ArrayList<>();\n        \n        if (!abilitySection.contains(\"conditions\")) {\n            return conditions;\n        }\n        \n        List<Map<?, ?>> conditionsList = abilitySection.getMapList(\"conditions\");\n        for (Map<?, ?> conditionMap : conditionsList) {\n            String type = (String) conditionMap.get(\"type\");\n            if (type == null) continue;\n            \n            // Convertir Map a ConfigurationSection\n            ConfigurationSection conditionConfig = abilityConfig.createSection(\"temp\");\n            for (Map.Entry<?, ?> entry : conditionMap.entrySet()) {\n                conditionConfig.set(entry.getKey().toString(), entry.getValue());\n            }\n            \n            AbilityCondition condition = createCondition(type, conditionConfig);\n            if (condition != null) {\n                conditions.add(condition);\n            }\n        }\n        \n        return conditions;\n    }\n    \n    private AbilityCondition createCondition(String type, ConfigurationSection config) {\n        switch (type.toUpperCase()) {\n            case \"HEALTH_BELOW\":\n                return new HealthBelowCondition(type, config);\n            case \"SAFE_LOCATION\":\n                return new SafeLocationCondition(type, config);\n            default:\n                plugin.getLogger().warning(\"Unknown condition type: \" + type);\n                return null;\n        }\n    }\n    \n    private AbilityTrigger createTrigger(String type, ConfigurationSection config) {\n        switch (type.toUpperCase()) {\n            case \"RIGHT_CLICK\":\n            case \"LEFT_CLICK\":\n            case \"SHIFT_CLICK\":\n            case \"SHIFT_RIGHT_CLICK\":\n            case \"SHIFT_LEFT_CLICK\":\n                return new ClickTrigger(type, config);\n            case \"DOUBLE_SHIFT\":\n                return new DoubleShiftTrigger(type, config);\n            case \"ON_HIT\":\n            case \"ON_RECEIVE_HIT\":\n            case \"HIT_COUNT\":\n            case \"RECEIVE_COUNT\":\n                return new CombatTrigger(type, config);\n            case \"RIGHT_CLICK_ITEM\":\n                return new ItemUseTrigger(type, config);\n            case \"COMBO_GIVE\":\n            case \"COMBO_RECEIVE\":\n                return new com.hyser.hysercore.abilities.triggers.ComboTrigger(type, config);\n            case \"ABILITY_THEN_DOUBLE_SHIFT\":\n                return new SequentialTrigger(type, config);\n            default:\n                plugin.getLogger().warning(\"Unknown trigger type: \" + type);\n                return null;\n        }\n    }\n    \n    private AbilityAction createAction(String type, ConfigurationSection config) {\n        switch (type.toUpperCase()) {\n            case \"POTION_EFFECT\":\n                return new PotionEffectAction(type, config);\n            case \"SOUND\":\n                return new SoundAction(type, config);\n            case \"MESSAGE\":\n                return new MessageAction(type, config);\n            case \"PARTICLE\":\n                return new ParticleAction(type, config);\n            case \"HEAL\":\n                return new HealAction(type, config);\n            case \"HEAL_RADIUS\":\n                return new HealRadiusAction(type, config);\n            case \"TELEPORT\":\n                return new TeleportAction(type, config);\n            case \"VELOCITY\":\n                return new VelocityAction(type, config);\n            case \"ENERGY_CHARGE\":\n                EnergyChargeAction energyCharge = new EnergyChargeAction(type, config);\n                energyCharge.setPlugin(plugin);\n                return energyCharge;\n            case \"ENERGY_RELEASE\":\n                return new EnergyReleaseAction(type, config);\n            default:\n                plugin.getLogger().warning(\"Unknown action type: \" + type);\n                return null;\n        }\n    }\n    \n    public boolean handleEvent(Event event, Player player) {\n        if (!enabled || abilities.isEmpty()) {\n            return false;\n        }\n        \n        boolean handled = false;\n        \n        // Optimizaci√≥n: procesar abilities en paralelo cuando sea posible\n        for (Ability ability : abilities.values()) {\n            if (!ability.isEnabled() || !ability.canUse(player)) {\n                continue;\n            }\n            \n            // Verificar cooldown\n            if (isOnCooldown(player, ability.getId())) {\n                continue;\n            }\n            \n            // Verificar condiciones\n            if (!checkConditions(ability, player)) {\n                continue;\n            }\n            \n            // Usar cache de triggers para mejor rendimiento\n            List<AbilityTrigger> triggers = triggerCache.get(ability.getId());\n            if (triggers != null) {\n                for (AbilityTrigger trigger : triggers) {\n                    if (trigger.matches(event, player)) {\n                        // Para triggers de items, verificar y consumir uso\n                        if (trigger instanceof ItemUseTrigger) {\n                            ItemUseTrigger itemTrigger = (ItemUseTrigger) trigger;\n                            if (itemTrigger.shouldConsumeUse() && event instanceof org.bukkit.event.player.PlayerInteractEvent) {\n                                org.bukkit.event.player.PlayerInteractEvent interactEvent = (org.bukkit.event.player.PlayerInteractEvent) event;\n                                org.bukkit.inventory.ItemStack item = interactEvent.getItem();\n                                if (item != null) {\n                                    // Consumir uso del objeto\n                                    if (!itemManager.useAbilityItem(player, item, ability.getId())) {\n                                        continue; // No se pudo consumir el uso\n                                    }\n                                }\n                            }\n                        }\n                        \n                        // Ejecutar habilidad usando cache de acciones\n                        executeAbility(ability, player);\n                        \n                        // Aplicar cooldown\n                        if (ability.getCooldown() > 0) {\n                            setCooldown(player, ability.getId(), ability.getCooldown());\n                        }\n                        \n                        handled = true;\n                        break; // Solo ejecutar una vez por habilidad\n                    }\n                }\n            }\n        }\n        \n        return handled;\n    }\n    \n    private boolean checkConditions(Ability ability, Player player) {\n        @SuppressWarnings(\"unchecked\")\n        List<AbilityCondition> conditions = (List<AbilityCondition>)(List<?>) ability.getConditions();\n        \n        if (conditions == null || conditions.isEmpty()) {\n            return true;\n        }\n        \n        for (AbilityCondition condition : conditions) {\n            if (!condition.check(player)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private boolean isOnCooldown(Player player, String abilityId) {\n        Map<String, Long> playerCooldowns = cooldowns.get(player.getUniqueId());\n        if (playerCooldowns == null) {\n            return false;\n        }\n        \n        Long cooldownTime = playerCooldowns.get(abilityId);\n        if (cooldownTime == null) {\n            return false;\n        }\n        \n        return System.currentTimeMillis() < cooldownTime;\n    }\n    \n    private void setCooldown(Player player, String abilityId, int seconds) {\n        UUID playerId = player.getUniqueId();\n        cooldowns.computeIfAbsent(playerId, k -> new HashMap<>())\n            .put(abilityId, System.currentTimeMillis() + (seconds * 1000L));\n    }\n    \n    public void reload() {\n        reloadSystem();\n    }\n    \n    public boolean isEnabled() {\n        return enabled;\n    }\n    \n    public Map<String, Ability> getAbilities() {\n        return new HashMap<>(abilities);\n    }\n    \n    public Ability getAbility(String id) {\n        return abilities.get(id);\n    }\n    \n    public String getPrefix() {\n        return prefix;\n    }\n    \n    public FileConfiguration getAbilityConfigFile() {\n        return abilityConfig;\n    }\n    \n    public ItemAbilityManager getItemManager() {\n        return itemManager;\n    }\n    \n    // M√©todo optimizado para ejecutar abilities\n    private void executeAbility(Ability ability, Player player) {\n        List<AbilityAction> actions = actionCache.get(ability.getId());\n        if (actions != null) {\n            for (AbilityAction action : actions) {\n                try {\n                    action.execute(player);\n                } catch (Exception e) {\n                    plugin.getLogger().warning(\"Error executing action for ability \" + \n                        ability.getId() + \": \" + e.getMessage());\n                    if (abilityConfig.getBoolean(\"ability-system.debug\", false)) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n    \n    // M√©todo mejorado de recarga con limpieza de cach√©\n    public void reloadSystem() {\n        triggerCache.clear();\n        actionCache.clear();\n        loadConfig();\n        loadAbilities();\n        plugin.getLogger().info(\"Ability system reloaded with optimized caching.\");\n    }\n}","size_bytes":15937},"src/main/java/com/hyser/hysercore/apples/AppleManager.java":{"content":"package com.hyser.hysercore.apples;\n\npublic class AppleManager {\n\n}","size_bytes":67},"src/main/java/com/hyser/hysercore/apples/Apples.java":{"content":"package com.hyser.hysercore.apples;\n\npublic class Apples {\n\n}","size_bytes":61},"src/main/java/com/hyser/hysercore/commands/ChatGamesCommand.java":{"content":"package com.hyser.hysercore.commands;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.managers.ChatGameManager;\nimport com.hyser.hysercore.utils.PlayerStats;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class ChatGamesCommand implements CommandExecutor, TabCompleter {\n    \n    private HyserCore plugin;\n    private ChatGameManager gameManager;\n    \n    public ChatGamesCommand(HyserCore plugin, ChatGameManager gameManager) {\n        this.plugin = plugin;\n        this.gameManager = gameManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                plugin.getChatGamesConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            sender.sendMessage(noPermission);\n            return true;\n        }\n        \n        if (args.length == 0) {\n            sendHelp(sender);\n            return true;\n        }\n        \n        String subCommand = args[0].toLowerCase();\n        \n        switch (subCommand) {\n            case \"reload\":\n                handleReload(sender);\n                break;\n            case \"start\":\n                handleStart(sender, args);\n                break;\n            case \"stop\":\n                handleStop(sender);\n                break;\n            case \"status\":\n                handleStatus(sender);\n                break;\n            case \"stats\":\n                handleStats(sender, args);\n                break;\n            case \"enable\":\n                handleEnable(sender);\n                break;\n            case \"disable\":\n                handleDisable(sender);\n                break;\n            case \"help\":\n            default:\n                sendHelp(sender);\n                break;\n        }\n        \n        return true;\n    }\n    \n    private void handleReload(CommandSender sender) {\n        gameManager.reloadConfig();\n        String reloadMessage = ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.plugin-reloaded\", \"&aConfiguraci√≥n de ChatGames recargada correctamente.\"));\n        sender.sendMessage(reloadMessage);\n    }\n    \n    private void handleStart(CommandSender sender, String[] args) {\n        if (gameManager.isGameActive()) {\n            sender.sendMessage(ChatColor.RED + \"Ya hay un ChatGame activo.\");\n            return;\n        }\n        \n        String gameType = \"random\";\n        if (args.length > 1) {\n            gameType = args[1].toLowerCase();\n        }\n        \n        if (gameType.equals(\"random\")) {\n            gameManager.forceStartGame(null);\n        } else {\n            List<String> validTypes = Arrays.asList(\"math\", \"word\", \"trivia\", \"complete\", \"number\");\n            if (!validTypes.contains(gameType)) {\n                sender.sendMessage(ChatColor.RED + \"Tipo de juego inv√°lido. Tipos v√°lidos: \" + String.join(\", \", validTypes));\n                return;\n            }\n            gameManager.forceStartGame(gameType);\n        }\n        \n        sender.sendMessage(ChatColor.GREEN + \"ChatGame iniciado manualmente.\");\n    }\n    \n    private void handleStop(CommandSender sender) {\n        if (!gameManager.isGameActive()) {\n            sender.sendMessage(ChatColor.RED + \"No hay ning√∫n ChatGame activo.\");\n            return;\n        }\n        \n        gameManager.stopCurrentGame();\n        sender.sendMessage(ChatColor.GREEN + \"ChatGame detenido.\");\n    }\n    \n    private void handleStatus(CommandSender sender) {\n        boolean enabled = plugin.getChatGamesConfig().getBoolean(\"general.enabled\", true);\n        boolean gameActive = gameManager.isGameActive();\n        int onlinePlayers = Bukkit.getOnlinePlayers().size();\n        int minPlayers = plugin.getChatGamesConfig().getInt(\"general.min-players\", 3);\n        \n        sender.sendMessage(ChatColor.GOLD + \"=== Estado de ChatGames ===\");\n        sender.sendMessage(ChatColor.YELLOW + \"Sistema: \" + (enabled ? ChatColor.GREEN + \"Habilitado\" : ChatColor.RED + \"Deshabilitado\"));\n        sender.sendMessage(ChatColor.YELLOW + \"Juego activo: \" + (gameActive ? ChatColor.GREEN + \"S√≠\" : ChatColor.RED + \"No\"));\n        sender.sendMessage(ChatColor.YELLOW + \"Jugadores online: \" + ChatColor.WHITE + onlinePlayers + \"/\" + minPlayers + \" (m√≠nimo)\");\n        \n        if (enabled && !gameActive) {\n            int minInterval = plugin.getChatGamesConfig().getInt(\"general.interval.min\", 300);\n            int maxInterval = plugin.getChatGamesConfig().getInt(\"general.interval.max\", 600);\n            sender.sendMessage(ChatColor.YELLOW + \"Pr√≥ximo juego: \" + ChatColor.WHITE + \"Entre \" + minInterval + \" y \" + maxInterval + \" segundos\");\n        }\n    }\n    \n    private void handleStats(CommandSender sender, String[] args) {\n        if (args.length > 1) {\n            // Estad√≠sticas de un jugador espec√≠fico\n            String playerName = args[1];\n            Player target = Bukkit.getPlayer(playerName);\n            if (target == null) {\n                sender.sendMessage(ChatColor.RED + \"Jugador no encontrado o no est√° online.\");\n                return;\n            }\n            \n            showPlayerStats(sender, target);\n        } else {\n            // Ranking general\n            showTopPlayers(sender);\n        }\n    }\n    \n    private void showPlayerStats(CommandSender sender, Player target) {\n        PlayerStats stats = gameManager.getPlayerStats();\n        UUID playerId = target.getUniqueId();\n        \n        int gamesPlayed = stats.getGamesPlayed(playerId);\n        int gamesWon = stats.getGamesWon(playerId);\n        double winRate = stats.getWinRate(playerId);\n        int totalRewards = stats.getTotalRewards(playerId);\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', plugin.getChatGamesConfig().getString(\"general.prefix\", \"\"));\n        \n        sender.sendMessage(prefix + ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-header\", \"&8&m----------&r &6Estad√≠sticas &8&m----------\")));\n        sender.sendMessage(ChatColor.YELLOW + \"Jugador: \" + ChatColor.WHITE + target.getName());\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-games-played\", \"&7Juegos jugados: &e{games}\").replace(\"{games}\", String.valueOf(gamesPlayed))));\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-games-won\", \"&7Juegos ganados: &a{wins}\").replace(\"{wins}\", String.valueOf(gamesWon))));\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-win-rate\", \"&7Tasa de victoria: &b{rate}%\").replace(\"{rate}\", String.format(\"%.1f\", winRate))));\n        sender.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.stats-total-rewards\", \"&7Recompensas totales: &6${rewards}\").replace(\"{rewards}\", String.valueOf(totalRewards))));\n    }\n    \n    private void showTopPlayers(CommandSender sender) {\n        PlayerStats stats = gameManager.getPlayerStats();\n        Map<UUID, Integer> topPlayers = stats.getTopPlayers(10);\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', plugin.getChatGamesConfig().getString(\"general.prefix\", \"\"));\n        \n        sender.sendMessage(prefix + ChatColor.GOLD + \"=== Top 10 Jugadores ===\");\n        \n        if (topPlayers.isEmpty()) {\n            sender.sendMessage(ChatColor.GRAY + \"No hay estad√≠sticas disponibles.\");\n            return;\n        }\n        \n        int position = 1;\n        for (Map.Entry<UUID, Integer> entry : topPlayers.entrySet()) {\n            Player player = Bukkit.getPlayer(entry.getKey());\n            String playerName = player != null ? player.getName() : \"Jugador desconocido\";\n            int wins = entry.getValue();\n            int totalGames = stats.getGamesPlayed(entry.getKey());\n            double winRate = stats.getWinRate(entry.getKey());\n            \n            sender.sendMessage(ChatColor.YELLOW + \"#\" + position + \" \" + ChatColor.WHITE + playerName + \n                ChatColor.GRAY + \" - \" + ChatColor.GREEN + wins + \" victorias \" + \n                ChatColor.GRAY + \"(\" + String.format(\"%.1f\", winRate) + \"% de \" + totalGames + \" juegos)\");\n            position++;\n        }\n    }\n    \n    private void handleEnable(CommandSender sender) {\n        plugin.getChatGamesConfig().set(\"general.enabled\", true);\n        plugin.saveChatGamesConfig();\n        gameManager.reloadConfig();\n        \n        String enabledMessage = ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.games-enabled\", \"&aChatGames han sido habilitados.\"));\n        sender.sendMessage(enabledMessage);\n    }\n    \n    private void handleDisable(CommandSender sender) {\n        plugin.getChatGamesConfig().set(\"general.enabled\", false);\n        plugin.saveChatGamesConfig();\n        \n        if (gameManager.isGameActive()) {\n            gameManager.stopCurrentGame();\n        }\n        \n        gameManager.reloadConfig();\n        \n        String disabledMessage = ChatColor.translateAlternateColorCodes('&', \n            plugin.getChatGamesConfig().getString(\"messages.games-disabled\", \"&cChatGames han sido deshabilitados.\"));\n        sender.sendMessage(disabledMessage);\n    }\n    \n    private void sendHelp(CommandSender sender) {\n        sender.sendMessage(ChatColor.GOLD + \"=== Comandos de ChatGames ===\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames reload\" + ChatColor.GRAY + \" - Recargar configuraci√≥n\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames start [tipo]\" + ChatColor.GRAY + \" - Iniciar juego manualmente\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames stop\" + ChatColor.GRAY + \" - Detener juego actual\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames status\" + ChatColor.GRAY + \" - Ver estado del sistema\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames stats [jugador]\" + ChatColor.GRAY + \" - Ver estad√≠sticas\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames enable\" + ChatColor.GRAY + \" - Habilitar sistema\");\n        sender.sendMessage(ChatColor.YELLOW + \"/chatgames disable\" + ChatColor.GRAY + \" - Deshabilitar sistema\");\n        sender.sendMessage(ChatColor.GRAY + \"Tipos de juego: math, word, trivia, complete, number\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] subCommands = {\"reload\", \"start\", \"stop\", \"status\", \"stats\", \"enable\", \"disable\", \"help\"};\n            for (String subCommand : subCommands) {\n                if (subCommand.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(subCommand);\n                }\n            }\n        } else if (args.length == 2) {\n            if (args[0].equalsIgnoreCase(\"start\")) {\n                String[] gameTypes = {\"math\", \"word\", \"trivia\", \"complete\", \"number\", \"random\"};\n                for (String gameType : gameTypes) {\n                    if (gameType.toLowerCase().startsWith(args[1].toLowerCase())) {\n                        completions.add(gameType);\n                    }\n                }\n            } else if (args[0].equalsIgnoreCase(\"stats\")) {\n                for (Player player : Bukkit.getOnlinePlayers()) {\n                    if (player.getName().toLowerCase().startsWith(args[1].toLowerCase())) {\n                        completions.add(player.getName());\n                    }\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":12460},"src/main/java/com/hyser/hysercore/games/ChatGame.java":{"content":"package com.hyser.hysercore.games;\n\npublic abstract class ChatGame {\n    \n    protected String question;\n    protected String answer;\n    protected String typeName;\n    protected String[] hints;\n    \n    public ChatGame(String typeName) {\n        this.typeName = typeName;\n        this.hints = new String[0];\n    }\n    \n    public abstract void generateQuestion();\n    \n    public boolean checkAnswer(String playerAnswer) {\n        if (answer == null || playerAnswer == null) {\n            return false;\n        }\n        \n        String cleanAnswer = answer.toLowerCase().trim().replaceAll(\"[^a-zA-Z0-9√°√©√≠√≥√∫√±√º ]\", \"\");\n        String cleanPlayerAnswer = playerAnswer.toLowerCase().trim().replaceAll(\"[^a-zA-Z0-9√°√©√≠√≥√∫√±√º ]\", \"\");\n        \n        return cleanAnswer.equals(cleanPlayerAnswer);\n    }\n    \n    public String getQuestion() {\n        return question;\n    }\n    \n    public String getAnswer() {\n        return answer;\n    }\n    \n    public String getTypeName() {\n        return typeName;\n    }\n    \n    public String[] getHints() {\n        return hints;\n    }\n    \n    public String getHint(int index) {\n        if (hints == null || index < 0 || index >= hints.length) {\n            return null;\n        }\n        return hints[index];\n    }\n}","size_bytes":1266},"src/main/java/com/hyser/hysercore/games/CompleteGame.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class CompleteGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public CompleteGame(FileConfiguration config) {\n        super(\"Completar Frase\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        List<Map<?, ?>> completeQuestions = (List<Map<?, ?>>) config.getList(\"questions.complete\");\n        \n        if (completeQuestions == null || completeQuestions.isEmpty()) {\n            generateDefaultQuestion();\n            return;\n        }\n        \n        Map<?, ?> selectedQuestion = completeQuestions.get(ThreadLocalRandom.current().nextInt(completeQuestions.size()));\n        \n        question = (String) selectedQuestion.get(\"question\");\n        answer = (String) selectedQuestion.get(\"answer\");\n        \n        List<String> hintsList = (List<String>) selectedQuestion.get(\"hints\");\n        if (hintsList != null) {\n            hints = hintsList.toArray(new String[0]);\n        } else {\n            hints = new String[]{\"Es un refr√°n\", \"Piensa en el significado\", \"La respuesta es: \" + answer};\n        }\n    }\n    \n    private void generateDefaultQuestion() {\n        String[][] questions = {\n            {\"M√°s vale p√°jaro en mano que...\", \"ciento volando\", \"Es un refr√°n\", \"Habla de n√∫meros\", \"...ciento volando\"},\n            {\"En casa de herrero, cuchillo de...\", \"palo\", \"Es un refr√°n\", \"Material opuesto\", \"...de palo\"},\n            {\"A caballo regalado no se le mira el...\", \"diente\", \"Es un refr√°n\", \"Parte de la boca\", \"...el diente\"},\n            {\"Ojos que no ven, coraz√≥n que no...\", \"siente\", \"Es un refr√°n\", \"Emoci√≥n\", \"...que no siente\"},\n            {\"Agua que no has de beber...\", \"dejala correr\", \"Es un refr√°n\", \"No interferir\", \"...d√©jala correr\"},\n            {\"Camar√≥n que se duerme...\", \"se lo lleva la corriente\", \"Es un refr√°n\", \"Sobre el r√≠o\", \"...se lo lleva la corriente\"},\n            {\"El que madruga...\", \"dios le ayuda\", \"Es un refr√°n\", \"Sobre levantarse temprano\", \"...Dios le ayuda\"},\n            {\"No por mucho madrugar...\", \"amanece mas temprano\", \"Es un refr√°n\", \"Sobre el tiempo\", \"...amanece m√°s temprano\"},\n            {\"A quien madruga...\", \"dios le ayuda\", \"Es un refr√°n\", \"Sobre levantarse temprano\", \"...Dios le ayuda\"},\n            {\"Dime con qui√©n andas y te dir√©...\", \"quien eres\", \"Es un refr√°n\", \"Sobre las amistades\", \"...qui√©n eres\"},\n            {\"En boca cerrada...\", \"no entran moscas\", \"Es un refr√°n\", \"Sobre el silencio\", \"...no entran moscas\"},\n            {\"Perro que ladra...\", \"no muerde\", \"Es un refr√°n\", \"Sobre amenazas\", \"...no muerde\"},\n            {\"A mal tiempo...\", \"buena cara\", \"Es un refr√°n\", \"Sobre el optimismo\", \"...buena cara\"},\n            {\"M√°s vale tarde...\", \"que nunca\", \"Es un refr√°n\", \"Sobre el tiempo\", \"...que nunca\"},\n            {\"No hay mal que...\", \"por bien no venga\", \"Es un refr√°n\", \"Sobre las adversidades\", \"...por bien no venga\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n}","size_bytes":3404},"src/main/java/com/hyser/hysercore/games/MathGame.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class MathGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public MathGame(FileConfiguration config) {\n        super(\"Matem√°ticas\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        String[] difficulties = {\"easy\", \"medium\", \"hard\"};\n        String difficulty = difficulties[ThreadLocalRandom.current().nextInt(difficulties.length)];\n        \n        String[] operations = config.getStringList(\"game-types.math.difficulty.\" + difficulty + \".operations\").toArray(new String[0]);\n        int[] range = config.getIntegerList(\"game-types.math.difficulty.\" + difficulty + \".range\").stream().mapToInt(i -> i).toArray();\n        \n        if (operations.length == 0) {\n            operations = new String[]{\"suma\", \"resta\", \"multiplicacion\"};\n        }\n        if (range.length < 2) {\n            range = new int[]{1, 50};\n        }\n        \n        String operation = operations[ThreadLocalRandom.current().nextInt(operations.length)];\n        \n        int num1 = ThreadLocalRandom.current().nextInt(range[0], range[1] + 1);\n        int num2 = ThreadLocalRandom.current().nextInt(range[0], range[1] + 1);\n        int result;\n        \n        switch (operation.toLowerCase()) {\n            case \"suma\":\n                result = num1 + num2;\n                question = \"¬øCu√°nto es \" + num1 + \" + \" + num2 + \"?\";\n                break;\n            case \"resta\":\n                if (num1 < num2) {\n                    int temp = num1;\n                    num1 = num2;\n                    num2 = temp;\n                }\n                result = num1 - num2;\n                question = \"¬øCu√°nto es \" + num1 + \" - \" + num2 + \"?\";\n                break;\n            case \"multiplicacion\":\n                // Para multiplicaci√≥n, usar n√∫meros m√°s peque√±os\n                num1 = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 15));\n                num2 = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 15));\n                result = num1 * num2;\n                question = \"¬øCu√°nto es \" + num1 + \" √ó \" + num2 + \"?\";\n                break;\n            case \"division\":\n                // Para divisi√≥n, asegurar que sea exacta\n                num2 = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 10));\n                result = ThreadLocalRandom.current().nextInt(2, Math.min(range[1], 20));\n                num1 = num2 * result;\n                question = \"¬øCu√°nto es \" + num1 + \" √∑ \" + num2 + \"?\";\n                break;\n            default:\n                result = num1 + num2;\n                question = \"¬øCu√°nto es \" + num1 + \" + \" + num2 + \"?\";\n                break;\n        }\n        \n        answer = String.valueOf(result);\n        hints = new String[]{\n            \"Es un n√∫mero \" + (result % 2 == 0 ? \"par\" : \"impar\"),\n            \"Est√° entre \" + Math.max(0, result - 10) + \" y \" + (result + 10),\n            \"La respuesta es \" + result\n        };\n    }\n}","size_bytes":3157},"src/main/java/com/hyser/hysercore/games/NumberGame.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class NumberGame extends ChatGame {\n    \n    private FileConfiguration config;\n    private int targetNumber;\n    \n    public NumberGame(FileConfiguration config) {\n        super(\"Adivinar N√∫mero\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        int[] range = config.getIntegerList(\"game-types.number.range\").stream().mapToInt(i -> i).toArray();\n        if (range.length < 2) {\n            range = new int[]{1, 1000};\n        }\n        \n        targetNumber = ThreadLocalRandom.current().nextInt(range[0], range[1] + 1);\n        answer = String.valueOf(targetNumber);\n        \n        question = \"Adivina el n√∫mero entre \" + range[0] + \" y \" + range[1];\n        \n        // Generar pistas matem√°ticas\n        String parity = targetNumber % 2 == 0 ? \"par\" : \"impar\";\n        String range1 = \"Est√° entre \" + Math.max(range[0], targetNumber - 50) + \" y \" + Math.min(range[1], targetNumber + 50);\n        String range2 = \"Est√° entre \" + Math.max(range[0], targetNumber - 20) + \" y \" + Math.min(range[1], targetNumber + 20);\n        \n        // Pistas adicionales basadas en propiedades del n√∫mero\n        String divisibility = \"\";\n        if (targetNumber % 10 == 0) {\n            divisibility = \"Es m√∫ltiplo de 10\";\n        } else if (targetNumber % 5 == 0) {\n            divisibility = \"Es m√∫ltiplo de 5\";\n        } else if (targetNumber % 3 == 0) {\n            divisibility = \"Es m√∫ltiplo de 3\";\n        } else {\n            divisibility = \"No es m√∫ltiplo de 5\";\n        }\n        \n        hints = new String[]{\n            \"Es un n√∫mero \" + parity,\n            divisibility,\n            range1,\n            range2,\n            \"El n√∫mero es \" + targetNumber\n        };\n    }\n    \n    @Override\n    public boolean checkAnswer(String playerAnswer) {\n        try {\n            int playerNumber = Integer.parseInt(playerAnswer.trim());\n            return playerNumber == targetNumber;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n}","size_bytes":2207},"src/main/java/com/hyser/hysercore/games/TriviaGame.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class TriviaGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public TriviaGame(FileConfiguration config) {\n        super(\"Trivia\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        List<String> categories = config.getStringList(\"game-types.trivia.categories\");\n        if (categories.isEmpty()) {\n            categories = List.of(\"general\", \"minecraft\", \"historia\", \"ciencia\");\n        }\n        \n        String category = categories.get(ThreadLocalRandom.current().nextInt(categories.size()));\n        ConfigurationSection questionsSection = config.getConfigurationSection(\"questions.trivia.\" + category);\n        \n        if (questionsSection == null) {\n            generateDefaultQuestion(category);\n            return;\n        }\n        \n        List<Map<?, ?>> questionsList = (List<Map<?, ?>>) config.getList(\"questions.trivia.\" + category);\n        if (questionsList == null || questionsList.isEmpty()) {\n            generateDefaultQuestion(category);\n            return;\n        }\n        \n        Map<?, ?> selectedQuestion = questionsList.get(ThreadLocalRandom.current().nextInt(questionsList.size()));\n        \n        question = (String) selectedQuestion.get(\"question\");\n        answer = (String) selectedQuestion.get(\"answer\");\n        \n        List<String> hintsList = (List<String>) selectedQuestion.get(\"hints\");\n        if (hintsList != null) {\n            hints = hintsList.toArray(new String[0]);\n        } else {\n            hints = new String[]{\"Piensa bien\", \"Es de la categor√≠a \" + category, \"La respuesta es: \" + answer};\n        }\n    }\n    \n    private void generateDefaultQuestion(String category) {\n        switch (category.toLowerCase()) {\n            case \"minecraft\":\n                generateMinecraftQuestion();\n                break;\n            case \"general\":\n                generateGeneralQuestion();\n                break;\n            case \"historia\":\n                generateHistoryQuestion();\n                break;\n            case \"ciencia\":\n                generateScienceQuestion();\n                break;\n            default:\n                generateGeneralQuestion();\n                break;\n        }\n    }\n    \n    private void generateMinecraftQuestion() {\n        String[][] questions = {\n            {\"¬øQui√©n cre√≥ Minecraft?\", \"notch\", \"Su nombre real es Markus\", \"Fund√≥ Mojang\", \"La respuesta es Notch\"},\n            {\"¬øCu√°ntos ojos de ender necesitas para el portal?\", \"12\", \"Es un n√∫mero par\", \"M√°s de 10\", \"Son doce\"},\n            {\"¬øQu√© mob explota?\", \"creeper\", \"Es verde\", \"Hace sss\", \"Es un Creeper\"},\n            {\"¬øCu√°l es el bloque m√°s resistente?\", \"bedrock\", \"No se puede romper\", \"Est√° en el fondo\", \"Es Bedrock\"},\n            {\"¬øEn qu√© dimensi√≥n est√° el Wither?\", \"nether\", \"Es roja y caliente\", \"Hay lava\", \"Es el Nether\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n    \n    private void generateGeneralQuestion() {\n        String[][] questions = {\n            {\"¬øCu√°l es la capital de Espa√±a?\", \"madrid\", \"Es europea\", \"Empieza por M\", \"Es Madrid\"},\n            {\"¬øCu√°ntos continentes hay?\", \"7\", \"Es impar\", \"Menos de 10\", \"Son siete\"},\n            {\"¬øCu√°l es el planeta m√°s grande?\", \"jupiter\", \"Es gaseoso\", \"Empieza por J\", \"Es J√∫piter\"},\n            {\"¬øCu√°l es el oc√©ano m√°s grande?\", \"pacifico\", \"Entre Asia y Am√©rica\", \"Significa pac√≠fico\", \"Es el Pac√≠fico\"},\n            {\"¬øCu√°ntos d√≠as tiene un a√±o?\", \"365\", \"M√°s de 300\", \"Menos de 400\", \"Son 365\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n    \n    private void generateHistoryQuestion() {\n        String[][] questions = {\n            {\"¬øEn qu√© a√±o comenz√≥ la Segunda Guerra Mundial?\", \"1939\", \"Siglo XX\", \"D√©cada del 30\", \"Fue en 1939\"},\n            {\"¬øQui√©n fue el primer emperador romano?\", \"augusto\", \"Era Octavio\", \"Sobrino de C√©sar\", \"Fue Augusto\"},\n            {\"¬øEn qu√© a√±o descubri√≥ Am√©rica Col√≥n?\", \"1492\", \"Siglo XV\", \"D√©cada del 90\", \"Fue en 1492\"},\n            {\"¬øQui√©n pint√≥ la Mona Lisa?\", \"leonardo\", \"Fue italiano\", \"Del Renacimiento\", \"Leonardo da Vinci\"},\n            {\"¬øEn qu√© a√±o cay√≥ el Muro de Berl√≠n?\", \"1989\", \"Siglo XX\", \"D√©cada del 80\", \"Fue en 1989\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n    \n    private void generateScienceQuestion() {\n        String[][] questions = {\n            {\"¬øCu√°l es el elemento m√°s abundante en el universo?\", \"hidrogeno\", \"Es el m√°s ligero\", \"Su s√≠mbolo es H\", \"Es hidr√≥geno\"},\n            {\"¬øCu√°ntos huesos tiene el cuerpo humano?\", \"206\", \"M√°s de 200\", \"Menos de 210\", \"Son 206\"},\n            {\"¬øCu√°l es la velocidad de la luz?\", \"300000000\", \"300 millones\", \"Metros por segundo\", \"300.000.000 m/s\"},\n            {\"¬øCu√°l es el gas m√°s abundante en la atm√≥sfera?\", \"nitrogeno\", \"No es ox√≠geno\", \"Empieza por N\", \"Es nitr√≥geno\"},\n            {\"¬øCu√°ntos cromosomas tiene el ser humano?\", \"46\", \"Es par\", \"M√°s de 40\", \"Son 46\"}\n        };\n        \n        String[] selected = questions[ThreadLocalRandom.current().nextInt(questions.length)];\n        question = selected[0];\n        answer = selected[1];\n        hints = new String[]{selected[2], selected[3], selected[4]};\n    }\n}","size_bytes":6131},"src/main/java/com/hyser/hysercore/games/WordGame.java":{"content":"package com.hyser.hysercore.games;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class WordGame extends ChatGame {\n    \n    private FileConfiguration config;\n    \n    public WordGame(FileConfiguration config) {\n        super(\"Palabras\");\n        this.config = config;\n        generateQuestion();\n    }\n    \n    @Override\n    public void generateQuestion() {\n        List<String> words = config.getStringList(\"questions.words\");\n        if (words.isEmpty()) {\n            words = getDefaultWords();\n        }\n        \n        String originalWord = words.get(ThreadLocalRandom.current().nextInt(words.size()));\n        answer = originalWord.toLowerCase();\n        \n        String[] gameTypes = {\"scramble\", \"reverse\", \"riddle\"};\n        String gameType = gameTypes[ThreadLocalRandom.current().nextInt(gameTypes.length)];\n        \n        switch (gameType) {\n            case \"scramble\":\n                generateScrambleQuestion(originalWord);\n                break;\n            case \"reverse\":\n                generateReverseQuestion(originalWord);\n                break;\n            case \"riddle\":\n                generateRiddleQuestion(originalWord);\n                break;\n            default:\n                generateScrambleQuestion(originalWord);\n                break;\n        }\n    }\n    \n    private void generateScrambleQuestion(String word) {\n        List<Character> letters = new ArrayList<>();\n        for (char c : word.toCharArray()) {\n            letters.add(c);\n        }\n        Collections.shuffle(letters);\n        \n        StringBuilder scrambled = new StringBuilder();\n        for (char c : letters) {\n            scrambled.append(c);\n        }\n        \n        question = \"Ordena las letras: \" + scrambled.toString().toUpperCase();\n        hints = new String[]{\n            \"Es una palabra de \" + word.length() + \" letras\",\n            \"Empieza por \" + Character.toString(word.charAt(0)).toUpperCase(),\n            \"La palabra es: \" + word\n        };\n    }\n    \n    private void generateReverseQuestion(String word) {\n        StringBuilder reversed = new StringBuilder(word);\n        reversed.reverse();\n        \n        question = \"¬øQu√© palabra es al rev√©s? \" + reversed.toString().toUpperCase();\n        hints = new String[]{\n            \"Es una palabra de \" + word.length() + \" letras\",\n            \"Termina en \" + Character.toString(word.charAt(word.length() - 1)).toUpperCase(),\n            \"La palabra es: \" + word\n        };\n    }\n    \n    private void generateRiddleQuestion(String word) {\n        String riddle = generateRiddle(word.toLowerCase());\n        question = riddle;\n        hints = new String[]{\n            \"Es una palabra de \" + word.length() + \" letras\",\n            \"Empieza por \" + Character.toString(word.charAt(0)).toUpperCase(),\n            \"La palabra es: \" + word\n        };\n    }\n    \n    private String generateRiddle(String word) {\n        switch (word.toLowerCase()) {\n            case \"creeper\":\n                return \"Soy verde y exploto, ¬øqui√©n soy?\";\n            case \"enderdragon\":\n                return \"Soy el jefe final del End, ¬øqui√©n soy?\";\n            case \"diamante\":\n                return \"Soy azul y muy valioso en las minas, ¬øqu√© soy?\";\n            case \"redstone\":\n                return \"Soy rojo y conduzco electricidad en Minecraft, ¬øqu√© soy?\";\n            case \"nether\":\n                return \"Soy una dimensi√≥n roja y caliente, ¬øqu√© soy?\";\n            case \"zombie\":\n                return \"Camino lento y digo 'grrr', ¬øqui√©n soy?\";\n            case \"skeleton\":\n                return \"Disparo flechas y soy de huesos, ¬øqui√©n soy?\";\n            case \"spider\":\n                return \"Tengo ocho patas y trepo paredes, ¬øqui√©n soy?\";\n            case \"agua\":\n                return \"Soy l√≠quida y azul, ¬øqu√© soy?\";\n            case \"fuego\":\n                return \"Soy caliente y quemo, ¬øqu√© soy?\";\n            case \"monta√±a\":\n                return \"Soy alta y rocosa, ¬øqu√© soy?\";\n            case \"oc√©ano\":\n                return \"Soy grande y lleno de agua, ¬øqu√© soy?\";\n            case \"sol\":\n                return \"Ilumino el d√≠a, ¬øqu√© soy?\";\n            case \"luna\":\n                return \"Ilumino la noche, ¬øqu√© soy?\";\n            case \"estrella\":\n                return \"Brillo en el cielo nocturno, ¬øqu√© soy?\";\n            default:\n                return \"Adivina la palabra relacionada con: \" + word.substring(0, 1).toUpperCase() + \"_\".repeat(word.length() - 1);\n        }\n    }\n    \n    private List<String> getDefaultWords() {\n        List<String> defaultWords = new ArrayList<>();\n        defaultWords.add(\"minecraft\");\n        defaultWords.add(\"creeper\");\n        defaultWords.add(\"diamante\");\n        defaultWords.add(\"redstone\");\n        defaultWords.add(\"nether\");\n        defaultWords.add(\"portal\");\n        defaultWords.add(\"zombie\");\n        defaultWords.add(\"skeleton\");\n        defaultWords.add(\"spider\");\n        defaultWords.add(\"agua\");\n        defaultWords.add(\"fuego\");\n        defaultWords.add(\"tierra\");\n        defaultWords.add(\"aire\");\n        return defaultWords;\n    }\n}","size_bytes":5267},"src/main/java/com/hyser/hysercore/managers/ChatGameManager.java":{"content":"package com.hyser.hysercore.managers;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.games.ChatGame;\nimport com.hyser.hysercore.games.MathGame;\nimport com.hyser.hysercore.games.WordGame;\nimport com.hyser.hysercore.games.TriviaGame;\nimport com.hyser.hysercore.games.CompleteGame;\nimport com.hyser.hysercore.games.NumberGame;\nimport com.hyser.hysercore.utils.PlayerStats;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.AsyncPlayerChatEvent;\nimport org.bukkit.scheduler.BukkitRunnable;\nimport org.bukkit.scheduler.BukkitTask;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ChatGameManager implements Listener {\n    \n    private HyserCore plugin;\n    private FileConfiguration config;\n    private ChatGame currentGame;\n    private BukkitTask gameTask;\n    private BukkitTask intervalTask;\n    private PlayerStats playerStats;\n    \n    public ChatGameManager(HyserCore plugin) {\n        this.plugin = plugin;\n        this.playerStats = new PlayerStats();\n        loadConfig();\n        startGameInterval();\n    }\n    \n    public void loadConfig() {\n        File configFile = new File(plugin.getDataFolder(), \"chatgames.yml\");\n        if (!configFile.exists()) {\n            plugin.saveResource(\"chatgames.yml\", false);\n        }\n        config = YamlConfiguration.loadConfiguration(configFile);\n    }\n    \n    public void reloadConfig() {\n        loadConfig();\n        restartGameInterval();\n        plugin.getLogger().info(\"Configuraci√≥n de ChatGames recargada\");\n    }\n    \n    private void startGameInterval() {\n        if (!config.getBoolean(\"general.enabled\", true)) {\n            return;\n        }\n        \n        int minInterval = config.getInt(\"general.interval.min\", 300);\n        int maxInterval = config.getInt(\"general.interval.max\", 600);\n        int interval = ThreadLocalRandom.current().nextInt(minInterval, maxInterval + 1);\n        \n        intervalTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                startRandomGame();\n                startGameInterval(); // Programar el siguiente juego\n            }\n        }.runTaskLater(plugin, interval * 20L);\n    }\n    \n    private void restartGameInterval() {\n        if (intervalTask != null) {\n            intervalTask.cancel();\n        }\n        startGameInterval();\n    }\n    \n    private void startRandomGame() {\n        if (currentGame != null) {\n            return; // Ya hay un juego en progreso\n        }\n        \n        int minPlayers = config.getInt(\"general.min-players\", 3);\n        if (Bukkit.getOnlinePlayers().size() < minPlayers) {\n            if (config.getBoolean(\"advanced.cancel-if-not-enough-players\", true)) {\n                return;\n            }\n        }\n        \n        String gameType = selectRandomGameType();\n        if (gameType == null) {\n            return;\n        }\n        \n        currentGame = createGame(gameType);\n        if (currentGame != null) {\n            startGame();\n        }\n    }\n    \n    private String selectRandomGameType() {\n        List<String> availableTypes = new ArrayList<>();\n        Map<String, Integer> weights = new HashMap<>();\n        \n        if (config.getBoolean(\"game-types.math.enabled\", true)) {\n            int weight = config.getInt(\"game-types.math.weight\", 30);\n            weights.put(\"math\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"math\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.word.enabled\", true)) {\n            int weight = config.getInt(\"game-types.word.weight\", 25);\n            weights.put(\"word\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"word\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.trivia.enabled\", true)) {\n            int weight = config.getInt(\"game-types.trivia.weight\", 20);\n            weights.put(\"trivia\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"trivia\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.complete.enabled\", true)) {\n            int weight = config.getInt(\"game-types.complete.weight\", 15);\n            weights.put(\"complete\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"complete\");\n            }\n        }\n        \n        if (config.getBoolean(\"game-types.number.enabled\", true)) {\n            int weight = config.getInt(\"game-types.number.weight\", 10);\n            weights.put(\"number\", weight);\n            for (int i = 0; i < weight; i++) {\n                availableTypes.add(\"number\");\n            }\n        }\n        \n        if (availableTypes.isEmpty()) {\n            return null;\n        }\n        \n        return availableTypes.get(ThreadLocalRandom.current().nextInt(availableTypes.size()));\n    }\n    \n    private ChatGame createGame(String type) {\n        switch (type.toLowerCase()) {\n            case \"math\":\n                return new MathGame(config);\n            case \"word\":\n                return new WordGame(config);\n            case \"trivia\":\n                return new TriviaGame(config);\n            case \"complete\":\n                return new CompleteGame(config);\n            case \"number\":\n                return new NumberGame(config);\n            default:\n                return null;\n        }\n    }\n    \n    private void startGame() {\n        if (currentGame == null) {\n            return;\n        }\n        \n        // Anunciar inicio del juego\n        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n        String gameStarting = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-starting\", \"\"));\n        String gameType = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-type\", \"\").replace(\"{type}\", currentGame.getTypeName()));\n        int duration = config.getInt(\"general.duration\", 60);\n        String gameDuration = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-duration\", \"\").replace(\"{duration}\", String.valueOf(duration)));\n        int reward = config.getInt(\"rewards.winner.money\", 1000);\n        String gameReward = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-reward\", \"\").replace(\"{reward}\", String.valueOf(reward)));\n        \n        Bukkit.broadcastMessage(prefix + gameStarting);\n        Bukkit.broadcastMessage(prefix + gameType);\n        Bukkit.broadcastMessage(prefix + gameDuration);\n        Bukkit.broadcastMessage(prefix + gameReward);\n        \n        // Mostrar pregunta\n        String question = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.question\", \"\").replace(\"{question}\", currentGame.getQuestion()));\n        Bukkit.broadcastMessage(prefix + question);\n        \n        // Programar avisos de tiempo\n        scheduleTimeWarnings(duration);\n        \n        // Programar fin del juego\n        gameTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                endGame(null);\n            }\n        }.runTaskLater(plugin, duration * 20L);\n    }\n    \n    private void scheduleTimeWarnings(int duration) {\n        // Aviso a los 30 segundos si la duraci√≥n es mayor a 30\n        if (duration > 30) {\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (currentGame != null) {\n                        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n                        String timeLeft = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.time-left\", \"\").replace(\"{time}\", \"30\"));\n                        Bukkit.broadcastMessage(prefix + timeLeft);\n                    }\n                }\n            }.runTaskLater(plugin, (duration - 30) * 20L);\n        }\n        \n        // Aviso a los 10 segundos\n        if (duration > 10) {\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (currentGame != null) {\n                        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n                        String timeLeft = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.time-left\", \"\").replace(\"{time}\", \"10\"));\n                        Bukkit.broadcastMessage(prefix + timeLeft);\n                    }\n                }\n            }.runTaskLater(plugin, (duration - 10) * 20L);\n        }\n    }\n    \n    @EventHandler\n    public void onPlayerChat(AsyncPlayerChatEvent event) {\n        if (currentGame == null) {\n            return;\n        }\n        \n        Player player = event.getPlayer();\n        String message = event.getMessage().trim();\n        \n        if (!player.hasPermission(\"hysercore.participate\")) {\n            return;\n        }\n        \n        if (currentGame.checkAnswer(message)) {\n            // Cancelar el evento para evitar que se muestre en el chat\n            event.setCancelled(true);\n            \n            // Ejecutar en el hilo principal\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n                    endGame(player);\n                }\n            }.runTask(plugin);\n        }\n    }\n    \n    private void endGame(Player winner) {\n        if (currentGame == null) {\n            return;\n        }\n        \n        // Cancelar task del juego\n        if (gameTask != null) {\n            gameTask.cancel();\n        }\n        \n        String prefix = ChatColor.translateAlternateColorCodes('&', config.getString(\"general.prefix\", \"\"));\n        \n        if (winner != null) {\n            // Hay ganador\n            String winnerMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.winner\", \"\")\n                    .replace(\"{player}\", winner.getName())\n                    .replace(\"{answer}\", currentGame.getAnswer()));\n            Bukkit.broadcastMessage(prefix + winnerMessage);\n            \n            // Dar recompensas\n            giveRewards(winner, true);\n            \n            // Actualizar estad√≠sticas\n            playerStats.addWin(winner.getUniqueId());\n        } else {\n            // No hay ganador\n            String noWinnerMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.no-winner\", \"\").replace(\"{answer}\", currentGame.getAnswer()));\n            Bukkit.broadcastMessage(prefix + noWinnerMessage);\n        }\n        \n        String gameEnded = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.game-ended\", \"\"));\n        Bukkit.broadcastMessage(prefix + gameEnded);\n        \n        // Actualizar estad√≠sticas para todos los jugadores que participaron\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            if (player.hasPermission(\"hysercore.participate\")) {\n                playerStats.addGame(player.getUniqueId());\n                if (winner == null || !player.equals(winner)) {\n                    giveRewards(player, false);\n                }\n            }\n        }\n        \n        currentGame = null;\n    }\n    \n    private void giveRewards(Player player, boolean isWinner) {\n        String rewardType = isWinner ? \"winner\" : \"participation\";\n        \n        // Recompensa de dinero (requiere Vault)\n        int money = config.getInt(\"rewards.\" + rewardType + \".money\", 0);\n        if (money > 0) {\n            // Aqu√≠ se integrar√≠a con Vault para dar dinero\n            String moneyReward = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.money-reward\", \"\").replace(\"{amount}\", String.valueOf(money)));\n            player.sendMessage(moneyReward);\n        }\n        \n        // Recompensa de experiencia\n        int experience = config.getInt(\"rewards.\" + rewardType + \".experience\", 0);\n        if (experience > 0) {\n            player.giveExp(experience);\n            String expReward = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.exp-reward\", \"\").replace(\"{amount}\", String.valueOf(experience)));\n            player.sendMessage(expReward);\n        }\n        \n        // Comandos de recompensa\n        List<String> commands = config.getStringList(\"rewards.\" + rewardType + \".commands\");\n        for (String command : commands) {\n            command = command.replace(\"{player}\", player.getName());\n            Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command);\n        }\n        \n        String rewardGiven = ChatColor.translateAlternateColorCodes('&', config.getString(\"messages.reward-given\", \"\"));\n        player.sendMessage(rewardGiven);\n    }\n    \n    public void forceStartGame(String type) {\n        if (currentGame != null) {\n            endGame(null);\n        }\n        \n        currentGame = createGame(type);\n        if (currentGame != null) {\n            startGame();\n        }\n    }\n    \n    public void stopCurrentGame() {\n        if (currentGame != null) {\n            endGame(null);\n        }\n    }\n    \n    public boolean isGameActive() {\n        return currentGame != null;\n    }\n    \n    public PlayerStats getPlayerStats() {\n        return playerStats;\n    }\n    \n    public void shutdown() {\n        if (gameTask != null) {\n            gameTask.cancel();\n        }\n        if (intervalTask != null) {\n            intervalTask.cancel();\n        }\n        if (currentGame != null) {\n            endGame(null);\n        }\n    }\n}","size_bytes":13918},"src/main/java/com/hyser/hysercore/teamviewer/LunarTeamViewer.java":{"content":"package com.hyser.hysercore.teamviewer;\n\nimport com.hyser.hysercore.HyserCore;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Location;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class LunarTeamViewer {\n    \n    private HyserCore plugin;\n    private FileConfiguration config;\n    private Map<UUID, Boolean> teamViewerEnabled;\n    private Plugin ultimateClans;\n    private BukkitRunnable updateTask;\n    \n    public LunarTeamViewer(HyserCore plugin) {\n        this.plugin = plugin;\n        this.config = plugin.getConfig();\n        this.teamViewerEnabled = new HashMap<>();\n        \n        // Verificar si UltimateClans est√° disponible\n        this.ultimateClans = Bukkit.getPluginManager().getPlugin(\"UltimateClans\");\n        if (ultimateClans == null) {\n            plugin.getLogger().warning(\"UltimateClans no encontrado. LunarTeamViewer funcionar√° sin integraci√≥n de clanes.\");\n        } else {\n            plugin.getLogger().info(\"UltimateClans detectado. LunarTeamViewer integrado.\");\n        }\n        \n        // Iniciar actualizaciones autom√°ticas\n        startTeamViewerUpdates();\n    }\n    \n    public boolean toggleTeamViewer(Player player) {\n        if (!config.getBoolean(\"lunar-teamviewer.enabled\", true)) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-teamviewer.messages.system-disabled\", \n                \"&cEl sistema de teamviewer est√° deshabilitado.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        // Verificar permisos\n        if (!player.hasPermission(\"hysercore.teamviewer\") && !player.hasPermission(\"hysercore.admin\")) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-teamviewer.messages.no-permission\", \n                \"&cNo tienes permisos para usar teamviewer.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        String clanName = getClanName(player);\n        if (clanName == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-teamviewer.messages.no-clan\", \n                \"&cDebes estar en un clan para usar teamviewer.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        UUID playerId = player.getUniqueId();\n        boolean currentStatus = teamViewerEnabled.getOrDefault(playerId, false);\n        boolean newStatus = !currentStatus;\n        \n        teamViewerEnabled.put(playerId, newStatus);\n        \n        if (newStatus) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-teamviewer.messages.teamviewer-enabled\", \n                \"&a¬°TeamViewer activado! Puedes ver a tus compa√±eros de clan.\"));\n            player.sendMessage(message);\n        } else {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-teamviewer.messages.teamviewer-disabled\", \n                \"&cTeamViewer desactivado.\"));\n            player.sendMessage(message);\n        }\n        \n        return newStatus;\n    }\n    \n    public void showTeamMembers(Player player) {\n        if (!isTeamViewerEnabled(player)) {\n            return;\n        }\n        \n        String clanName = getClanName(player);\n        if (clanName == null) {\n            return;\n        }\n        \n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&d&l                    TEAMVIEWER - CLAN \" + clanName.toUpperCase()));\n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n        \n        boolean foundMembers = false;\n        \n        for (Player onlinePlayer : Bukkit.getOnlinePlayers()) {\n            if (onlinePlayer.equals(player)) {\n                continue; // No mostrarse a s√≠ mismo\n            }\n            \n            String memberClan = getClanName(onlinePlayer);\n            if (memberClan != null && memberClan.equals(clanName)) {\n                // CR√çTICO: Solo mostrar jugadores en el MISMO MUNDO\n                if (!onlinePlayer.getWorld().getName().equals(player.getWorld().getName())) {\n                    continue; // No mostrar jugadores de otros mundos\n                }\n                \n                Location memberLocation = onlinePlayer.getLocation();\n                double distance = player.getLocation().distance(memberLocation);\n                String direction = getDirection(player.getLocation(), memberLocation);\n                String worldName = onlinePlayer.getWorld().getName();\n                \n                // Informaci√≥n del miembro del clan\n                String memberInfo = ChatColor.translateAlternateColorCodes('&', \n                    config.getString(\"lunar-teamviewer.messages.clan-member-info\", \n                    \"&f‚óè &b{player} &7- &e{distance}m &7{direction} &8[{world}]\")\n                    .replace(\"{player}\", onlinePlayer.getName())\n                    .replace(\"{distance}\", String.format(\"%.1f\", distance))\n                    .replace(\"{direction}\", direction)\n                    .replace(\"{world}\", worldName));\n                \n                player.sendMessage(memberInfo);\n                foundMembers = true;\n            }\n        }\n        \n        if (!foundMembers) {\n            player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-teamviewer.messages.no-clan-members\", \n                \"&7No hay miembros de tu clan online en este mundo.\")));\n        }\n        \n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n    }\n    \n    public boolean isTeamViewerEnabled(Player player) {\n        return teamViewerEnabled.getOrDefault(player.getUniqueId(), false);\n    }\n    \n    private String getClanName(Player player) {\n        if (ultimateClans == null || player == null) {\n            return null;\n        }\n        \n        try {\n            // Usar el mismo m√©todo mejorado que LunarWaypoints\n            \n            // Intento 1: API moderna de UltimateClans\n            try {\n                Class<?> ultimateClansAPI = Class.forName(\"me.ulrichbg.UltimateClans.API.UltimateClansAPI\");\n                Object apiInstance = ultimateClansAPI.getMethod(\"getInstance\").invoke(null);\n                Object clan = ultimateClansAPI.getMethod(\"getPlayerClan\", UUID.class).invoke(apiInstance, player.getUniqueId());\n                \n                if (clan != null) {\n                    return (String) clan.getClass().getMethod(\"getName\").invoke(clan);\n                }\n            } catch (Exception e) {\n                plugin.getLogger().fine(\"Error al obtener clan (TeamViewer): \" + e.getMessage());\n            }\n            \n            // Intento 2: API alternativa\n            try {\n                Class<?> clanPlayer = Class.forName(\"me.ulrichbg.UltimateClans.ClanPlayer\");\n                Object playerObj = clanPlayer.getConstructor(UUID.class).newInstance(player.getUniqueId());\n                Object clan = clanPlayer.getMethod(\"getClan\").invoke(playerObj);\n                \n                if (clan != null) {\n                    return (String) clan.getClass().getMethod(\"getName\").invoke(clan);\n                }\n            } catch (Exception e) {\n                plugin.getLogger().fine(\"Error al obtener clan m√©todo 2 (TeamViewer): \" + e.getMessage());\n            }\n            \n        } catch (Exception e) {\n            plugin.getLogger().warning(\"Error cr√≠tico al acceder a UltimateClans (TeamViewer): \" + e.getMessage());\n        }\n        \n        return null;\n    }\n    \n    private String getDirection(Location from, Location to) {\n        double dx = to.getX() - from.getX();\n        double dz = to.getZ() - from.getZ();\n        \n        double angle = Math.atan2(dz, dx) * 180 / Math.PI;\n        \n        if (angle < 0) {\n            angle += 360;\n        }\n        \n        if (angle >= 337.5 || angle < 22.5) {\n            return \"‚Üí Este\";\n        } else if (angle >= 22.5 && angle < 67.5) {\n            return \"‚Üò Sureste\";\n        } else if (angle >= 67.5 && angle < 112.5) {\n            return \"‚Üì Sur\";\n        } else if (angle >= 112.5 && angle < 157.5) {\n            return \"‚Üô Suroeste\";\n        } else if (angle >= 157.5 && angle < 202.5) {\n            return \"‚Üê Oeste\";\n        } else if (angle >= 202.5 && angle < 247.5) {\n            return \"‚Üñ Noroeste\";\n        } else if (angle >= 247.5 && angle < 292.5) {\n            return \"‚Üë Norte\";\n        } else {\n            return \"‚Üó Noreste\";\n        }\n    }\n    \n    // Actualizaciones autom√°ticas del TeamViewer\n    private void startTeamViewerUpdates() {\n        updateTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                updateAllTeamViewers();\n            }\n        };\n        updateTask.runTaskTimer(plugin, 100L, 100L); // Actualizar cada 5 segundos\n    }\n    \n    private void updateAllTeamViewers() {\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            if (isTeamViewerEnabled(player)) {\n                updatePlayerTeamViewer(player);\n            }\n        }\n    }\n    \n    private void updatePlayerTeamViewer(Player player) {\n        String clanName = getClanName(player);\n        if (clanName == null) return;\n        \n        // Actualizaci√≥n silenciosa: contar miembros del clan en el mismo mundo\n        int membersInWorld = 0;\n        for (Player onlinePlayer : Bukkit.getOnlinePlayers()) {\n            if (onlinePlayer.equals(player)) continue;\n            \n            String memberClan = getClanName(onlinePlayer);\n            if (memberClan != null && memberClan.equals(clanName) && \n                onlinePlayer.getWorld().getName().equals(player.getWorld().getName())) {\n                membersInWorld++;\n            }\n        }\n        \n        // Solo mostrar informaci√≥n si hay cambios significativos o cada cierto tiempo\n        // En este caso, mantenemos la actualizaci√≥n silenciosa para mejor rendimiento\n    }\n    \n    public void shutdown() {\n        if (updateTask != null) {\n            updateTask.cancel();\n        }\n        teamViewerEnabled.clear();\n    }\n}","size_bytes":11241},"src/main/java/com/hyser/hysercore/teamviewer/TeamViewerCommand.java":{"content":"package com.hyser.hysercore.teamviewer;\n\nimport com.hyser.hysercore.HyserCore;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class TeamViewerCommand implements CommandExecutor, TabCompleter {\n    \n    private HyserCore plugin;\n    private LunarTeamViewer teamViewerManager;\n    \n    public TeamViewerCommand(HyserCore plugin, LunarTeamViewer teamViewerManager) {\n        this.plugin = plugin;\n        this.teamViewerManager = teamViewerManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Este comando solo puede ser usado por jugadores.\");\n            return true;\n        }\n        \n        Player player = (Player) sender;\n        \n        if (args.length == 0) {\n            teamViewerManager.showTeamMembers(player);\n            return true;\n        }\n        \n        switch (args[0].toLowerCase()) {\n            case \"on\":\n            case \"enable\":\n                teamViewerManager.toggleTeamViewer(player);\n                break;\n                \n            case \"off\":\n            case \"disable\":\n                if (teamViewerManager.isTeamViewerEnabled(player)) {\n                    teamViewerManager.toggleTeamViewer(player);\n                } else {\n                    String message = ChatColor.translateAlternateColorCodes('&', \n                        plugin.getConfig().getString(\"lunar-teamviewer.messages.teamviewer-disabled\", \n                        \"&cTeamViewer ya est√° desactivado.\"));\n                    player.sendMessage(message);\n                }\n                break;\n                \n            case \"toggle\":\n                teamViewerManager.toggleTeamViewer(player);\n                break;\n                \n            case \"list\":\n            case \"show\":\n                teamViewerManager.showTeamMembers(player);\n                break;\n                \n            case \"help\":\n            default:\n                sendHelp(player);\n                break;\n        }\n        \n        return true;\n    }\n    \n    private void sendHelp(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            plugin.getConfig().getString(\"lunar-teamviewer.messages.prefix\", \"&8[&dTeamViewer&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Comandos de LunarTeamViewer ===\");\n        player.sendMessage(ChatColor.YELLOW + \"/teamviewer\" + ChatColor.GRAY + \" - Ver miembros del clan\");\n        player.sendMessage(ChatColor.YELLOW + \"/teamviewer on\" + ChatColor.GRAY + \" - Activar teamviewer\");\n        player.sendMessage(ChatColor.YELLOW + \"/teamviewer off\" + ChatColor.GRAY + \" - Desactivar teamviewer\");\n        player.sendMessage(ChatColor.YELLOW + \"/teamviewer toggle\" + ChatColor.GRAY + \" - Alternar estado\");\n        player.sendMessage(ChatColor.YELLOW + \"/teamviewer list\" + ChatColor.GRAY + \" - Mostrar lista\");\n        player.sendMessage(ChatColor.YELLOW + \"/teamviewer help\" + ChatColor.GRAY + \" - Ver esta ayuda\");\n        player.sendMessage(ChatColor.GRAY + \"Solo muestra jugadores en el mismo mundo.\");\n        player.sendMessage(ChatColor.GRAY + \"Requiere estar en un clan (UltimateClans).\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.teamviewer\") && !sender.hasPermission(\"hysercore.admin\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] subCommands = {\"on\", \"off\", \"toggle\", \"list\", \"show\", \"enable\", \"disable\", \"help\"};\n            for (String subCommand : subCommands) {\n                if (subCommand.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(subCommand);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":4288},"src/main/java/com/hyser/hysercore/utils/PlayerStats.java":{"content":"package com.hyser.hysercore.utils;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class PlayerStats {\n    \n    private Map<UUID, Integer> gamesPlayed;\n    private Map<UUID, Integer> gamesWon;\n    private Map<UUID, Integer> totalRewards;\n    \n    public PlayerStats() {\n        this.gamesPlayed = new HashMap<>();\n        this.gamesWon = new HashMap<>();\n        this.totalRewards = new HashMap<>();\n    }\n    \n    public void addGame(UUID playerId) {\n        gamesPlayed.put(playerId, gamesPlayed.getOrDefault(playerId, 0) + 1);\n    }\n    \n    public void addWin(UUID playerId) {\n        gamesWon.put(playerId, gamesWon.getOrDefault(playerId, 0) + 1);\n    }\n    \n    public void addReward(UUID playerId, int amount) {\n        totalRewards.put(playerId, totalRewards.getOrDefault(playerId, 0) + amount);\n    }\n    \n    public int getGamesPlayed(UUID playerId) {\n        return gamesPlayed.getOrDefault(playerId, 0);\n    }\n    \n    public int getGamesWon(UUID playerId) {\n        return gamesWon.getOrDefault(playerId, 0);\n    }\n    \n    public int getTotalRewards(UUID playerId) {\n        return totalRewards.getOrDefault(playerId, 0);\n    }\n    \n    public double getWinRate(UUID playerId) {\n        int played = getGamesPlayed(playerId);\n        if (played == 0) {\n            return 0.0;\n        }\n        return (double) getGamesWon(playerId) / played * 100.0;\n    }\n    \n    public Map<UUID, Integer> getTopPlayers(int limit) {\n        return gamesWon.entrySet().stream()\n            .sorted(Map.Entry.<UUID, Integer>comparingByValue().reversed())\n            .limit(limit)\n            .collect(java.util.stream.Collectors.toMap(\n                Map.Entry::getKey,\n                Map.Entry::getValue,\n                (e1, e2) -> e1,\n                java.util.LinkedHashMap::new\n            ));\n    }\n}","size_bytes":1839},"src/main/java/com/hyser/hysercore/waypoints/LunarWaypoints.java":{"content":"package com.hyser.hysercore.waypoints;\n\nimport com.hyser.hysercore.HyserCore;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Location;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class LunarWaypoints {\n    \n    private HyserCore plugin;\n    private FileConfiguration config;\n    private Map<String, Map<UUID, WaypointData>> clanWaypoints; // clan -> player -> waypoint\n    private Plugin ultimateClans;\n    private BukkitRunnable updateTask;\n    \n    public LunarWaypoints(HyserCore plugin) {\n        this.plugin = plugin;\n        this.config = plugin.getConfig();\n        this.clanWaypoints = new HashMap<>();\n        \n        // Verificar si UltimateClans est√° disponible con mejor detecci√≥n\n        this.ultimateClans = Bukkit.getPluginManager().getPlugin(\"UltimateClans\");\n        if (ultimateClans == null) {\n            plugin.getLogger().warning(\"UltimateClans no encontrado. LunarWaypoints funcionar√° sin integraci√≥n de clanes.\");\n        } else {\n            plugin.getLogger().info(\"UltimateClans detectado v\" + ultimateClans.getDescription().getVersion() + \". Integraci√≥n activada.\");\n        }\n        \n        // Iniciar actualizaci√≥n autom√°tica tipo F3 rally\n        startRallyUpdates();\n    }\n    \n    public boolean setWaypoint(Player player, String waypointName, Location location) {\n        if (!config.getBoolean(\"lunar-waypoints.enabled\", true)) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.system-disabled\", \n                \"&cEl sistema de waypoints est√° deshabilitado.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        // Verificar permisos\n        if (!player.hasPermission(\"hysercore.waypoints\") && !player.hasPermission(\"hysercore.admin\")) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-permission\", \n                \"&cNo tienes permisos para usar waypoints.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        String clanName = getClanName(player);\n        if (clanName == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-clan\", \n                \"&cDebes estar en un clan para establecer waypoints.\"));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        // Verificar l√≠mite de waypoints por clan\n        int maxWaypoints = config.getInt(\"lunar-waypoints.max-waypoints-per-clan\", 3);\n        Map<UUID, WaypointData> clanMap = clanWaypoints.computeIfAbsent(clanName, k -> new HashMap<>());\n        \n        if (clanMap.size() >= maxWaypoints && !clanMap.containsKey(player.getUniqueId())) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.max-waypoints\", \n                \"&cTu clan ya tiene el m√°ximo de waypoints permitidos ({max}).\")\n                .replace(\"{max}\", String.valueOf(maxWaypoints)));\n            player.sendMessage(message);\n            return false;\n        }\n        \n        // Establecer waypoint\n        WaypointData waypoint = new WaypointData(waypointName, location.clone(), System.currentTimeMillis());\n        clanMap.put(player.getUniqueId(), waypoint);\n        \n        String successMessage = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lunar-waypoints.messages.waypoint-set\", \n            \"&a¬°Waypoint '{name}' establecido para el clan {clan}!\")\n            .replace(\"{name}\", waypointName)\n            .replace(\"{clan}\", clanName));\n        player.sendMessage(successMessage);\n        \n        return true;\n    }\n    \n    public void showWaypoints(Player player) {\n        if (!config.getBoolean(\"lunar-waypoints.enabled\", true)) {\n            return;\n        }\n        \n        String clanName = getClanName(player);\n        if (clanName == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-clan\", \n                \"&cDebes estar en un clan para ver waypoints.\"));\n            player.sendMessage(message);\n            return;\n        }\n        \n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&b&l                    WAYPOINTS - CLAN \" + clanName.toUpperCase()));\n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n        \n        Map<UUID, WaypointData> clanMap = clanWaypoints.get(clanName);\n        if (clanMap == null || clanMap.isEmpty()) {\n            player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.no-waypoints\", \n                \"&7No hay waypoints establecidos en tu clan.\")));\n        } else {\n            for (Map.Entry<UUID, WaypointData> entry : clanMap.entrySet()) {\n                Player waypointOwner = Bukkit.getPlayer(entry.getKey());\n                WaypointData waypoint = entry.getValue();\n                \n                if (waypointOwner != null) {\n                    // Verificar que el waypoint est√© en el mismo mundo\n                    if (!waypoint.getLocation().getWorld().getName().equals(player.getWorld().getName())) {\n                        continue; // No mostrar waypoints de otros mundos\n                    }\n                    \n                    double distance = player.getLocation().distance(waypoint.getLocation());\n                    String direction = getDirection(player.getLocation(), waypoint.getLocation());\n                    \n                    String waypointInfo = ChatColor.translateAlternateColorCodes('&', \n                        \"&f‚óè &b{name} &7({player}) - &e{distance}m &7{direction}\")\n                        .replace(\"{name}\", waypoint.getName())\n                        .replace(\"{player}\", waypointOwner.getName())\n                        .replace(\"{distance}\", String.format(\"%.1f\", distance))\n                        .replace(\"{direction}\", direction);\n                    \n                    player.sendMessage(waypointInfo);\n                }\n            }\n        }\n        \n        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \n            \"&8‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨\"));\n    }\n    \n    public boolean removeWaypoint(Player player) {\n        String clanName = getClanName(player);\n        if (clanName == null) {\n            return false;\n        }\n        \n        Map<UUID, WaypointData> clanMap = clanWaypoints.get(clanName);\n        if (clanMap != null && clanMap.containsKey(player.getUniqueId())) {\n            clanMap.remove(player.getUniqueId());\n            \n            String message = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lunar-waypoints.messages.waypoint-removed\", \n                \"&cWaypoint eliminado.\"));\n            player.sendMessage(message);\n            return true;\n        }\n        \n        String message = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lunar-waypoints.messages.no-waypoint\", \n            \"&cNo tienes ning√∫n waypoint establecido.\"));\n        player.sendMessage(message);\n        return false;\n    }\n    \n    private String getClanName(Player player) {\n        if (ultimateClans == null || player == null) {\n            return null;\n        }\n        \n        try {\n            // M√©todo mejorado para obtener clan con m√∫ltiples intentos\n            \n            // Intento 1: API moderna de UltimateClans\n            try {\n                Class<?> ultimateClansAPI = Class.forName(\"me.ulrichbg.UltimateClans.API.UltimateClansAPI\");\n                Object apiInstance = ultimateClansAPI.getMethod(\"getInstance\").invoke(null);\n                Object clan = ultimateClansAPI.getMethod(\"getPlayerClan\", UUID.class).invoke(apiInstance, player.getUniqueId());\n                \n                if (clan != null) {\n                    return (String) clan.getClass().getMethod(\"getName\").invoke(clan);\n                }\n            } catch (Exception e) {\n                plugin.getLogger().fine(\"Intento 1 fallido para obtener clan: \" + e.getMessage());\n            }\n            \n            // Intento 2: API alternativa\n            try {\n                Class<?> clanPlayer = Class.forName(\"me.ulrichbg.UltimateClans.ClanPlayer\");\n                Object playerObj = clanPlayer.getConstructor(UUID.class).newInstance(player.getUniqueId());\n                Object clan = clanPlayer.getMethod(\"getClan\").invoke(playerObj);\n                \n                if (clan != null) {\n                    return (String) clan.getClass().getMethod(\"getName\").invoke(clan);\n                }\n            } catch (Exception e) {\n                plugin.getLogger().fine(\"Intento 2 fallido para obtener clan: \" + e.getMessage());\n            }\n            \n            // Intento 3: Comandos directo (√∫ltimo recurso)\n            // Este m√©todo no se implementa para evitar spam de comandos\n            \n        } catch (Exception e) {\n            plugin.getLogger().warning(\"Error cr√≠tico al acceder a UltimateClans: \" + e.getMessage());\n        }\n        \n        return null;\n    }\n    \n    private String getDirection(Location from, Location to) {\n        double dx = to.getX() - from.getX();\n        double dz = to.getZ() - from.getZ();\n        \n        double angle = Math.atan2(dz, dx) * 180 / Math.PI;\n        \n        if (angle < 0) {\n            angle += 360;\n        }\n        \n        if (angle >= 337.5 || angle < 22.5) {\n            return \"‚Üí Este\";\n        } else if (angle >= 22.5 && angle < 67.5) {\n            return \"‚Üò Sureste\";\n        } else if (angle >= 67.5 && angle < 112.5) {\n            return \"‚Üì Sur\";\n        } else if (angle >= 112.5 && angle < 157.5) {\n            return \"‚Üô Suroeste\";\n        } else if (angle >= 157.5 && angle < 202.5) {\n            return \"‚Üê Oeste\";\n        } else if (angle >= 202.5 && angle < 247.5) {\n            return \"‚Üñ Noroeste\";\n        } else if (angle >= 247.5 && angle < 292.5) {\n            return \"‚Üë Norte\";\n        } else {\n            return \"‚Üó Noreste\";\n        }\n    }\n    \n    // NUEVO: Sistema tipo F rally con actualizaciones autom√°ticas\n    private void startRallyUpdates() {\n        updateTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                updateAllWaypoints();\n            }\n        };\n        updateTask.runTaskTimer(plugin, 60L, 60L); // Actualizar cada 3 segundos\n    }\n    \n    private void updateAllWaypoints() {\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            if (player.hasPermission(\"hysercore.waypoints\")) {\n                updatePlayerWaypoints(player, false); // Actualizaci√≥n silenciosa\n            }\n        }\n    }\n    \n    public void updatePlayerWaypoints(Player player, boolean showHeader) {\n        String clanName = getClanName(player);\n        if (clanName == null) return;\n        \n        Map<UUID, WaypointData> clanMap = clanWaypoints.get(clanName);\n        if (clanMap == null || clanMap.isEmpty()) return;\n        \n        if (showHeader) {\n            player.sendMessage(ChatColor.translateAlternateColorCodes('&', \"&8[&bWaypoints&8] &7Actualizando posiciones...\"));\n        }\n        \n        for (Map.Entry<UUID, WaypointData> entry : clanMap.entrySet()) {\n            Player waypointOwner = Bukkit.getPlayer(entry.getKey());\n            WaypointData waypoint = entry.getValue();\n            \n            if (waypointOwner != null && !waypointOwner.equals(player)) {\n                // Solo mostrar si est√°n en el mismo mundo\n                if (waypoint.getLocation().getWorld().getName().equals(player.getWorld().getName())) {\n                    double distance = player.getLocation().distance(waypoint.getLocation());\n                    String direction = getDirection(player.getLocation(), waypoint.getLocation());\n                    \n                    // Mostrar en action bar si es posible (1.8+)\n                    String info = ChatColor.translateAlternateColorCodes('&', \n                        \"&b{name} &7- &e{distance}m &7{direction}\")\n                        .replace(\"{name}\", waypoint.getName())\n                        .replace(\"{distance}\", String.format(\"%.0f\", distance))\n                        .replace(\"{direction}\", direction);\n                    \n                    // En 1.8.8 usamos chat normal ya que action bar es limitado\n                    if (showHeader) {\n                        player.sendMessage(ChatColor.translateAlternateColorCodes('&', \"&8‚Üí \") + info);\n                    }\n                }\n            }\n        }\n    }\n    \n    public void shutdown() {\n        if (updateTask != null) {\n            updateTask.cancel();\n        }\n    }\n    \n    // Clase para datos del waypoint\n    private static class WaypointData {\n        private String name;\n        private Location location;\n        private long timestamp;\n        \n        public WaypointData(String name, Location location, long timestamp) {\n            this.name = name;\n            this.location = location;\n            this.timestamp = timestamp;\n        }\n        \n        public String getName() { return name; }\n        public Location getLocation() { return location; }\n        public long getTimestamp() { return timestamp; }\n    }\n}","size_bytes":14421},"src/main/java/com/hyser/hysercore/waypoints/WaypointsCommand.java":{"content":"package com.hyser.hysercore.waypoints;\n\nimport com.hyser.hysercore.HyserCore;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class WaypointsCommand implements CommandExecutor, TabCompleter {\n    \n    private HyserCore plugin;\n    private LunarWaypoints waypointManager;\n    \n    public WaypointsCommand(HyserCore plugin, LunarWaypoints waypointManager) {\n        this.plugin = plugin;\n        this.waypointManager = waypointManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Este comando solo puede ser usado por jugadores.\");\n            return true;\n        }\n        \n        Player player = (Player) sender;\n        \n        if (args.length == 0) {\n            sendHelp(player);\n            return true;\n        }\n        \n        switch (args[0].toLowerCase()) {\n            case \"set\":\n                if (args.length < 2) {\n                    player.sendMessage(ChatColor.RED + \"Uso: /waypoints set <nombre>\");\n                    return true;\n                }\n                String waypointName = args[1];\n                waypointManager.setWaypoint(player, waypointName, player.getLocation());\n                break;\n                \n            case \"list\":\n            case \"show\":\n                waypointManager.showWaypoints(player);\n                break;\n                \n            case \"remove\":\n            case \"delete\":\n                waypointManager.removeWaypoint(player);\n                break;\n                \n            case \"help\":\n            default:\n                sendHelp(player);\n                break;\n        }\n        \n        return true;\n    }\n    \n    private void sendHelp(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            plugin.getConfig().getString(\"lunar-waypoints.messages.prefix\", \"&8[&bWaypoints&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Comandos de LunarWaypoints ===\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints set <nombre>\" + ChatColor.GRAY + \" - Establecer waypoint\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints list\" + ChatColor.GRAY + \" - Ver waypoints del clan\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints remove\" + ChatColor.GRAY + \" - Eliminar tu waypoint\");\n        player.sendMessage(ChatColor.YELLOW + \"/waypoints help\" + ChatColor.GRAY + \" - Ver esta ayuda\");\n        player.sendMessage(ChatColor.GRAY + \"Los waypoints solo funcionan en el mismo mundo.\");\n        player.sendMessage(ChatColor.GRAY + \"Requiere estar en un clan (UltimateClans).\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.waypoints\") && !sender.hasPermission(\"hysercore.admin\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] subCommands = {\"set\", \"list\", \"show\", \"remove\", \"delete\", \"help\"};\n            for (String subCommand : subCommands) {\n                if (subCommand.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(subCommand);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":3717},"src/main/java/com/hyser/hysercore/enchantments/commands/EnchantBookCommand.java":{"content":"package com.hyser.hysercore.enchantments.commands;\n\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class EnchantBookCommand implements CommandExecutor, TabCompleter {\n    \n    private SwordEnchantmentManager enchantmentManager;\n    \n    public EnchantBookCommand(SwordEnchantmentManager enchantmentManager) {\n        this.enchantmentManager = enchantmentManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Este comando solo puede ser usado por jugadores.\");\n            return true;\n        }\n        \n        Player player = (Player) sender;\n        \n        if (!player.hasPermission(\"hysercore.admin\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            player.sendMessage(noPermission);\n            return true;\n        }\n        \n        if (args.length == 0) {\n            sendHelp(player);\n            return true;\n        }\n        \n        String enchantType = args[0].toLowerCase();\n        SwordEnchantment enchantment = null;\n        \n        switch (enchantType) {\n            case \"dash\":\n                enchantment = enchantmentManager.getEnchantment(\"dash\");\n                break;\n            case \"iceaspect\":\n            case \"ice_aspect\":\n                enchantment = enchantmentManager.getEnchantment(\"ice_aspect\");\n                break;\n            case \"sharpness\":\n                enchantment = enchantmentManager.getEnchantment(\"sharpness\");\n                break;\n            case \"lifesteal\":\n                enchantment = enchantmentManager.getEnchantment(\"lifesteal\");\n                break;\n            case \"vampire\":\n                enchantment = enchantmentManager.getEnchantment(\"vampire\");\n                break;\n            case \"bleeding\":\n                enchantment = enchantmentManager.getEnchantment(\"bleeding\");\n                break;\n            case \"explosive\":\n                enchantment = enchantmentManager.getEnchantment(\"explosive\");\n                break;\n            case \"executioner\":\n                enchantment = enchantmentManager.getEnchantment(\"executioner\");\n                break;\n            default:\n                player.sendMessage(ChatColor.RED + \"Tipo de encantamiento inv√°lido: \" + enchantType);\n                sendHelp(player);\n                return true;\n        }\n        \n        if (enchantment == null) {\n            player.sendMessage(ChatColor.RED + \"El encantamiento \" + enchantType + \" no est√° disponible.\");\n            return true;\n        }\n        \n        // Crear libro de encantamiento\n        ItemStack book = createEnchantmentBook(enchantment);\n        \n        // Dar el libro al jugador\n        if (player.getInventory().firstEmpty() == -1) {\n            player.getWorld().dropItem(player.getLocation(), book);\n            player.sendMessage(ChatColor.YELLOW + \"Tu inventario est√° lleno. El libro se ha dejado caer en el suelo.\");\n        } else {\n            player.getInventory().addItem(book);\n        }\n        \n        String successMessage = ChatColor.translateAlternateColorCodes('&', \n            \"&a¬°Libro de encantamiento &f{enchant} &acreado exitosamente!\")\n            .replace(\"{enchant}\", enchantment.getDisplayName());\n        player.sendMessage(successMessage);\n        \n        return true;\n    }\n    \n    private ItemStack createEnchantmentBook(SwordEnchantment enchantment) {\n        ItemStack book = new ItemStack(Material.BOOK);\n        ItemMeta meta = book.getItemMeta();\n        \n        String bookName = ChatColor.translateAlternateColorCodes('&', \n            \"&6Libro de &e\" + enchantment.getDisplayName());\n        meta.setDisplayName(bookName);\n        \n        List<String> lore = new ArrayList<>();\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Libro de encantamiento\"));\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&8Haz click derecho con una espada\"));\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&8en tu inventario para aplicar.\"));\n        lore.add(\"\");\n        lore.add(ChatColor.translateAlternateColorCodes('&', \"&b‚ö° \" + enchantment.getLoreText()));\n        \n        // Agregar descripci√≥n espec√≠fica del encantamiento\n        switch (enchantment.getName()) {\n            case \"dash\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Impulso a√©reo hacia adelante\"));\n                break;\n            case \"ice_aspect\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Efectos de hielo al atacar\"));\n                break;\n            case \"sharpness\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Aumenta el da√±o de ataque\"));\n                break;\n            case \"lifesteal\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Roba vida de los enemigos\"));\n                break;\n            case \"vampire\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Regeneraci√≥n al atacar\"));\n                break;\n            case \"bleeding\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Causa sangrado continuo\"));\n                break;\n            case \"explosive\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7Knockback explosivo\"));\n                break;\n            case \"executioner\":\n                lore.add(ChatColor.translateAlternateColorCodes('&', \"&7M√°s da√±o a enemigos heridos\"));\n                break;\n        }\n        \n        meta.setLore(lore);\n        book.setItemMeta(meta);\n        \n        return book;\n    }\n    \n    private void sendHelp(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"general.prefix\", \"&8[&bSwordEnchant&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Comandos de Libros de Encantamiento ===\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook dash\" + ChatColor.GRAY + \" - Crear libro de Dash\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook iceaspect\" + ChatColor.GRAY + \" - Crear libro de Ice Aspect\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook sharpness\" + ChatColor.GRAY + \" - Crear libro de Sharpness+\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook lifesteal\" + ChatColor.GRAY + \" - Crear libro de Lifesteal\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook vampire\" + ChatColor.GRAY + \" - Crear libro de Vampire\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook bleeding\" + ChatColor.GRAY + \" - Crear libro de Bleeding\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook explosive\" + ChatColor.GRAY + \" - Crear libro de Explosive\");\n        player.sendMessage(ChatColor.YELLOW + \"/enchantbook executioner\" + ChatColor.GRAY + \" - Crear libro de Executioner\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] enchantTypes = {\"dash\", \"iceaspect\", \"sharpness\", \"lifesteal\", \"vampire\", \"bleeding\", \"explosive\", \"executioner\"};\n            for (String type : enchantTypes) {\n                if (type.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(type);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":8375},"src/main/java/com/hyser/hysercore/enchantments/commands/SwordEnchantCommand.java":{"content":"package com.hyser.hysercore.enchantments.commands;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SwordEnchantCommand implements CommandExecutor, TabCompleter {\n    \n    private HyserCore plugin;\n    private SwordEnchantmentManager enchantmentManager;\n    \n    public SwordEnchantCommand(HyserCore plugin, SwordEnchantmentManager enchantmentManager) {\n        this.plugin = plugin;\n        this.enchantmentManager = enchantmentManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Este comando solo puede ser usado por jugadores.\");\n            return true;\n        }\n        \n        Player player = (Player) sender;\n        \n        if (!player.hasPermission(\"hysercore.swordenchant\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            player.sendMessage(noPermission);\n            return true;\n        }\n        \n        if (args.length == 0) {\n            sendHelp(player);\n            return true;\n        }\n        \n        String subCommand = args[0].toLowerCase();\n        \n        switch (subCommand) {\n            case \"reload\":\n                handleReload(player);\n                break;\n            case \"list\":\n                handleList(player);\n                break;\n            case \"dash\":\n                enchantmentManager.applySwordEnchantment(player, \"dash\");\n                break;\n            case \"ice_aspect\":\n            case \"iceaspect\":\n                enchantmentManager.applySwordEnchantment(player, \"ice_aspect\");\n                break;\n            case \"sharpness\":\n                enchantmentManager.applySwordEnchantment(player, \"sharpness\");\n                break;\n            case \"lifesteal\":\n                enchantmentManager.applySwordEnchantment(player, \"lifesteal\");\n                break;\n            case \"vampire\":\n                enchantmentManager.applySwordEnchantment(player, \"vampire\");\n                break;\n            case \"bleeding\":\n                enchantmentManager.applySwordEnchantment(player, \"bleeding\");\n                break;\n            case \"explosive\":\n                enchantmentManager.applySwordEnchantment(player, \"explosive\");\n                break;\n            case \"executioner\":\n                enchantmentManager.applySwordEnchantment(player, \"executioner\");\n                break;\n            case \"help\":\n            default:\n                sendHelp(player);\n                break;\n        }\n        \n        return true;\n    }\n    \n    private void handleReload(CommandSender sender) {\n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            String noPermission = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"messages.no-permission\", \"&cNo tienes permisos para usar este comando.\"));\n            sender.sendMessage(noPermission);\n            return;\n        }\n        \n        enchantmentManager.reloadConfig();\n        String reloadMessage = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"messages.config-reloaded\", \"&aConfiguraci√≥n de Sword Enchantments recargada correctamente.\"));\n        sender.sendMessage(reloadMessage);\n    }\n    \n    private void handleList(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"general.prefix\", \"&8[&bSwordEnchant&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Encantamientos Disponibles ===\");\n        \n        for (SwordEnchantment enchant : enchantmentManager.getAllEnchantments().values()) {\n            player.sendMessage(ChatColor.YELLOW + \"‚Ä¢ \" + ChatColor.WHITE + enchant.getDisplayName() + \n                ChatColor.GRAY + \" - \" + enchant.getLoreText());\n        }\n        \n        player.sendMessage(ChatColor.GRAY + \"Uso: /swordenchant <tipo>\");\n    }\n    \n    private void sendHelp(Player player) {\n        String prefix = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"general.prefix\", \"&8[&bSwordEnchant&8] \"));\n        \n        player.sendMessage(prefix + ChatColor.GOLD + \"=== Comandos de Sword Enchantments ===\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant dash\" + ChatColor.GRAY + \" - Aplicar encantamiento Dash\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant iceaspect\" + ChatColor.GRAY + \" - Aplicar encantamiento Ice Aspect\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant sharpness\" + ChatColor.GRAY + \" - Aplicar encantamiento Sharpness+\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant lifesteal\" + ChatColor.GRAY + \" - Aplicar encantamiento Lifesteal\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant vampire\" + ChatColor.GRAY + \" - Aplicar encantamiento Vampire\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant bleeding\" + ChatColor.GRAY + \" - Aplicar encantamiento Bleeding\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant explosive\" + ChatColor.GRAY + \" - Aplicar encantamiento Explosive\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant executioner\" + ChatColor.GRAY + \" - Aplicar encantamiento Executioner\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant list\" + ChatColor.GRAY + \" - Ver encantamientos disponibles\");\n        player.sendMessage(ChatColor.YELLOW + \"/swordenchant reload\" + ChatColor.GRAY + \" - Recargar configuraci√≥n\");\n        player.sendMessage(ChatColor.GRAY + \"Necesitas tener una espada en la mano para aplicar encantamientos.\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (!sender.hasPermission(\"hysercore.swordenchant\")) {\n            return completions;\n        }\n        \n        if (args.length == 1) {\n            String[] subCommands = {\"dash\", \"iceaspect\", \"ice_aspect\", \"sharpness\", \"lifesteal\", \"vampire\", \"bleeding\", \"explosive\", \"executioner\", \"list\", \"help\"};\n            \n            // Agregar reload si tiene permisos de admin\n            if (sender.hasPermission(\"hysercore.admin\")) {\n                List<String> allCommands = new ArrayList<>(Arrays.asList(subCommands));\n                allCommands.add(\"reload\");\n                subCommands = allCommands.toArray(new String[0]);\n            }\n            \n            for (String subCommand : subCommands) {\n                if (subCommand.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(subCommand);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":7453},"src/main/java/com/hyser/hysercore/enchantments/listeners/AntiAutoArmorListener.java":{"content":"package com.hyser.hysercore.enchantments.listeners;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.GameMode;\nimport org.bukkit.Material;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.inventory.InventoryClickEvent;\nimport org.bukkit.event.player.PlayerArmorStandManipulateEvent;\nimport org.bukkit.inventory.ItemStack;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class AntiAutoArmorListener implements Listener {\n    \n    private FileConfiguration config;\n    private Map<UUID, ArmorChangeTracker> playerTrackers;\n    \n    public AntiAutoArmorListener(FileConfiguration config) {\n        this.config = config;\n        this.playerTrackers = new HashMap<>();\n    }\n    \n    @EventHandler\n    public void onInventoryClick(InventoryClickEvent event) {\n        if (!config.getBoolean(\"anti-autoarmor.enabled\", true)) {\n            return;\n        }\n        \n        if (!(event.getWhoClicked() instanceof Player)) {\n            return;\n        }\n        \n        Player player = (Player) event.getWhoClicked();\n        \n        // Ignorar en modo creativo si est√° configurado\n        if (config.getBoolean(\"anti-autoarmor.ignore-creative\", true) && \n            player.getGameMode() == GameMode.CREATIVE) {\n            return;\n        }\n        \n        // Verificar si es un slot de armadura\n        if (!isArmorSlot(event.getSlot())) {\n            return;\n        }\n        \n        ItemStack clickedItem = event.getCurrentItem();\n        ItemStack cursorItem = event.getCursor();\n        \n        // Verificar si se est√° equipando armadura\n        if (isArmorPiece(clickedItem) || isArmorPiece(cursorItem)) {\n            trackArmorChange(player);\n        }\n    }\n    \n    private boolean isArmorSlot(int slot) {\n        // Slots de armadura en el inventario del jugador (1.8.8)\n        return slot >= 36 && slot <= 39; // Slots 36-39 son helmet, chestplate, leggings, boots\n    }\n    \n    private boolean isArmorPiece(ItemStack item) {\n        if (item == null || item.getType() == Material.AIR) {\n            return false;\n        }\n        \n        String typeName = item.getType().name();\n        return typeName.contains(\"HELMET\") || \n               typeName.contains(\"CHESTPLATE\") || \n               typeName.contains(\"LEGGINGS\") || \n               typeName.contains(\"BOOTS\") ||\n               typeName.contains(\"_HELMET\") ||\n               typeName.contains(\"_CHESTPLATE\") ||\n               typeName.contains(\"_LEGGINGS\") ||\n               typeName.contains(\"_BOOTS\");\n    }\n    \n    private void trackArmorChange(Player player) {\n        UUID playerId = player.getUniqueId();\n        ArmorChangeTracker tracker = playerTrackers.get(playerId);\n        \n        if (tracker == null) {\n            tracker = new ArmorChangeTracker();\n            playerTrackers.put(playerId, tracker);\n        }\n        \n        long currentTime = System.currentTimeMillis();\n        long timeWindow = config.getLong(\"anti-autoarmor.time-window-ms\", 200);\n        long rapidThreshold = config.getLong(\"anti-autoarmor.rapid-change-threshold\", 150);\n        int maxEquips = config.getInt(\"anti-autoarmor.max-equips-per-window\", 3);\n        \n        // Limpiar cambios antiguos\n        tracker.cleanOldChanges(currentTime, timeWindow);\n        \n        // Agregar nuevo cambio\n        tracker.addChange(currentTime);\n        \n        // Verificar si hay demasiados cambios en la ventana de tiempo\n        if (tracker.getChangeCount() > maxEquips) {\n            handleAutoArmorDetection(player, tracker);\n            return;\n        }\n        \n        // NUEVO: Verificar cambios extremadamente r√°pidos\n        if (tracker.getChangeCount() >= 2) {\n            long lastChangeTime = tracker.getLastChangeTime();\n            if (currentTime - lastChangeTime < rapidThreshold) {\n                handleAutoArmorDetection(player, tracker);\n                return;\n            }\n        }\n        \n        // NUEVO: Verificar patrones sospechosos (mismo tipo de armadura repetidamente)\n        if (config.getBoolean(\"anti-autoarmor.ignore-same-armor\", true)) {\n            // Esta l√≥gica se puede expandir para rastrear qu√© tipo de armadura se est√° equipando\n        }\n    }\n    \n    private void handleAutoArmorDetection(Player player, ArmorChangeTracker tracker) {\n        boolean kickPlayer = config.getBoolean(\"anti-autoarmor.kick-player\", true);\n        \n        if (kickPlayer) {\n            String kickMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"anti-autoarmor.kick-message\", \"&cHas sido expulsado por usar AutoArmor\"));\n            player.kickPlayer(kickMessage);\n        } else {\n            String warningMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"anti-autoarmor.warning-message\", \"&cAdvertencia: No uses AutoArmor en este servidor\"));\n            player.sendMessage(warningMessage);\n        }\n        \n        // Limpiar tracker despu√©s de la detecci√≥n\n        tracker.reset();\n    }\n    \n    // Clase interna para rastrear cambios de armadura\n    private static class ArmorChangeTracker {\n        private java.util.List<Long> changeTimes;\n        \n        public ArmorChangeTracker() {\n            this.changeTimes = new java.util.ArrayList<>();\n        }\n        \n        public void addChange(long time) {\n            changeTimes.add(time);\n        }\n        \n        public void cleanOldChanges(long currentTime, long timeWindow) {\n            changeTimes.removeIf(time -> currentTime - time > timeWindow);\n        }\n        \n        public int getChangeCount() {\n            return changeTimes.size();\n        }\n        \n        public long getLastChangeTime() {\n            if (changeTimes.isEmpty()) {\n                return 0;\n            }\n            return changeTimes.get(changeTimes.size() - 1);\n        }\n        \n        public void reset() {\n            changeTimes.clear();\n        }\n    }\n}","size_bytes":6067},"src/main/java/com/hyser/hysercore/enchantments/listeners/EnchantmentBookListener.java":{"content":"package com.hyser.hysercore.enchantments.listeners;\n\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerInteractEvent;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.util.List;\n\npublic class EnchantmentBookListener implements Listener {\n    \n    private SwordEnchantmentManager enchantmentManager;\n    \n    public EnchantmentBookListener(SwordEnchantmentManager enchantmentManager) {\n        this.enchantmentManager = enchantmentManager;\n    }\n    \n    @EventHandler\n    public void onPlayerInteract(PlayerInteractEvent event) {\n        if (!enchantmentManager.getConfig().getBoolean(\"advanced.enable-book-effects\", true)) {\n            return;\n        }\n        \n        Player player = event.getPlayer();\n        ItemStack item = player.getItemInHand();\n        \n        // Verificar si es un libro de encantamiento\n        if (!isEnchantmentBook(item)) {\n            return;\n        }\n        \n        // Verificar si el jugador tiene una espada en el inventario\n        ItemStack sword = findSwordInInventory(player);\n        if (sword == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"book-messages.need-sword-for-book\", \n                \"&cNecesitas tener una espada para aplicar este libro de encantamiento.\"));\n            player.sendMessage(message);\n            event.setCancelled(true);\n            return;\n        }\n        \n        // Obtener el tipo de encantamiento del libro\n        String enchantmentType = getEnchantmentFromBook(item);\n        if (enchantmentType == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"book-messages.invalid-book\", \n                \"&cEste no es un libro de encantamiento v√°lido.\"));\n            player.sendMessage(message);\n            event.setCancelled(true);\n            return;\n        }\n        \n        SwordEnchantment enchantment = enchantmentManager.getEnchantment(enchantmentType);\n        if (enchantment == null) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"book-messages.invalid-book\", \n                \"&cEste no es un libro de encantamiento v√°lido.\"));\n            player.sendMessage(message);\n            event.setCancelled(true);\n            return;\n        }\n        \n        // Verificar si la espada ya tiene el encantamiento\n        if (hasEnchantment(sword, enchantment)) {\n            String message = ChatColor.translateAlternateColorCodes('&', \n                enchantmentManager.getConfig().getString(\"book-messages.sword-already-has-enchant\", \n                \"&cEsta espada ya tiene el encantamiento &f{enchant}&c.\")\n                .replace(\"{enchant}\", enchantment.getDisplayName()));\n            player.sendMessage(message);\n            event.setCancelled(true);\n            return;\n        }\n        \n        // Verificar tasa de √©xito\n        double successRate = enchantmentManager.getConfig().getDouble(\"advanced.book-success-rate\", 1.0);\n        if (Math.random() > successRate) {\n            player.sendMessage(ChatColor.RED + \"¬°El libro fall√≥ al aplicar el encantamiento!\");\n            consumeBook(player, item);\n            event.setCancelled(true);\n            return;\n        }\n        \n        // Aplicar el encantamiento a la espada\n        addEnchantmentToSword(sword, enchantment);\n        \n        // Mensaje de √©xito\n        String successMessage = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"book-messages.book-applied\", \n            \"&a¬°Encantamiento &f{enchant} &aaplicado desde el libro!\")\n            .replace(\"{enchant}\", enchantment.getDisplayName()));\n        player.sendMessage(successMessage);\n        \n        // Consumir el libro\n        consumeBook(player, item);\n        \n        String consumedMessage = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"book-messages.book-consumed\", \n            \"&7El libro de encantamiento ha sido consumido.\"));\n        player.sendMessage(consumedMessage);\n        \n        event.setCancelled(true);\n    }\n    \n    private boolean isEnchantmentBook(ItemStack item) {\n        if (item == null || item.getType() != Material.BOOK) {\n            return false;\n        }\n        \n        if (!item.hasItemMeta() || !item.getItemMeta().hasDisplayName()) {\n            return false;\n        }\n        \n        String displayName = ChatColor.stripColor(item.getItemMeta().getDisplayName());\n        return displayName.contains(\"Libro de\") && displayName.contains(\"Encantamiento\");\n    }\n    \n    private ItemStack findSwordInInventory(Player player) {\n        // Primero verificar la mano\n        ItemStack mainHand = player.getItemInHand();\n        if (isSword(mainHand)) {\n            return mainHand;\n        }\n        \n        // Luego verificar el inventario\n        for (ItemStack item : player.getInventory().getContents()) {\n            if (isSword(item)) {\n                return item;\n            }\n        }\n        \n        return null;\n    }\n    \n    private boolean isSword(ItemStack item) {\n        if (item == null || item.getType() == Material.AIR) {\n            return false;\n        }\n        \n        Material type = item.getType();\n        return type == Material.WOOD_SWORD || \n               type == Material.STONE_SWORD || \n               type == Material.IRON_SWORD || \n               type == Material.GOLD_SWORD || \n               type == Material.DIAMOND_SWORD ||\n               type.toString().contains(\"SWORD\");\n    }\n    \n    private String getEnchantmentFromBook(ItemStack book) {\n        if (!book.hasItemMeta() || !book.getItemMeta().hasLore()) {\n            return null;\n        }\n        \n        List<String> lore = book.getItemMeta().getLore();\n        for (String line : lore) {\n            String cleanLine = ChatColor.stripColor(line).toLowerCase();\n            if (cleanLine.contains(\"‚ö°\")) {\n                // Extraer el nombre del encantamiento del lore\n                if (cleanLine.contains(\"dash\")) return \"dash\";\n                if (cleanLine.contains(\"ice aspect\")) return \"ice_aspect\";\n                if (cleanLine.contains(\"sharpness\")) return \"sharpness\";\n                if (cleanLine.contains(\"lifesteal\")) return \"lifesteal\";\n                if (cleanLine.contains(\"vampire\")) return \"vampire\";\n                if (cleanLine.contains(\"bleeding\")) return \"bleeding\";\n                if (cleanLine.contains(\"explosive\")) return \"explosive\";\n                if (cleanLine.contains(\"executioner\")) return \"executioner\";\n            }\n        }\n        \n        return null;\n    }\n    \n    private boolean hasEnchantment(ItemStack sword, SwordEnchantment enchantment) {\n        if (!sword.hasItemMeta() || !sword.getItemMeta().hasLore()) {\n            return false;\n        }\n        \n        List<String> lore = sword.getItemMeta().getLore();\n        String enchantLore = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"lore-format\", \"&b‚ö° {enchant}\")\n            .replace(\"{enchant}\", enchantment.getLoreText()));\n        \n        for (String line : lore) {\n            if (ChatColor.stripColor(line).equals(ChatColor.stripColor(enchantLore))) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void addEnchantmentToSword(ItemStack sword, SwordEnchantment enchantment) {\n        ItemMeta meta = sword.getItemMeta();\n        if (meta == null) {\n            meta = sword.getItemMeta();\n        }\n        \n        List<String> lore = meta.hasLore() ? meta.getLore() : new java.util.ArrayList<>();\n        \n        String enchantLore = ChatColor.translateAlternateColorCodes('&', \n            enchantmentManager.getConfig().getString(\"lore-format\", \"&b‚ö° {enchant}\")\n            .replace(\"{enchant}\", enchantment.getLoreText()));\n        lore.add(enchantLore);\n        \n        meta.setLore(lore);\n        sword.setItemMeta(meta);\n    }\n    \n    private void consumeBook(Player player, ItemStack book) {\n        if (book.getAmount() > 1) {\n            book.setAmount(book.getAmount() - 1);\n        } else {\n            player.setItemInHand(new ItemStack(Material.AIR));\n        }\n    }\n}","size_bytes":8708},"src/main/java/com/hyser/hysercore/enchantments/listeners/SwordEnchantmentListener.java":{"content":"package com.hyser.hysercore.enchantments.listeners;\n\nimport com.hyser.hysercore.enchantments.managers.SwordEnchantmentManager;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\nimport com.hyser.hysercore.enchantments.types.DashEnchantment;\nimport com.hyser.hysercore.enchantments.types.SharpnessEnchantment;\nimport com.hyser.hysercore.enchantments.types.ExecutionerEnchantment;\n\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.entity.EntityDamageByEntityEvent;\nimport org.bukkit.event.player.PlayerInteractEvent;\nimport org.bukkit.inventory.ItemStack;\n\nimport java.util.List;\n\npublic class SwordEnchantmentListener implements Listener {\n    \n    private SwordEnchantmentManager enchantmentManager;\n    \n    public SwordEnchantmentListener(SwordEnchantmentManager enchantmentManager) {\n        this.enchantmentManager = enchantmentManager;\n    }\n    \n    @EventHandler\n    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {\n        if (!(event.getDamager() instanceof Player) || !(event.getEntity() instanceof Player)) {\n            return;\n        }\n        \n        Player attacker = (Player) event.getDamager();\n        Player target = (Player) event.getEntity();\n        ItemStack weapon = attacker.getItemInHand();\n        \n        List<SwordEnchantment> enchantments = enchantmentManager.getEnchantsOnSword(weapon);\n        if (enchantments.isEmpty()) {\n            return;\n        }\n        \n        // Aplicar efectos de encantamientos\n        for (SwordEnchantment enchant : enchantments) {\n            enchant.onAttack(attacker, target);\n            \n            // Manejar encantamientos especiales que modifican da√±o\n            if (enchant instanceof SharpnessEnchantment) {\n                SharpnessEnchantment sharpness = (SharpnessEnchantment) enchant;\n                double bonus = sharpness.getBonusDamage();\n                event.setDamage(event.getDamage() + bonus);\n            } else if (enchant instanceof ExecutionerEnchantment) {\n                ExecutionerEnchantment executioner = (ExecutionerEnchantment) enchant;\n                if (executioner.shouldActivate(target)) {\n                    double multiplier = executioner.getBonusMultiplier();\n                    event.setDamage(event.getDamage() * multiplier);\n                }\n            }\n        }\n    }\n    \n    @EventHandler\n    public void onPlayerInteract(PlayerInteractEvent event) {\n        Player player = event.getPlayer();\n        ItemStack item = player.getItemInHand();\n        \n        List<SwordEnchantment> enchantments = enchantmentManager.getEnchantsOnSword(item);\n        \n        for (SwordEnchantment enchant : enchantments) {\n            if (enchant instanceof DashEnchantment && \n                (event.getAction().name().contains(\"RIGHT_CLICK\")) &&\n                player.isSneaking()) { // Requiere SHIFT + CLICK DERECHO\n                DashEnchantment dash = (DashEnchantment) enchant;\n                dash.activateDash(player);\n                event.setCancelled(true);\n                break;\n            }\n        }\n    }\n}","size_bytes":3151},"src/main/java/com/hyser/hysercore/enchantments/managers/SwordEnchantmentManager.java":{"content":"package com.hyser.hysercore.enchantments.managers;\n\nimport com.hyser.hysercore.HyserCore;\nimport com.hyser.hysercore.enchantments.types.DashEnchantment;\nimport com.hyser.hysercore.enchantments.types.IceAspectEnchantment;\nimport com.hyser.hysercore.enchantments.types.SwordEnchantment;\nimport com.hyser.hysercore.enchantments.types.SharpnessEnchantment;\nimport com.hyser.hysercore.enchantments.types.LifestealEnchantment;\nimport com.hyser.hysercore.enchantments.types.VampireEnchantment;\nimport com.hyser.hysercore.enchantments.types.BleedingEnchantment;\nimport com.hyser.hysercore.enchantments.types.ExplosiveEnchantment;\nimport com.hyser.hysercore.enchantments.types.ExecutionerEnchantment;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SwordEnchantmentManager {\n    \n    private HyserCore plugin;\n    private FileConfiguration config;\n    private Map<String, SwordEnchantment> enchantments;\n    \n    public SwordEnchantmentManager(HyserCore plugin) {\n        this.plugin = plugin;\n        this.enchantments = new HashMap<>();\n        loadConfig();\n        registerEnchantments();\n    }\n    \n    public void loadConfig() {\n        File configFile = new File(plugin.getDataFolder(), \"swordenchants.yml\");\n        if (!configFile.exists()) {\n            plugin.saveResource(\"swordenchants.yml\", false);\n        }\n        config = YamlConfiguration.loadConfiguration(configFile);\n    }\n    \n    public void reloadConfig() {\n        loadConfig();\n        enchantments.clear();\n        registerEnchantments();\n        plugin.getLogger().info(\"Configuraci√≥n de Sword Enchantments recargada\");\n    }\n    \n    private void registerEnchantments() {\n        // Registrar Dash\n        if (config.getBoolean(\"enchantments.dash.enabled\", true)) {\n            DashEnchantment dash = new DashEnchantment(config);\n            enchantments.put(\"dash\", dash);\n        }\n        \n        // Registrar Ice Aspect\n        if (config.getBoolean(\"enchantments.ice-aspect.enabled\", true)) {\n            IceAspectEnchantment iceAspect = new IceAspectEnchantment(config, plugin);\n            enchantments.put(\"ice_aspect\", iceAspect);\n        }\n        \n        // Registrar Sharpness+\n        if (config.getBoolean(\"enchantments.sharpness.enabled\", true)) {\n            SharpnessEnchantment sharpness = new SharpnessEnchantment(config);\n            enchantments.put(\"sharpness\", sharpness);\n        }\n        \n        // Registrar Lifesteal\n        if (config.getBoolean(\"enchantments.lifesteal.enabled\", true)) {\n            LifestealEnchantment lifesteal = new LifestealEnchantment(config);\n            enchantments.put(\"lifesteal\", lifesteal);\n        }\n        \n        // Registrar Vampire\n        if (config.getBoolean(\"enchantments.vampire.enabled\", true)) {\n            VampireEnchantment vampire = new VampireEnchantment(config);\n            enchantments.put(\"vampire\", vampire);\n        }\n        \n        // Registrar Bleeding\n        if (config.getBoolean(\"enchantments.bleeding.enabled\", true)) {\n            BleedingEnchantment bleeding = new BleedingEnchantment(config, plugin);\n            enchantments.put(\"bleeding\", bleeding);\n        }\n        \n        // Registrar Explosive\n        if (config.getBoolean(\"enchantments.explosive.enabled\", true)) {\n            ExplosiveEnchantment explosive = new ExplosiveEnchantment(config);\n            enchantments.put(\"explosive\", explosive);\n        }\n        \n        // Registrar Executioner\n        if (config.getBoolean(\"enchantments.executioner.enabled\", true)) {\n            ExecutionerEnchantment executioner = new ExecutionerEnchantment(config);\n            enchantments.put(\"executioner\", executioner);\n        }\n        \n        plugin.getLogger().info(\"Registrados \" + enchantments.size() + \" encantamientos de espada\");\n    }\n    \n    public boolean applySwordEnchantment(Player player, String enchantmentName) {\n        ItemStack item = player.getItemInHand();\n        \n        // Verificar que tenga una espada\n        if (!isSword(item)) {\n            String noSwordMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.no-sword\", \"&cDebes tener una espada en la mano.\"));\n            player.sendMessage(noSwordMessage);\n            return false;\n        }\n        \n        // Verificar que el encantamiento existe\n        SwordEnchantment enchantment = enchantments.get(enchantmentName.toLowerCase());\n        if (enchantment == null) {\n            String unknownEnchantMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.unknown-enchantment\", \"&cEncantamiento desconocido: {enchant}\")\n                .replace(\"{enchant}\", enchantmentName));\n            player.sendMessage(unknownEnchantMessage);\n            return false;\n        }\n        \n        // Verificar que no tenga ya el encantamiento\n        if (hasEnchantment(item, enchantment)) {\n            String alreadyHasMessage = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"messages.already-has-enchantment\", \"&cEsta espada ya tiene el encantamiento {enchant}.\")\n                .replace(\"{enchant}\", enchantment.getDisplayName()));\n            player.sendMessage(alreadyHasMessage);\n            return false;\n        }\n        \n        // Aplicar encantamiento\n        addEnchantmentToSword(item, enchantment);\n        \n        String successMessage = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"messages.enchantment-applied\", \"&aEncantamiento {enchant} aplicado exitosamente!\")\n            .replace(\"{enchant}\", enchantment.getDisplayName()));\n        player.sendMessage(successMessage);\n        \n        return true;\n    }\n    \n    private boolean isSword(ItemStack item) {\n        if (item == null || item.getType() == Material.AIR) {\n            return false;\n        }\n        \n        Material type = item.getType();\n        return type == Material.WOOD_SWORD || \n               type == Material.STONE_SWORD || \n               type == Material.IRON_SWORD || \n               type == Material.GOLD_SWORD || \n               type == Material.DIAMOND_SWORD ||\n               type.toString().contains(\"SWORD\");\n    }\n    \n    private boolean hasEnchantment(ItemStack item, SwordEnchantment enchantment) {\n        if (!item.hasItemMeta()) {\n            return false;\n        }\n        \n        ItemMeta meta = item.getItemMeta();\n        if (!meta.hasLore()) {\n            return false;\n        }\n        \n        List<String> lore = meta.getLore();\n        String enchantLore = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lore-format\", \"&b{enchant}\").replace(\"{enchant}\", enchantment.getLoreText()));\n        \n        for (String line : lore) {\n            if (ChatColor.stripColor(line).equals(ChatColor.stripColor(enchantLore))) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private void addEnchantmentToSword(ItemStack item, SwordEnchantment enchantment) {\n        ItemMeta meta = item.getItemMeta();\n        if (meta == null) {\n            meta = item.getItemMeta(); // Crear meta si no existe\n        }\n        \n        List<String> lore = meta.hasLore() ? new ArrayList<>(meta.getLore()) : new ArrayList<>();\n        \n        String enchantLore = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"lore-format\", \"&b{enchant}\").replace(\"{enchant}\", enchantment.getLoreText()));\n        lore.add(enchantLore);\n        \n        meta.setLore(lore);\n        item.setItemMeta(meta);\n    }\n    \n    public SwordEnchantment getEnchantment(String name) {\n        return enchantments.get(name.toLowerCase());\n    }\n    \n    public List<SwordEnchantment> getEnchantsOnSword(ItemStack sword) {\n        List<SwordEnchantment> foundEnchants = new ArrayList<>();\n        \n        if (!isSword(sword) || !sword.hasItemMeta() || !sword.getItemMeta().hasLore()) {\n            return foundEnchants;\n        }\n        \n        List<String> lore = sword.getItemMeta().getLore();\n        \n        for (SwordEnchantment enchant : enchantments.values()) {\n            String enchantLore = ChatColor.translateAlternateColorCodes('&', \n                config.getString(\"lore-format\", \"&b{enchant}\").replace(\"{enchant}\", enchant.getLoreText()));\n            \n            for (String line : lore) {\n                if (ChatColor.stripColor(line).equals(ChatColor.stripColor(enchantLore))) {\n                    foundEnchants.add(enchant);\n                    break;\n                }\n            }\n        }\n        \n        return foundEnchants;\n    }\n    \n    public Map<String, SwordEnchantment> getAllEnchantments() {\n        return new HashMap<>(enchantments);\n    }\n    \n    public FileConfiguration getConfig() {\n        return config;\n    }\n}","size_bytes":9177},"src/main/java/com/hyser/hysercore/enchantments/types/BleedingEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class BleedingEnchantment extends SwordEnchantment {\n    \n    private FileConfiguration config;\n    private Plugin plugin;\n    \n    public BleedingEnchantment(FileConfiguration config, Plugin plugin) {\n        super(\"bleeding\", \"Bleeding\", \"Sangrado\");\n        this.config = config;\n        this.plugin = plugin;\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        double chance = config.getDouble(\"enchantments.bleeding.activation-chance\", 0.18);\n        if (ThreadLocalRandom.current().nextDouble() > chance) {\n            return;\n        }\n        \n        int duration = config.getInt(\"enchantments.bleeding.duration-seconds\", 6);\n        double damagePerTick = config.getDouble(\"enchantments.bleeding.damage-per-tick\", 0.5);\n        int tickInterval = config.getInt(\"enchantments.bleeding.tick-interval\", 20);\n        \n        new BukkitRunnable() {\n            int ticks = 0;\n            int maxTicks = duration;\n            \n            @Override\n            public void run() {\n                if (ticks >= maxTicks || !target.isOnline()) {\n                    cancel();\n                    return;\n                }\n                \n                target.damage(damagePerTick);\n                ticks++;\n            }\n        }.runTaskTimer(plugin, tickInterval, tickInterval);\n    }\n}","size_bytes":1605},"src/main/java/com/hyser/hysercore/enchantments/types/DashEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.ChatColor;\nimport org.bukkit.Sound;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.util.Vector;\n\npublic class DashEnchantment extends SwordEnchantment {\n    \n    private FileConfiguration config;\n    \n    public DashEnchantment(FileConfiguration config) {\n        super(\"dash\", \"Dash\", \"Impulso a√©reo\");\n        this.config = config;\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        // Dash se activa con click derecho, no en ataque\n    }\n    \n    public void activateDash(Player player) {\n        if (isOnCooldown(player)) {\n            int remaining = getRemainingCooldown(player);\n            String cooldownMessage = ChatColor.translateAlternateColorCodes('&',\n                config.getString(\"messages.dash-cooldown\", \"&cDash en cooldown. Espera &f{time} &csegundos.\")\n                .replace(\"{time}\", String.valueOf(remaining)));\n            player.sendMessage(cooldownMessage);\n            return;\n        }\n        \n        double forwardForce = config.getDouble(\"enchantments.dash.forward-force\", 1.8);\n        double upwardForce = config.getDouble(\"enchantments.dash.upward-force\", 1.2);\n        int cooldown = config.getInt(\"enchantments.dash.cooldown-seconds\", 15);\n        \n        Vector direction = player.getLocation().getDirection().normalize();\n        direction.multiply(forwardForce);\n        direction.setY(upwardForce);\n        \n        player.setVelocity(direction);\n        setCooldown(player, cooldown);\n        \n        if (config.getBoolean(\"enchantments.dash.play-sound\", true)) {\n            try {\n                String soundName = config.getString(\"enchantments.dash.sound\", \"ENDERDRAGON_WINGS\");\n                Sound sound = Sound.valueOf(soundName);\n                player.getWorld().playSound(player.getLocation(), sound, 1.0f, 1.0f);\n            } catch (Exception e) {\n                player.getWorld().playSound(player.getLocation(), Sound.ENDERDRAGON_WINGS, 1.0f, 1.0f);\n            }\n        }\n        \n        String activatedMessage = ChatColor.translateAlternateColorCodes('&',\n            config.getString(\"messages.dash-activated\", \"&b‚ö° &aDash activado!\"));\n        player.sendMessage(activatedMessage);\n    }\n}","size_bytes":2332},"src/main/java/com/hyser/hysercore/enchantments/types/ExecutionerEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\n\npublic class ExecutionerEnchantment extends SwordEnchantment {\n    \n    private FileConfiguration config;\n    \n    public ExecutionerEnchantment(FileConfiguration config) {\n        super(\"executioner\", \"Executioner\", \"M√°s da√±o a heridos\");\n        this.config = config;\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        // El da√±o se maneja en el listener de da√±o\n    }\n    \n    public boolean shouldActivate(Player target) {\n        double threshold = config.getDouble(\"enchantments.executioner.health-threshold\", 0.30);\n        double healthPercentage = target.getHealth() / target.getMaxHealth();\n        return healthPercentage <= threshold;\n    }\n    \n    public double getBonusMultiplier() {\n        return config.getDouble(\"enchantments.executioner.bonus-multiplier\", 1.5);\n    }\n}","size_bytes":973},"src/main/java/com/hyser/hysercore/enchantments/types/ExplosiveEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.util.Vector;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ExplosiveEnchantment extends SwordEnchantment {\n    \n    private FileConfiguration config;\n    \n    public ExplosiveEnchantment(FileConfiguration config) {\n        super(\"explosive\", \"Explosive\", \"Knockback explosivo\");\n        this.config = config;\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        double chance = config.getDouble(\"enchantments.explosive.activation-chance\", 0.12);\n        if (ThreadLocalRandom.current().nextDouble() > chance) {\n            return;\n        }\n        \n        double knockbackForce = config.getDouble(\"enchantments.explosive.knockback-force\", 1.8);\n        \n        Vector direction = target.getLocation().subtract(attacker.getLocation()).toVector().normalize();\n        direction.multiply(knockbackForce);\n        direction.setY(0.5);\n        \n        target.setVelocity(direction);\n        \n        if (config.getBoolean(\"enchantments.explosive.play-effect\", true)) {\n            target.getWorld().createExplosion(target.getLocation(), 0.0f, false);\n        }\n    }\n}","size_bytes":1278},"src/main/java/com/hyser/hysercore/enchantments/types/IceAspectEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.Sound;\nimport org.bukkit.block.Block;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class IceAspectEnchantment extends SwordEnchantment {\n    \n    private Plugin plugin;\n    private FileConfiguration config;\n    private List<Location> iceBlocks;\n    \n    public IceAspectEnchantment(FileConfiguration config, Plugin plugin) {\n        super(\"ice_aspect\", \"Ice Aspect\", \"Efectos de hielo\");\n        this.config = config;\n        this.plugin = plugin;\n        this.iceBlocks = new ArrayList<>();\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        double chance = config.getDouble(\"enchantments.ice-aspect.activation-chance\", 0.15);\n        \n        if (ThreadLocalRandom.current().nextDouble() > chance) {\n            return;\n        }\n        \n        // Cooldown check\n        if (isOnCooldown(attacker)) {\n            return;\n        }\n        \n        setCooldown(attacker, config.getInt(\"enchantments.ice-aspect.cooldown-seconds\", 3));\n        \n        String mode = config.getString(\"enchantments.ice-aspect.mode\", \"both\");\n        \n        // Aplicar efectos de estado\n        if (mode.equals(\"effects\") || mode.equals(\"both\")) {\n            applyStatusEffects(target);\n        }\n        \n        // Crear jaula de hielo MEJORADA\n        if (mode.equals(\"cage\") || mode.equals(\"both\")) {\n            createImprovedIceCage(target);\n        }\n        \n        // Sonido\n        if (config.getBoolean(\"enchantments.ice-aspect.play-sound\", true)) {\n            String soundName = config.getString(\"enchantments.ice-aspect.sound\", \"GLASS\");\n            try {\n                Sound sound = Sound.valueOf(soundName);\n                target.getWorld().playSound(target.getLocation(), sound, 1.0f, 1.0f);\n            } catch (Exception e) {\n                // Sonido de respaldo para 1.8\n                target.getWorld().playSound(target.getLocation(), Sound.GLASS, 1.0f, 1.0f);\n            }\n        }\n        \n        // Mensaje al atacante\n        String message = config.getString(\"messages.ice-aspect-cage\", \"&b‚ùÑ &f{target} &aha sido encerrado en una celda de hielo!\")\n            .replace(\"{target}\", target.getName());\n        attacker.sendMessage(org.bukkit.ChatColor.translateAlternateColorCodes('&', message));\n        \n        // Mensaje al objetivo\n        String targetMessage = config.getString(\"messages.ice-aspect-target\", \"&c‚ùÑ ¬°Has sido afectado por Ice Aspect!\");\n        target.sendMessage(org.bukkit.ChatColor.translateAlternateColorCodes('&', targetMessage));\n    }\n    \n    private void applyStatusEffects(Player target) {\n        List<String> effects = config.getStringList(\"enchantments.ice-aspect.status-effects\");\n        int duration = config.getInt(\"enchantments.ice-aspect.effect-duration-seconds\", 5) * 20; // Convertir a ticks\n        int amplifier = config.getInt(\"enchantments.ice-aspect.effect-amplifier\", 1);\n        \n        for (String effectName : effects) {\n            try {\n                PotionEffectType effectType = PotionEffectType.getByName(effectName);\n                if (effectType != null) {\n                    // Manejar efectos especiales para 1.8.8\n                    if (effectName.equals(\"JUMP\")) {\n                        // En 1.8, JUMP reduce el salto con amplificador negativo\n                        effectType = PotionEffectType.JUMP;\n                        amplifier = -amplifier; // Amplificador negativo para reducir salto\n                    }\n                    \n                    target.addPotionEffect(new PotionEffect(effectType, duration, amplifier));\n                }\n            } catch (Exception e) {\n                plugin.getLogger().warning(\"Error al aplicar efecto \" + effectName + \": \" + e.getMessage());\n            }\n        }\n    }\n    \n    private void createImprovedIceCage(Player target) {\n        Location center = target.getLocation().getBlock().getLocation();\n        int radius = config.getInt(\"enchantments.ice-aspect.igloo-radius\", 3);\n        int height = config.getInt(\"enchantments.ice-aspect.igloo-height\", 4);\n        int duration = config.getInt(\"enchantments.ice-aspect.cage-duration-seconds\", 6);\n        \n        Material tempMaterial;\n        try {\n            tempMaterial = Material.valueOf(config.getString(\"enchantments.ice-aspect.ice-material\", \"PACKED_ICE\"));\n        } catch (Exception e) {\n            tempMaterial = Material.ICE; // Respaldo para 1.8\n        }\n        final Material iceMaterial = tempMaterial;\n        \n        List<Location> blocksToPlace = new ArrayList<>();\n        final List<Location> originalBlocks = new ArrayList<>();\n        \n        // Crear igl√∫ realista con forma de domo redondeado\n        for (int x = -radius; x <= radius; x++) {\n            for (int y = -1; y <= height; y++) {\n                for (int z = -radius; z <= radius; z++) {\n                    \n                    // Calcular distancia desde el centro (horizontal y 3D)\n                    double horizontalDistance = Math.sqrt(x * x + z * z);\n                    double totalDistance = Math.sqrt(x * x + y * y + z * z);\n                    \n                    // Crear forma de igl√∫ con algoritmo realista\n                    boolean shouldPlace = false;\n                    \n                    if (y == -1) {\n                        // Base del igl√∫: anillo exterior (sin centro)\n                        if (horizontalDistance <= radius && horizontalDistance >= radius - 0.8) {\n                            shouldPlace = true;\n                        }\n                    } else if (y == 0) {\n                        // Nivel del suelo: paredes completas del igl√∫\n                        if (horizontalDistance <= radius && horizontalDistance >= radius - 1.2) {\n                            shouldPlace = true;\n                        }\n                    } else {\n                        // Paredes y techo curvado del igl√∫\n                        // Usar f√≥rmula de domo: altura m√°xima decrece con distancia\n                        double maxHeightAtDistance = height * (1.0 - (horizontalDistance / (radius + 0.5)));\n                        \n                        if (horizontalDistance <= radius && y <= maxHeightAtDistance) {\n                            // Crear c√°scara del domo (hueco por dentro)\n                            double innerRadius = radius - 1.0;\n                            double innerMaxHeight = height * (1.0 - (horizontalDistance / (innerRadius + 0.5)));\n                            \n                            // Solo colocar en la c√°scara exterior\n                            if (horizontalDistance >= innerRadius || y >= innerMaxHeight) {\n                                shouldPlace = true;\n                            }\n                        }\n                    }\n                    \n                    if (shouldPlace) {\n                        Location blockLoc = center.clone().add(x, y, z);\n                        Block block = blockLoc.getBlock();\n                        \n                        // CR√çTICO: Solo colocar en espacios de aire vac√≠os, NO reemplazar NADA\n                        if (block.getType() == Material.AIR) {\n                            \n                            originalBlocks.add(blockLoc.clone());\n                            blocksToPlace.add(blockLoc.clone());\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Colocar bloques de hielo\n        for (Location loc : blocksToPlace) {\n            loc.getBlock().setType(iceMaterial);\n            iceBlocks.add(loc);\n        }\n        \n        // Programar destrucci√≥n autom√°tica\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                destroyIceCage(originalBlocks, iceMaterial);\n            }\n        }.runTaskLater(plugin, duration * 20L);\n    }\n    \n    private void destroyIceCage(List<Location> blocks, final Material iceMaterial) {\n        for (Location loc : blocks) {\n            if (loc.getBlock().getType() == iceMaterial) {\n                loc.getBlock().setType(Material.AIR);\n                iceBlocks.remove(loc);\n                \n                // Sonido de destrucci√≥n\n                if (config.getBoolean(\"enchantments.ice-aspect.play-destruction-sound\", true)) {\n                    try {\n                        loc.getWorld().playSound(loc, Sound.GLASS, 0.5f, 2.0f);\n                    } catch (Exception e) {\n                        // Sonido de respaldo\n                        loc.getWorld().playSound(loc, Sound.FIZZ, 0.5f, 1.0f);\n                    }\n                }\n            }\n        }\n    }\n    \n    // M√©todo para limpiar bloques de hielo al descargar el plugin\n    public void cleanupIceBlocks() {\n        for (Location loc : iceBlocks) {\n            try {\n                if (loc.getBlock().getType().name().contains(\"ICE\")) {\n                    loc.getBlock().setType(Material.AIR);\n                }\n            } catch (Exception e) {\n                // Ignorar errores de bloques no cargados\n            }\n        }\n        iceBlocks.clear();\n    }\n}","size_bytes":9554},"src/main/java/com/hyser/hysercore/enchantments/types/LifestealEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class LifestealEnchantment extends SwordEnchantment {\n    \n    private FileConfiguration config;\n    \n    public LifestealEnchantment(FileConfiguration config) {\n        super(\"lifesteal\", \"Lifesteal\", \"Roba vida\");\n        this.config = config;\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        double chance = config.getDouble(\"enchantments.lifesteal.activation-chance\", 0.25);\n        if (ThreadLocalRandom.current().nextDouble() > chance) {\n            return;\n        }\n        \n        double healPercentage = config.getDouble(\"enchantments.lifesteal.heal-percentage\", 0.25);\n        double damage = 2.0; // Da√±o base estimado, se puede obtener del evento\n        double healAmount = damage * healPercentage;\n        \n        double currentHealth = attacker.getHealth();\n        double maxHealth = attacker.getMaxHealth();\n        double newHealth = Math.min(currentHealth + healAmount, maxHealth);\n        \n        attacker.setHealth(newHealth);\n    }\n}","size_bytes":1197},"src/main/java/com/hyser/hysercore/enchantments/types/SharpnessEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.entity.EntityDamageByEntityEvent;\n\npublic class SharpnessEnchantment extends SwordEnchantment {\n    \n    private FileConfiguration config;\n    \n    public SharpnessEnchantment(FileConfiguration config) {\n        super(\"sharpness\", \"Sharpness+\", \"Da√±o aumentado\");\n        this.config = config;\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        // El da√±o se maneja en el listener de da√±o\n    }\n    \n    public double getBonusDamage() {\n        return config.getDouble(\"enchantments.sharpness.bonus-damage\", 1.5);\n    }\n}","size_bytes":727},"src/main/java/com/hyser/hysercore/enchantments/types/SwordEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.entity.Player;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic abstract class SwordEnchantment {\n    \n    protected String name;\n    protected String displayName;\n    protected String loreText;\n    private Map<UUID, Long> cooldowns;\n    \n    public SwordEnchantment(String name, String displayName, String loreText) {\n        this.name = name;\n        this.displayName = displayName;\n        this.loreText = loreText;\n        this.cooldowns = new HashMap<>();\n    }\n    \n    public abstract void onAttack(Player attacker, Player target);\n    \n    public String getName() {\n        return name;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public String getLoreText() {\n        return loreText;\n    }\n    \n    protected boolean isOnCooldown(Player player) {\n        UUID playerId = player.getUniqueId();\n        if (!cooldowns.containsKey(playerId)) {\n            return false;\n        }\n        \n        long cooldownEnd = cooldowns.get(playerId);\n        return System.currentTimeMillis() < cooldownEnd;\n    }\n    \n    protected void setCooldown(Player player, int seconds) {\n        UUID playerId = player.getUniqueId();\n        long cooldownEnd = System.currentTimeMillis() + (seconds * 1000L);\n        cooldowns.put(playerId, cooldownEnd);\n    }\n    \n    protected int getRemainingCooldown(Player player) {\n        UUID playerId = player.getUniqueId();\n        if (!cooldowns.containsKey(playerId)) {\n            return 0;\n        }\n        \n        long cooldownEnd = cooldowns.get(playerId);\n        long remaining = cooldownEnd - System.currentTimeMillis();\n        return remaining > 0 ? (int) (remaining / 1000) : 0;\n    }\n}","size_bytes":1778},"src/main/java/com/hyser/hysercore/enchantments/types/VampireEnchantment.java":{"content":"package com.hyser.hysercore.enchantments.types;\n\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class VampireEnchantment extends SwordEnchantment {\n    \n    private FileConfiguration config;\n    \n    public VampireEnchantment(FileConfiguration config) {\n        super(\"vampire\", \"Vampire\", \"Regeneraci√≥n\");\n        this.config = config;\n    }\n    \n    @Override\n    public void onAttack(Player attacker, Player target) {\n        double chance = config.getDouble(\"enchantments.vampire.activation-chance\", 0.20);\n        if (ThreadLocalRandom.current().nextDouble() > chance) {\n            return;\n        }\n        \n        int duration = config.getInt(\"enchantments.vampire.regen-duration-seconds\", 4) * 20;\n        int amplifier = config.getInt(\"enchantments.vampire.regen-amplifier\", 1);\n        \n        attacker.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION, duration, amplifier));\n    }\n}","size_bytes":1091},"src/main/java/com/hyser/hysercore/abilities/AbilityAction.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic abstract class AbilityAction {\n    protected String type;\n    protected ConfigurationSection config;\n    \n    public AbilityAction(String type, ConfigurationSection config) {\n        this.type = type;\n        this.config = config;\n    }\n    \n    public abstract void execute(Player player);\n    \n    public String getType() {\n        return type;\n    }\n}","size_bytes":489},"src/main/java/com/hyser/hysercore/abilities/AbilityCommand.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport com.hyser.hysercore.HyserCore;\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.command.Command;\nimport org.bukkit.command.CommandExecutor;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.TabCompleter;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class AbilityCommand implements CommandExecutor, TabCompleter {\n    private final HyserCore plugin;\n    private final AbilityManager abilityManager;\n    \n    public AbilityCommand(HyserCore plugin, AbilityManager abilityManager) {\n        this.plugin = plugin;\n        this.abilityManager = abilityManager;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        String prefix = abilityManager.getPrefix();\n        \n        if (args.length == 0) {\n            sender.sendMessage(prefix + ChatColor.YELLOW + \"Comandos de Objetos de Abilities:\");\n            sender.sendMessage(ChatColor.GRAY + \"  /abilities list - Listar todos los objetos\");\n            sender.sendMessage(ChatColor.GRAY + \"  /abilities info <objeto> - Informaci√≥n de un objeto\");\n            sender.sendMessage(ChatColor.GRAY + \"  /abilities give <jugador> <objeto> - Dar objeto a jugador\");\n            sender.sendMessage(ChatColor.GRAY + \"  /abilities reload - Recargar configuraci√≥n\");\n            return true;\n        }\n        \n        String subcommand = args[0].toLowerCase();\n        \n        switch (subcommand) {\n            case \"list\":\n                return handleListCommand(sender, prefix);\n                \n            case \"info\":\n                if (args.length < 2) {\n                    sender.sendMessage(prefix + ChatColor.RED + \"Uso: /abilities info <ability>\");\n                    return true;\n                }\n                return handleInfoCommand(sender, args[1], prefix);\n                \n            case \"reload\":\n                return handleReloadCommand(sender, prefix);\n                \n            case \"give\":\n                if (args.length < 3) {\n                    sender.sendMessage(prefix + ChatColor.RED + \"Uso: /abilities give <jugador> <objeto>\");\n                    return true;\n                }\n                return handleGiveCommand(sender, args[1], args[2], prefix);\n                \n            default:\n                sender.sendMessage(prefix + ChatColor.RED + \"Subcomando desconocido: \" + subcommand);\n                return true;\n        }\n    }\n    \n    private boolean handleListCommand(CommandSender sender, String prefix) {\n        if (abilityManager.getAbilities().isEmpty()) {\n            sender.sendMessage(prefix + ChatColor.YELLOW + \"No hay objetos de ability cargados.\");\n            return true;\n        }\n        \n        sender.sendMessage(prefix + ChatColor.YELLOW + \"Objetos de Ability disponibles:\");\n        \n        for (Ability ability : abilityManager.getAbilities().values()) {\n            String status = ability.isEnabled() ? \n                ChatColor.GREEN + \"‚úì\" : ChatColor.RED + \"‚úó\";\n            \n            sender.sendMessage(ChatColor.GRAY + \"  \" + status + \" \" + \n                ChatColor.WHITE + ability.getId() + \n                ChatColor.GRAY + \" - \" + ability.getName());\n        }\n        \n        return true;\n    }\n    \n    private boolean handleInfoCommand(CommandSender sender, String abilityId, String prefix) {\n        Ability ability = abilityManager.getAbility(abilityId);\n        \n        if (ability == null) {\n            sender.sendMessage(prefix + ChatColor.RED + \"Ability '\" + abilityId + \"' no encontrada.\");\n            return true;\n        }\n        \n        sender.sendMessage(prefix + ChatColor.YELLOW + \"Informaci√≥n de: \" + ability.getName());\n        sender.sendMessage(ChatColor.GRAY + \"ID: \" + ChatColor.WHITE + ability.getId());\n        List<String> descriptions = ability.getDescription();\n        if (descriptions != null && !descriptions.isEmpty()) {\n            sender.sendMessage(ChatColor.GRAY + \"Descripci√≥n:\");\n            for (String desc : descriptions) {\n                sender.sendMessage(ChatColor.GRAY + \"  \" + ChatColor.WHITE + desc);\n            }\n        }\n        sender.sendMessage(ChatColor.GRAY + \"Permiso: \" + ChatColor.WHITE + ability.getPermission());\n        sender.sendMessage(ChatColor.GRAY + \"Cooldown: \" + ChatColor.WHITE + ability.getCooldown() + \"s\");\n        sender.sendMessage(ChatColor.GRAY + \"Estado: \" + \n            (ability.isEnabled() ? ChatColor.GREEN + \"Activa\" : ChatColor.RED + \"Desactivada\"));\n        \n        if (ability.getTriggers() != null && !ability.getTriggers().isEmpty()) {\n            sender.sendMessage(ChatColor.GRAY + \"Triggers: \" + ChatColor.WHITE + ability.getTriggers().size());\n        }\n        \n        if (ability.getActions() != null && !ability.getActions().isEmpty()) {\n            sender.sendMessage(ChatColor.GRAY + \"Acciones: \" + ChatColor.WHITE + ability.getActions().size());\n        }\n        \n        return true;\n    }\n    \n    private boolean handleReloadCommand(CommandSender sender, String prefix) {\n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            sender.sendMessage(prefix + ChatColor.RED + \"No tienes permisos para recargar abilities.\");\n            return true;\n        }\n        \n        try {\n            abilityManager.reload();\n            sender.sendMessage(prefix + ChatColor.GREEN + \"Sistema de abilities recargado exitosamente.\");\n            sender.sendMessage(prefix + ChatColor.GRAY + \"Abilities cargadas: \" + \n                abilityManager.getAbilities().size());\n        } catch (Exception e) {\n            sender.sendMessage(prefix + ChatColor.RED + \"Error al recargar abilities: \" + e.getMessage());\n        }\n        \n        return true;\n    }\n    \n    private boolean handleGiveCommand(CommandSender sender, String playerName, String abilityId, String prefix) {\n        if (!sender.hasPermission(\"hysercore.admin\")) {\n            sender.sendMessage(prefix + ChatColor.RED + \"No tienes permisos para dar objetos de ability.\");\n            return true;\n        }\n        \n        Player target = Bukkit.getPlayer(playerName);\n        if (target == null) {\n            sender.sendMessage(prefix + ChatColor.RED + \"Jugador '\" + playerName + \"' no encontrado.\");\n            return true;\n        }\n        \n        ItemStack abilityItem = abilityManager.getItemManager().createAbilityItem(abilityId);\n        if (abilityItem == null) {\n            sender.sendMessage(prefix + ChatColor.RED + \"Objeto de ability '\" + abilityId + \"' no encontrado.\");\n            return true;\n        }\n        \n        target.getInventory().addItem(abilityItem);\n        sender.sendMessage(prefix + ChatColor.GREEN + \"Objeto '\" + abilityId + \"' entregado a \" + target.getName());\n        target.sendMessage(prefix + ChatColor.GREEN + \"Has recibido un objeto especial: \" + abilityItem.getItemMeta().getDisplayName());\n        \n        return true;\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        List<String> completions = new ArrayList<>();\n        \n        if (args.length == 1) {\n            List<String> subcommands = Arrays.asList(\"list\", \"info\", \"reload\");\n            for (String sub : subcommands) {\n                if (sub.toLowerCase().startsWith(args[0].toLowerCase())) {\n                    completions.add(sub);\n                }\n            }\n        } else if (args.length == 2 && \"info\".equalsIgnoreCase(args[0])) {\n            for (String abilityId : abilityManager.getAbilities().keySet()) {\n                if (abilityId.toLowerCase().startsWith(args[1].toLowerCase())) {\n                    completions.add(abilityId);\n                }\n            }\n        }\n        \n        return completions;\n    }\n}","size_bytes":7941},"src/main/java/com/hyser/hysercore/abilities/AbilityCondition.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic abstract class AbilityCondition {\n    protected String type;\n    protected ConfigurationSection config;\n    \n    public AbilityCondition(String type, ConfigurationSection config) {\n        this.type = type;\n        this.config = config;\n    }\n    \n    public abstract boolean check(Player player);\n    \n    public String getType() {\n        return type;\n    }\n    \n    protected int getInt(String key, int defaultValue) {\n        return config.getInt(key, defaultValue);\n    }\n    \n    protected double getDouble(String key, double defaultValue) {\n        return config.getDouble(key, defaultValue);\n    }\n    \n    protected String getString(String key, String defaultValue) {\n        return config.getString(key, defaultValue);\n    }\n    \n    protected boolean getBoolean(String key, boolean defaultValue) {\n        return config.getBoolean(key, defaultValue);\n    }\n}","size_bytes":1004},"src/main/java/com/hyser/hysercore/abilities/AbilityListener.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.EventPriority;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.entity.EntityDamageByEntityEvent;\nimport org.bukkit.event.player.PlayerInteractEvent;\nimport org.bukkit.event.player.PlayerToggleSneakEvent;\nimport org.bukkit.event.player.PlayerItemConsumeEvent;\n\npublic class AbilityListener implements Listener {\n    private final AbilityManager abilityManager;\n    \n    public AbilityListener(AbilityManager abilityManager) {\n        this.abilityManager = abilityManager;\n    }\n    \n    @EventHandler(priority = EventPriority.NORMAL)\n    public void onPlayerInteract(PlayerInteractEvent event) {\n        if (!abilityManager.isEnabled()) return;\n        \n        Player player = event.getPlayer();\n        abilityManager.handleEvent(event, player);\n    }\n    \n    @EventHandler(priority = EventPriority.NORMAL)\n    public void onPlayerSneak(PlayerToggleSneakEvent event) {\n        if (!abilityManager.isEnabled()) return;\n        \n        Player player = event.getPlayer();\n        abilityManager.handleEvent(event, player);\n    }\n    \n    @EventHandler(priority = EventPriority.NORMAL)\n    public void onEntityDamage(EntityDamageByEntityEvent event) {\n        if (!abilityManager.isEnabled()) return;\n        \n        // Para el jugador que ataca\n        if (event.getDamager() instanceof Player) {\n            Player attacker = (Player) event.getDamager();\n            abilityManager.handleEvent(event, attacker);\n        }\n        \n        // Para el jugador que recibe da√±o\n        if (event.getEntity() instanceof Player) {\n            Player victim = (Player) event.getEntity();\n            abilityManager.handleEvent(event, victim);\n        }\n    }\n    \n    @EventHandler(priority = EventPriority.NORMAL)\n    public void onPlayerConsume(PlayerItemConsumeEvent event) {\n        if (!abilityManager.isEnabled()) return;\n        \n        // Cancelar consumo de objetos de abilities para evitar que se coman\n        if (abilityManager.getItemManager() != null) {\n            if (event.getItem().hasItemMeta() && event.getItem().getItemMeta().hasLore()) {\n                for (String lore : event.getItem().getItemMeta().getLore()) {\n                    if (lore.contains(\"Usos restantes:\")) {\n                        event.setCancelled(true);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}","size_bytes":2493},"src/main/java/com/hyser/hysercore/abilities/AbilityTrigger.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\nimport org.bukkit.inventory.EquipmentSlot;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic abstract class AbilityTrigger {\n    protected String type;\n    protected ConfigurationSection config;\n    \n    public AbilityTrigger(String type, ConfigurationSection config) {\n        this.type = type;\n        this.config = config;\n    }\n    \n    public abstract boolean matches(Event event, Player player);\n    \n    public String getType() {\n        return type;\n    }\n    \n    protected Material getMaterial(String key) {\n        String materialName = config.getString(key);\n        if (materialName != null) {\n            try {\n                return Material.valueOf(materialName.toUpperCase());\n            } catch (IllegalArgumentException e) {\n                return null;\n            }\n        }\n        return null;\n    }\n    \n    protected boolean isOffHand(String key) {\n        String handName = config.getString(key);\n        return \"OFF_HAND\".equalsIgnoreCase(handName);\n    }\n}","size_bytes":1130},"src/main/java/com/hyser/hysercore/abilities/ItemAbilityManager.java":{"content":"package com.hyser.hysercore.abilities;\n\nimport com.hyser.hysercore.HyserCore;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ItemAbilityManager {\n    private final HyserCore plugin;\n    private final AbilityManager abilityManager;\n    \n    public ItemAbilityManager(HyserCore plugin, AbilityManager abilityManager) {\n        this.plugin = plugin;\n        this.abilityManager = abilityManager;\n    }\n    \n    public ItemStack createAbilityItem(String abilityId) {\n        Ability ability = abilityManager.getAbility(abilityId);\n        if (ability == null) return null;\n        \n        // Obtener configuraci√≥n del item desde el archivo ability.yml\n        FileConfiguration abilityConfig = abilityManager.getAbilityConfigFile();\n        ConfigurationSection config = abilityConfig.getConfigurationSection(\"ability-items.\" + abilityId);\n        if (config == null) return null;\n        \n        // Obtener configuraci√≥n del item\n        String materialName = config.getString(\"item.material\", \"STICK\");\n        Material material;\n        try {\n            material = Material.valueOf(materialName.toUpperCase());\n        } catch (IllegalArgumentException e) {\n            material = Material.STICK;\n        }\n        \n        int data = config.getInt(\"item.data\", 0);\n        int maxUses = config.getInt(\"uses\", 1);\n        \n        // Crear item\n        ItemStack item = new ItemStack(material, 1, (short) data);\n        ItemMeta meta = item.getItemMeta();\n        \n        // Configurar nombre\n        meta.setDisplayName(ChatColor.translateAlternateColorCodes('&', ability.getName()));\n        \n        // Configurar lore (description + usos)\n        List<String> lore = new ArrayList<>();\n        \n        // Agregar descripci√≥n\n        List<String> descriptions = ability.getDescription();\n        if (descriptions != null) {\n            for (String desc : descriptions) {\n                lore.add(ChatColor.translateAlternateColorCodes('&', desc));\n            }\n        }\n        \n        // Agregar informaci√≥n de usos\n        lore.add(\"\");\n        lore.add(ChatColor.GRAY + \"Usos restantes: \" + ChatColor.WHITE + maxUses + \"/\" + maxUses);\n        lore.add(ChatColor.GRAY + \"Cooldown: \" + ChatColor.WHITE + ability.getCooldown() + \"s\");\n        lore.add(\"\");\n        lore.add(ChatColor.YELLOW + \"Click derecho para usar\");\n        \n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        \n        return item;\n    }\n    \n    public boolean useAbilityItem(Player player, ItemStack item, String abilityId) {\n        if (item == null || !item.hasItemMeta()) {\n            return false;\n        }\n        \n        // CORREGIDO: Trabajar directamente con el item en la mano del jugador\n        ItemStack itemInHand = player.getItemInHand();\n        if (itemInHand == null || !itemInHand.hasItemMeta()) {\n            return false;\n        }\n        \n        // Verificar que sea el mismo item\n        if (!itemInHand.isSimilar(item) && !itemInHand.equals(item)) {\n            return false;\n        }\n        \n        ItemMeta meta = itemInHand.getItemMeta();\n        List<String> lore = meta.getLore();\n        \n        if (lore == null) return false;\n        \n        // Buscar l√≠nea de usos\n        int usesLineIndex = -1;\n        int currentUses = 0;\n        int maxUses = 0;\n        \n        for (int i = 0; i < lore.size(); i++) {\n            String line = ChatColor.stripColor(lore.get(i));\n            if (line.startsWith(\"Usos restantes:\")) {\n                usesLineIndex = i;\n                String[] parts = line.split(\" \");\n                if (parts.length >= 3) {\n                    String[] usesParts = parts[2].split(\"/\");\n                    if (usesParts.length >= 2) {\n                        try {\n                            currentUses = Integer.parseInt(usesParts[0]);\n                            maxUses = Integer.parseInt(usesParts[1]);\n                        } catch (NumberFormatException e) {\n                            return false;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        \n        if (usesLineIndex == -1 || currentUses <= 0) {\n            player.sendMessage(ChatColor.RED + \"¬°Este objeto no tiene m√°s usos!\");\n            return false;\n        }\n        \n        // Reducir usos\n        currentUses--;\n        \n        if (currentUses <= 0) {\n            // CORREGIDO: Remover espec√≠ficamente el item de la mano\n            player.setItemInHand(null);\n            player.sendMessage(ChatColor.GRAY + \"El objeto se ha gastado completamente.\");\n        } else {\n            // CORREGIDO: Actualizar el item directamente en la mano del jugador\n            lore.set(usesLineIndex, ChatColor.GRAY + \"Usos restantes: \" + \n                ChatColor.WHITE + currentUses + \"/\" + maxUses);\n            meta.setLore(lore);\n            itemInHand.setItemMeta(meta);\n            \n            // Actualizar visualmente el inventario\n            player.updateInventory();\n        }\n        \n        return true;\n    }\n    \n    public FileConfiguration getAbilityConfig() {\n        return abilityManager.getAbilityConfigFile();\n    }\n}","size_bytes":5455},"src/main/java/com/hyser/hysercore/abilities/actions/MessageAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.ChatColor;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class MessageAction extends AbilityAction {\n    private String message;\n    \n    public MessageAction(String type, ConfigurationSection config) {\n        super(type, config);\n        this.message = ChatColor.translateAlternateColorCodes('&', \n            config.getString(\"message\", \"&7Habilidad activada!\"));\n    }\n    \n    @Override\n    public void execute(Player player) {\n        player.sendMessage(message);\n    }\n}","size_bytes":644},"src/main/java/com/hyser/hysercore/abilities/actions/ParticleAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class ParticleAction extends AbilityAction {\n    private String particleName;\n    private int amount;\n    private double offsetX, offsetY, offsetZ;\n    \n    public ParticleAction(String type, ConfigurationSection config) {\n        super(type, config);\n        \n        this.particleName = config.getString(\"particle\", \"CLOUD\");\n        \n        this.amount = config.getInt(\"amount\", 10);\n        this.offsetX = config.getDouble(\"offset_x\", 0.5);\n        this.offsetY = config.getDouble(\"offset_y\", 0.5);\n        this.offsetZ = config.getDouble(\"offset_z\", 0.5);\n    }\n    \n    @Override\n    public void execute(Player player) {\n        // Implementaci√≥n para Spigot 1.8.8\n        if (particleName != null) {\n            try {\n                // En 1.8.8 se usa playEffect en lugar de spawnParticle\n                org.bukkit.Effect effect = getEffectFromName(particleName);\n                if (effect != null) {\n                    for (int i = 0; i < amount; i++) {\n                        double x = player.getLocation().getX() + (Math.random() - 0.5) * offsetX * 2;\n                        double y = player.getLocation().getY() + Math.random() * offsetY;\n                        double z = player.getLocation().getZ() + (Math.random() - 0.5) * offsetZ * 2;\n                        \n                        org.bukkit.Location particleLoc = new org.bukkit.Location(player.getWorld(), x, y, z);\n                        player.getWorld().playEffect(particleLoc, effect, 0);\n                    }\n                }\n            } catch (Exception e) {\n                // Fallback silencioso para part√≠culas no soportadas\n            }\n        }\n    }\n    \n    private org.bukkit.Effect getEffectFromName(String name) {\n        switch (name.toUpperCase()) {\n            case \"CLOUD\":\n            case \"EXPLOSION\":\n                return org.bukkit.Effect.CLOUD;\n            case \"SMOKE\":\n                return org.bukkit.Effect.SMOKE;\n            case \"FLAME\":\n            case \"FIRE\":\n                return org.bukkit.Effect.MOBSPAWNER_FLAMES;\n            case \"HEART\":\n                return org.bukkit.Effect.HEART;\n            case \"PORTAL\":\n                return org.bukkit.Effect.ENDER_SIGNAL;\n            case \"REDSTONE\":\n                return org.bukkit.Effect.POTION_BREAK;\n            default:\n                return org.bukkit.Effect.CLOUD;\n        }\n    }\n}","size_bytes":2568},"src/main/java/com/hyser/hysercore/abilities/actions/PotionEffectAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.entity.Player;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class PotionEffectAction extends AbilityAction {\n    private PotionEffectType effectType;\n    private int amplifier;\n    private int duration;\n    \n    public PotionEffectAction(String type, ConfigurationSection config) {\n        super(type, config);\n        \n        String effectName = config.getString(\"effect\", \"SPEED\");\n        try {\n            this.effectType = PotionEffectType.getByName(effectName.toUpperCase());\n        } catch (Exception e) {\n            this.effectType = PotionEffectType.SPEED;\n        }\n        \n        this.amplifier = config.getInt(\"amplifier\", 0);\n        this.duration = config.getInt(\"duration\", 200);\n    }\n    \n    @Override\n    public void execute(Player player) {\n        if (effectType != null) {\n            PotionEffect effect = new PotionEffect(effectType, duration, amplifier);\n            player.addPotionEffect(effect);\n        }\n    }\n}","size_bytes":1163},"src/main/java/com/hyser/hysercore/abilities/actions/SoundAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.Sound;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class SoundAction extends AbilityAction {\n    private Sound sound;\n    private float volume;\n    private float pitch;\n    \n    public SoundAction(String type, ConfigurationSection config) {\n        super(type, config);\n        \n        String soundName = config.getString(\"sound\", \"ENTITY_EXPERIENCE_ORB_PICKUP\");\n        try {\n            this.sound = Sound.valueOf(soundName.toUpperCase());\n        } catch (IllegalArgumentException e) {\n            try {\n                this.sound = Sound.ORB_PICKUP;\n            } catch (Exception ex) {\n                this.sound = null;\n            }\n        }\n        \n        this.volume = (float) config.getDouble(\"volume\", 1.0);\n        this.pitch = (float) config.getDouble(\"pitch\", 1.0);\n    }\n    \n    @Override\n    public void execute(Player player) {\n        if (sound != null) {\n            player.playSound(player.getLocation(), sound, volume, pitch);\n        }\n    }\n}","size_bytes":1140},"src/main/java/com/hyser/hysercore/abilities/triggers/ClickTrigger.java":{"content":"package com.hyser.hysercore.abilities.triggers;\n\nimport com.hyser.hysercore.abilities.AbilityTrigger;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.block.Action;\nimport org.bukkit.event.player.PlayerInteractEvent;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.inventory.meta.ItemMeta;\nimport java.util.List;\n\npublic class ClickTrigger extends AbilityTrigger {\n    private Action requiredAction;\n    private Material requiredItem;\n    private boolean requireOffHand;\n    private boolean requireShift;\n    \n    public ClickTrigger(String type, ConfigurationSection config) {\n        super(type, config);\n        \n        switch (type.toUpperCase()) {\n            case \"RIGHT_CLICK\":\n                this.requiredAction = Action.RIGHT_CLICK_AIR;\n                break;\n            case \"LEFT_CLICK\":\n                this.requiredAction = Action.LEFT_CLICK_AIR;\n                break;\n            case \"SHIFT_RIGHT_CLICK\":\n                this.requiredAction = Action.RIGHT_CLICK_AIR;\n                this.requireShift = true;\n                break;\n            case \"SHIFT_LEFT_CLICK\":\n                this.requiredAction = Action.LEFT_CLICK_AIR;\n                this.requireShift = true;\n                break;\n            case \"SHIFT_CLICK\":\n                this.requireShift = true;\n                break;\n        }\n        \n        this.requiredItem = getMaterial(\"item\");\n        this.requireOffHand = isOffHand(\"hand\");\n    }\n    \n    @Override\n    public boolean matches(Event event, Player player) {\n        if (!(event instanceof PlayerInteractEvent)) {\n            return false;\n        }\n        \n        PlayerInteractEvent interactEvent = (PlayerInteractEvent) event;\n        \n        if (requireShift && !player.isSneaking()) {\n            return false;\n        }\n        \n        if (requiredAction != null) {\n            Action action = interactEvent.getAction();\n            if (action != requiredAction && \n                !(action == Action.RIGHT_CLICK_BLOCK && requiredAction == Action.RIGHT_CLICK_AIR) &&\n                !(action == Action.LEFT_CLICK_BLOCK && requiredAction == Action.LEFT_CLICK_AIR)) {\n                return false;\n            }\n        }\n        \n        // CORREGIDO: Verificar que el objeto de ability est√© en mano\n        ItemStack itemInHand = player.getItemInHand();\n        if (!isAbilityItemInHand(itemInHand)) {\n            return false;\n        }\n        \n        if (requiredItem != null) {\n            ItemStack item = interactEvent.getItem();\n            if (item == null || item.getType() != requiredItem) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private boolean isAbilityItemInHand(ItemStack item) {\n        if (item == null || !item.hasItemMeta()) {\n            return false;\n        }\n        \n        ItemMeta meta = item.getItemMeta();\n        List<String> lore = meta.getLore();\n        \n        // Verificar si tiene el lore de ability\n        if (lore != null) {\n            for (String line : lore) {\n                if (line.contains(\"Usos restantes:\")) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n}","size_bytes":3326},"src/main/java/com/hyser/hysercore/abilities/triggers/CombatTrigger.java":{"content":"package com.hyser.hysercore.abilities.triggers;\n\nimport com.hyser.hysercore.abilities.AbilityTrigger;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.entity.EntityDamageByEntityEvent;\nimport org.bukkit.configuration.ConfigurationSection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class CombatTrigger extends AbilityTrigger {\n    private static Map<UUID, Map<UUID, Integer>> hitCounter = new HashMap<>();\n    private static Map<UUID, Map<UUID, Integer>> damageGiven = new HashMap<>();\n    private static Map<UUID, Map<UUID, Integer>> damageReceived = new HashMap<>();\n    \n    private String triggerMode;\n    private int requiredHits;\n    private double requiredDamage;\n    private String targetType; // \"any\", \"player\", \"mob\"\n    \n    public CombatTrigger(String type, ConfigurationSection config) {\n        super(type, config);\n        this.triggerMode = type.toLowerCase();\n        this.requiredHits = config.getInt(\"required_hits\", 1);\n        this.requiredDamage = config.getDouble(\"required_damage\", 0.0);\n        this.targetType = config.getString(\"target_type\", \"any\");\n    }\n    \n    @Override\n    public boolean matches(Event event, Player player) {\n        if (!(event instanceof EntityDamageByEntityEvent)) {\n            return false;\n        }\n        \n        // NUEVO: Solo procesar si el jugador tiene un objeto de ability en mano\n        if (!hasAbilityItemInHand(player)) {\n            return false;\n        }\n        \n        EntityDamageByEntityEvent damageEvent = (EntityDamageByEntityEvent) event;\n        Entity damager = damageEvent.getDamager();\n        Entity victim = damageEvent.getEntity();\n        double damage = damageEvent.getDamage();\n        \n        UUID playerId = player.getUniqueId();\n        \n        switch (triggerMode) {\n            case \"on_hit\": // Cuando el jugador pega a otro\n                if (damager instanceof Player && ((Player) damager).getUniqueId().equals(playerId)) {\n                    return checkHitTarget(playerId, victim, damage);\n                }\n                break;\n                \n            case \"on_receive_hit\": // Cuando le pegan al jugador\n                if (victim instanceof Player && ((Player) victim).getUniqueId().equals(playerId)) {\n                    return checkReceiveHit(playerId, damager, damage);\n                }\n                break;\n                \n            case \"hit_count\": // Cuando alcanza X golpes dados\n                if (damager instanceof Player && ((Player) damager).getUniqueId().equals(playerId)) {\n                    return checkHitCount(playerId, victim, damage);\n                }\n                break;\n                \n            case \"receive_count\": // Cuando recibe X golpes\n                if (victim instanceof Player && ((Player) victim).getUniqueId().equals(playerId)) {\n                    return checkReceiveCount(playerId, damager, damage);\n                }\n                break;\n        }\n        \n        return false;\n    }\n    \n    private boolean hasAbilityItemInHand(Player player) {\n        org.bukkit.inventory.ItemStack itemInHand = player.getItemInHand();\n        if (itemInHand == null || !itemInHand.hasItemMeta()) {\n            return false;\n        }\n        \n        org.bukkit.inventory.meta.ItemMeta meta = itemInHand.getItemMeta();\n        java.util.List<String> lore = meta.getLore();\n        \n        // Verificar si tiene el lore de ability\n        if (lore != null) {\n            for (String line : lore) {\n                if (line.contains(\"Usos restantes:\")) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean checkHitTarget(UUID playerId, Entity target, double damage) {\n        if (!isValidTarget(target)) return false;\n        \n        // Actualizar estad√≠sticas\n        updateHitStats(playerId, target, damage);\n        \n        return true;\n    }\n    \n    private boolean checkReceiveHit(UUID playerId, Entity attacker, double damage) {\n        if (!isValidTarget(attacker)) return false;\n        \n        // Actualizar estad√≠sticas de da√±o recibido\n        updateReceiveStats(playerId, attacker, damage);\n        \n        return true;\n    }\n    \n    private boolean checkHitCount(UUID playerId, Entity target, double damage) {\n        if (!isValidTarget(target)) return false;\n        \n        updateHitStats(playerId, target, damage);\n        \n        UUID targetId = target.getUniqueId();\n        int hits = hitCounter.computeIfAbsent(playerId, k -> new HashMap<>())\n                            .getOrDefault(targetId, 0);\n        \n        return hits >= requiredHits;\n    }\n    \n    private boolean checkReceiveCount(UUID playerId, Entity attacker, double damage) {\n        if (!isValidTarget(attacker)) return false;\n        \n        updateReceiveStats(playerId, attacker, damage);\n        \n        UUID attackerId = attacker.getUniqueId();\n        int hits = hitCounter.computeIfAbsent(attackerId, k -> new HashMap<>())\n                            .getOrDefault(playerId, 0);\n        \n        return hits >= requiredHits;\n    }\n    \n    private void updateHitStats(UUID playerId, Entity target, double damage) {\n        UUID targetId = target.getUniqueId();\n        \n        // Actualizar contador de golpes\n        hitCounter.computeIfAbsent(playerId, k -> new HashMap<>())\n                  .put(targetId, hitCounter.get(playerId).getOrDefault(targetId, 0) + 1);\n        \n        // Actualizar da√±o dado\n        damageGiven.computeIfAbsent(playerId, k -> new HashMap<>())\n                   .put(targetId, (int) (damageGiven.get(playerId).getOrDefault(targetId, 0) + damage));\n    }\n    \n    private void updateReceiveStats(UUID playerId, Entity attacker, double damage) {\n        UUID attackerId = attacker.getUniqueId();\n        \n        // Actualizar da√±o recibido\n        damageReceived.computeIfAbsent(playerId, k -> new HashMap<>())\n                      .put(attackerId, (int) (damageReceived.get(playerId).getOrDefault(attackerId, 0) + damage));\n    }\n    \n    private boolean isValidTarget(Entity entity) {\n        switch (targetType.toLowerCase()) {\n            case \"player\":\n                return entity instanceof Player;\n            case \"mob\":\n                return !(entity instanceof Player);\n            case \"any\":\n            default:\n                return true;\n        }\n    }\n    \n    // M√©todos est√°ticos para obtener estad√≠sticas\n    public static int getHitsGiven(UUID playerId, UUID targetId) {\n        return hitCounter.getOrDefault(playerId, new HashMap<>()).getOrDefault(targetId, 0);\n    }\n    \n    public static int getDamageGiven(UUID playerId, UUID targetId) {\n        return damageGiven.getOrDefault(playerId, new HashMap<>()).getOrDefault(targetId, 0);\n    }\n    \n    public static int getDamageReceived(UUID playerId, UUID attackerId) {\n        return damageReceived.getOrDefault(playerId, new HashMap<>()).getOrDefault(attackerId, 0);\n    }\n    \n    public static void resetStats(UUID playerId) {\n        hitCounter.remove(playerId);\n        damageGiven.remove(playerId);\n        damageReceived.remove(playerId);\n    }\n}","size_bytes":7235},"src/main/java/com/hyser/hysercore/abilities/triggers/DoubleShiftTrigger.java":{"content":"package com.hyser.hysercore.abilities.triggers;\n\nimport com.hyser.hysercore.abilities.AbilityTrigger;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.player.PlayerToggleSneakEvent;\nimport org.bukkit.configuration.ConfigurationSection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class DoubleShiftTrigger extends AbilityTrigger {\n    private static Map<UUID, Long> lastShiftTime = new HashMap<>();\n    private long maxInterval;\n    \n    public DoubleShiftTrigger(String type, ConfigurationSection config) {\n        super(type, config);\n        this.maxInterval = config.getLong(\"within\", 500);\n    }\n    \n    @Override\n    public boolean matches(Event event, Player player) {\n        if (!(event instanceof PlayerToggleSneakEvent)) {\n            return false;\n        }\n        \n        PlayerToggleSneakEvent sneakEvent = (PlayerToggleSneakEvent) event;\n        if (!sneakEvent.isSneaking()) {\n            return false;\n        }\n        \n        // NUEVO: Solo activar si tiene un objeto de ability en mano\n        if (!hasAbilityItemInHand(player)) {\n            return false;\n        }\n        \n        UUID playerId = player.getUniqueId();\n        long currentTime = System.currentTimeMillis();\n        \n        if (lastShiftTime.containsKey(playerId)) {\n            long timeDiff = currentTime - lastShiftTime.get(playerId);\n            if (timeDiff <= maxInterval) {\n                lastShiftTime.remove(playerId);\n                return true;\n            }\n        }\n        \n        lastShiftTime.put(playerId, currentTime);\n        return false;\n    }\n    \n    private boolean hasAbilityItemInHand(Player player) {\n        org.bukkit.inventory.ItemStack itemInHand = player.getItemInHand();\n        if (itemInHand == null || !itemInHand.hasItemMeta()) {\n            return false;\n        }\n        \n        org.bukkit.inventory.meta.ItemMeta meta = itemInHand.getItemMeta();\n        java.util.List<String> lore = meta.getLore();\n        \n        // Verificar si tiene el lore de ability\n        if (lore != null) {\n            for (String line : lore) {\n                if (line.contains(\"Usos restantes:\")) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n}","size_bytes":2307},"src/main/java/com/hyser/hysercore/abilities/triggers/ItemUseTrigger.java":{"content":"package com.hyser.hysercore.abilities.triggers;\n\nimport com.hyser.hysercore.abilities.AbilityTrigger;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.block.Action;\nimport org.bukkit.event.player.PlayerInteractEvent;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\nimport org.bukkit.configuration.ConfigurationSection;\nimport java.util.List;\n\npublic class ItemUseTrigger extends AbilityTrigger {\n    private boolean consumeUse;\n    \n    public ItemUseTrigger(String type, ConfigurationSection config) {\n        super(type, config);\n        this.consumeUse = config.getBoolean(\"consume_use\", true);\n    }\n    \n    @Override\n    public boolean matches(Event event, Player player) {\n        if (!(event instanceof PlayerInteractEvent)) {\n            return false;\n        }\n        \n        PlayerInteractEvent interactEvent = (PlayerInteractEvent) event;\n        Action action = interactEvent.getAction();\n        \n        // Solo activar en right click\n        if (action != Action.RIGHT_CLICK_AIR && action != Action.RIGHT_CLICK_BLOCK) {\n            return false;\n        }\n        \n        ItemStack item = interactEvent.getItem();\n        if (item == null) {\n            return false;\n        }\n        \n        // Verificar si es un objeto de ability v√°lido\n        return isAbilityItem(item);\n    }\n    \n    private boolean isAbilityItem(ItemStack item) {\n        if (item == null || !item.hasItemMeta()) {\n            return false;\n        }\n        \n        ItemMeta meta = item.getItemMeta();\n        List<String> lore = meta.getLore();\n        \n        // Verificar si tiene el lore de ability\n        if (lore != null) {\n            for (String line : lore) {\n                if (line.contains(\"Usos restantes:\")) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    public boolean shouldConsumeUse() {\n        return consumeUse;\n    }\n}","size_bytes":2018},"src/main/java/com/hyser/hysercore/abilities/actions/HealAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class HealAction extends AbilityAction {\n    private double amount;\n    private String target;\n    \n    public HealAction(String type, ConfigurationSection config) {\n        super(type, config);\n        this.amount = config.getDouble(\"amount\", 2.0);\n        this.target = config.getString(\"target\", \"SELF\");\n    }\n    \n    @Override\n    public void execute(Player player) {\n        if (\"SELF\".equals(target)) {\n            double currentHealth = player.getHealth();\n            double maxHealth = player.getMaxHealth();\n            double newHealth = Math.min(currentHealth + amount, maxHealth);\n            player.setHealth(newHealth);\n        }\n    }\n}","size_bytes":849},"src/main/java/com/hyser/hysercore/abilities/actions/HealRadiusAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class HealRadiusAction extends AbilityAction {\n    private double amount;\n    private double radius;\n    private String target;\n    \n    public HealRadiusAction(String type, ConfigurationSection config) {\n        super(type, config);\n        this.amount = config.getDouble(\"amount\", 2.0);\n        this.radius = config.getDouble(\"radius\", 5.0);\n        this.target = config.getString(\"target\", \"NEARBY_PLAYERS\");\n    }\n    \n    @Override\n    public void execute(Player player) {\n        if (\"NEARBY_PLAYERS\".equals(target)) {\n            for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {\n                if (entity instanceof Player) {\n                    Player target = (Player) entity;\n                    double currentHealth = target.getHealth();\n                    double maxHealth = target.getMaxHealth();\n                    double newHealth = Math.min(currentHealth + amount, maxHealth);\n                    target.setHealth(newHealth);\n                }\n            }\n        }\n    }\n}","size_bytes":1246},"src/main/java/com/hyser/hysercore/abilities/actions/TeleportAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.block.Block;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.util.Vector;\n\npublic class TeleportAction extends AbilityAction {\n    private String target;\n    private double maxDistance;\n    private boolean safe;\n    \n    public TeleportAction(String type, ConfigurationSection config) {\n        super(type, config);\n        this.target = config.getString(\"target\", \"LOOKING_AT\");\n        this.maxDistance = config.getDouble(\"max_distance\", 10.0);\n        this.safe = config.getBoolean(\"safe\", true);\n    }\n    \n    @Override\n    public void execute(Player player) {\n        if (\"LOOKING_AT\".equals(target)) {\n            Location targetLoc = getTargetLocation(player);\n            if (targetLoc != null && isValidTeleportLocation(targetLoc)) {\n                player.teleport(targetLoc);\n            }\n        }\n    }\n    \n    private Location getTargetLocation(Player player) {\n        Block targetBlock = player.getTargetBlock((java.util.Set<Material>) null, (int) maxDistance);\n        if (targetBlock == null || targetBlock.getType() == Material.AIR) {\n            // Si no hay bloque, usar raycast\n            Vector direction = player.getLocation().getDirection();\n            Location start = player.getEyeLocation();\n            Location target = start.clone().add(direction.multiply(maxDistance));\n            \n            // Buscar superficie s√≥lida hacia abajo\n            for (int y = target.getBlockY(); y > 0; y--) {\n                target.setY(y);\n                if (target.getBlock().getType() != Material.AIR) {\n                    target.setY(y + 1); // Posicionar encima del bloque\n                    return target;\n                }\n            }\n            return null;\n        }\n        \n        Location teleportLoc = targetBlock.getLocation().add(0, 1, 0);\n        return teleportLoc;\n    }\n    \n    private boolean isValidTeleportLocation(Location loc) {\n        if (!safe) return true;\n        \n        // Verificar que haya espacio para el jugador (2 bloques de altura)\n        Block block1 = loc.getBlock();\n        Block block2 = loc.clone().add(0, 1, 0).getBlock();\n        \n        return block1.getType() == Material.AIR && block2.getType() == Material.AIR;\n    }\n}","size_bytes":2432},"src/main/java/com/hyser/hysercore/abilities/actions/VelocityAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.util.Vector;\n\npublic class VelocityAction extends AbilityAction {\n    private String direction;\n    private double strength;\n    private double yVelocity;\n    \n    public VelocityAction(String type, ConfigurationSection config) {\n        super(type, config);\n        this.direction = config.getString(\"direction\", \"FORWARD\");\n        this.strength = config.getDouble(\"strength\", 1.0);\n        this.yVelocity = config.getDouble(\"y_velocity\", 0.2);\n    }\n    \n    @Override\n    public void execute(Player player) {\n        Vector velocity = null;\n        \n        switch (direction.toUpperCase()) {\n            case \"FORWARD\":\n                velocity = player.getLocation().getDirection().multiply(strength);\n                velocity.setY(yVelocity);\n                break;\n            case \"BACKWARD\":\n                velocity = player.getLocation().getDirection().multiply(-strength);\n                velocity.setY(yVelocity);\n                break;\n            case \"UP\":\n                velocity = new Vector(0, strength, 0);\n                break;\n            case \"RANDOM\":\n                velocity = new Vector(\n                    (Math.random() - 0.5) * strength,\n                    yVelocity,\n                    (Math.random() - 0.5) * strength\n                );\n                break;\n        }\n        \n        if (velocity != null) {\n            player.setVelocity(velocity);\n        }\n    }\n}","size_bytes":1613},"src/main/java/com/hyser/hysercore/abilities/conditions/HealthBelowCondition.java":{"content":"package com.hyser.hysercore.abilities.conditions;\n\nimport com.hyser.hysercore.abilities.AbilityCondition;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class HealthBelowCondition extends AbilityCondition {\n    private double value;\n    \n    public HealthBelowCondition(String type, ConfigurationSection config) {\n        super(type, config);\n        this.value = getDouble(\"value\", 10.0);\n    }\n    \n    @Override\n    public boolean check(Player player) {\n        return player.getHealth() < value;\n    }\n}","size_bytes":555},"src/main/java/com/hyser/hysercore/abilities/conditions/SafeLocationCondition.java":{"content":"package com.hyser.hysercore.abilities.conditions;\n\nimport com.hyser.hysercore.abilities.AbilityCondition;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\n\npublic class SafeLocationCondition extends AbilityCondition {\n    private boolean required;\n    \n    public SafeLocationCondition(String type, ConfigurationSection config) {\n        super(type, config);\n        this.required = getBoolean(\"value\", true);\n    }\n    \n    @Override\n    public boolean check(Player player) {\n        if (!required) return true;\n        \n        Location loc = player.getLocation();\n        // Verificar que el jugador no est√© en lava o fuego\n        Material blockType = loc.getBlock().getType();\n        Material belowType = loc.clone().add(0, -1, 0).getBlock().getType();\n        \n        return blockType != Material.LAVA && \n               blockType != Material.STATIONARY_LAVA &&\n               blockType != Material.FIRE &&\n               belowType != Material.LAVA &&\n               belowType != Material.STATIONARY_LAVA;\n    }\n}","size_bytes":1116},"src/main/java/com/hyser/hysercore/abilities/triggers/ComboTrigger.java":{"content":"package com.hyser.hysercore.abilities.triggers;\n\nimport com.hyser.hysercore.abilities.AbilityTrigger;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.entity.EntityDamageByEntityEvent;\nimport org.bukkit.configuration.ConfigurationSection;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class ComboTrigger extends AbilityTrigger {\n    private static final Map<UUID, Integer> hitCountGiven = new ConcurrentHashMap<>();\n    private static final Map<UUID, Integer> hitCountReceived = new ConcurrentHashMap<>();\n    private static final Map<UUID, Long> lastHitTime = new ConcurrentHashMap<>();\n    \n    private String comboType; // \"give\" o \"receive\"\n    private int requiredHits;\n    private long resetTime; // Tiempo en ms para resetear combo si no hay hits\n    \n    public ComboTrigger(String type, ConfigurationSection config) {\n        super(type, config);\n        this.comboType = type.toLowerCase().replace(\"combo_\", \"\");\n        this.requiredHits = config.getInt(\"required_hits\", 3);\n        this.resetTime = config.getLong(\"reset_time\", 5000); // 5 segundos por defecto\n    }\n    \n    @Override\n    public boolean matches(Event event, Player player) {\n        if (!(event instanceof EntityDamageByEntityEvent)) {\n            return false;\n        }\n        \n        EntityDamageByEntityEvent damageEvent = (EntityDamageByEntityEvent) event;\n        Entity damager = damageEvent.getDamager();\n        Entity victim = damageEvent.getEntity();\n        UUID playerId = player.getUniqueId();\n        long currentTime = System.currentTimeMillis();\n        \n        // NUEVO: Solo procesar si el jugador tiene un objeto de ability en mano\n        if (!hasAbilityItemInHand(player)) {\n            return false;\n        }\n        \n        // Verificar si el combo se resetea por tiempo\n        if (shouldResetCombo(playerId, currentTime)) {\n            resetCombo(playerId);\n        }\n        \n        boolean triggerActivated = false;\n        \n        switch (comboType) {\n            case \"give\":\n                // Cuando el jugador pega a otro\n                if (damager instanceof Player && ((Player) damager).getUniqueId().equals(playerId)) {\n                    int currentHits = hitCountGiven.getOrDefault(playerId, 0) + 1;\n                    hitCountGiven.put(playerId, currentHits);\n                    lastHitTime.put(playerId, currentTime);\n                    \n                    if (currentHits >= requiredHits) {\n                        // NUEVO: Solo activar si a√∫n tiene el objeto en mano\n                        if (hasAbilityItemInHand(player)) {\n                            triggerActivated = true;\n                        }\n                        resetCombo(playerId); // Resetear despu√©s de activar\n                    }\n                }\n                break;\n                \n            case \"receive\":\n                // Cuando le pegan al jugador\n                if (victim instanceof Player && ((Player) victim).getUniqueId().equals(playerId)) {\n                    int currentHits = hitCountReceived.getOrDefault(playerId, 0) + 1;\n                    hitCountReceived.put(playerId, currentHits);\n                    lastHitTime.put(playerId, currentTime);\n                    \n                    if (currentHits >= requiredHits) {\n                        // NUEVO: Solo activar si a√∫n tiene el objeto en mano\n                        if (hasAbilityItemInHand(player)) {\n                            triggerActivated = true;\n                        }\n                        resetCombo(playerId); // Resetear despu√©s de activar\n                    }\n                }\n                break;\n        }\n        \n        return triggerActivated;\n    }\n    \n    private boolean hasAbilityItemInHand(Player player) {\n        org.bukkit.inventory.ItemStack itemInHand = player.getItemInHand();\n        if (itemInHand == null || !itemInHand.hasItemMeta()) {\n            return false;\n        }\n        \n        org.bukkit.inventory.meta.ItemMeta meta = itemInHand.getItemMeta();\n        java.util.List<String> lore = meta.getLore();\n        \n        // Verificar si tiene el lore de ability\n        if (lore != null) {\n            for (String line : lore) {\n                if (line.contains(\"Usos restantes:\")) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean shouldResetCombo(UUID playerId, long currentTime) {\n        Long lastHit = lastHitTime.get(playerId);\n        return lastHit != null && (currentTime - lastHit) > resetTime;\n    }\n    \n    private void resetCombo(UUID playerId) {\n        hitCountGiven.remove(playerId);\n        hitCountReceived.remove(playerId);\n        lastHitTime.remove(playerId);\n    }\n    \n    // M√©todos p√∫blicos para obtener estado de combo (para mostrar en lore)\n    public static int getHitsGiven(UUID playerId) {\n        return hitCountGiven.getOrDefault(playerId, 0);\n    }\n    \n    public static int getHitsReceived(UUID playerId) {\n        return hitCountReceived.getOrDefault(playerId, 0);\n    }\n    \n    public static void clearPlayerData(UUID playerId) {\n        hitCountGiven.remove(playerId);\n        hitCountReceived.remove(playerId);\n        lastHitTime.remove(playerId);\n    }\n    \n    // Getters para configuraci√≥n\n    public String getComboType() {\n        return comboType;\n    }\n    \n    public int getRequiredHits() {\n        return requiredHits;\n    }\n}","size_bytes":5549},"src/main/java/com/hyser/hysercore/abilities/actions/EnergyChargeAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.ChatColor;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.scheduler.BukkitRunnable;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.Sound;\nimport org.bukkit.Effect;\n\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class EnergyChargeAction extends AbilityAction {\n    private static final Map<UUID, Integer> energyLevels = new ConcurrentHashMap<>();\n    private static final Map<UUID, BukkitRunnable> chargeTasks = new ConcurrentHashMap<>();\n    private static final Map<UUID, Long> chargeStartTime = new ConcurrentHashMap<>();\n    \n    private int maxEnergy;\n    private long chargeIntervalTicks;\n    private int energyPerInterval;\n    private Plugin plugin;\n    private boolean showProgress;\n    private String chargeMessage;\n    \n    public EnergyChargeAction(String type, ConfigurationSection config) {\n        super(type, config);\n        this.maxEnergy = config.getInt(\"max_energy\", 100);\n        this.chargeIntervalTicks = config.getLong(\"charge_interval_ticks\", 20L); // 1 segundo por defecto\n        this.energyPerInterval = config.getInt(\"energy_per_interval\", 10);\n        this.showProgress = config.getBoolean(\"show_progress\", true);\n        this.chargeMessage = config.getString(\"charge_message\", \"&e‚ö° Energ√≠a: &f{energy}/{max_energy} &e‚ö°\");\n    }\n    \n    public void setPlugin(Plugin plugin) {\n        this.plugin = plugin;\n    }\n    \n    @Override\n    public void execute(Player player) {\n        UUID playerId = player.getUniqueId();\n        \n        // Si ya est√° cargando, detener la tarea anterior\n        BukkitRunnable existingTask = chargeTasks.get(playerId);\n        if (existingTask != null) {\n            existingTask.cancel();\n            chargeTasks.remove(playerId);\n        }\n        \n        // Inicializar energ√≠a si no existe\n        energyLevels.putIfAbsent(playerId, 0);\n        chargeStartTime.put(playerId, System.currentTimeMillis());\n        \n        player.sendMessage(ChatColor.YELLOW + \"‚ö° ¬°Comenzando carga de energ√≠a! Mant√©n el objeto en mano...\");\n        \n        // Crear nueva tarea de carga\n        BukkitRunnable chargeTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                // Verificar que el jugador sigue en l√≠nea\n                if (!player.isOnline()) {\n                    chargeTasks.remove(playerId);\n                    energyLevels.remove(playerId);\n                    chargeStartTime.remove(playerId);\n                    cancel();\n                    return;\n                }\n                \n                // Verificar que el objeto sigue en mano\n                if (!hasAbilityItemInHand(player)) {\n                    player.sendMessage(ChatColor.RED + \"‚ö° Carga interrumpida: necesitas mantener el objeto en mano\");\n                    chargeTasks.remove(playerId);\n                    cancel();\n                    return;\n                }\n                \n                int currentEnergy = energyLevels.get(playerId);\n                \n                if (currentEnergy >= maxEnergy) {\n                    // Energ√≠a m√°xima alcanzada\n                    player.sendMessage(ChatColor.GREEN + \"‚ö° ¬°ENERG√çA M√ÅXIMA ALCANZADA! Usa doble shift para liberar\");\n                    player.playSound(player.getLocation(), Sound.LEVEL_UP, 1.0f, 1.0f);\n                    player.getWorld().playEffect(player.getLocation(), Effect.ENDER_SIGNAL, 0);\n                    chargeTasks.remove(playerId);\n                    cancel();\n                    return;\n                }\n                \n                // Incrementar energ√≠a\n                int newEnergy = Math.min(currentEnergy + energyPerInterval, maxEnergy);\n                energyLevels.put(playerId, newEnergy);\n                \n                // Mostrar progreso\n                if (showProgress && newEnergy % (energyPerInterval * 3) == 0) { // Cada 3 intervalos\n                    String message = ChatColor.translateAlternateColorCodes('&', \n                        chargeMessage.replace(\"{energy}\", String.valueOf(newEnergy))\n                                   .replace(\"{max_energy}\", String.valueOf(maxEnergy)));\n                    player.sendMessage(message);\n                    \n                    // Efectos visuales y sonoros\n                    player.playSound(player.getLocation(), Sound.FIREWORK_TWINKLE, 0.5f, 1.5f);\n                    player.getWorld().playEffect(player.getLocation().add(0, 1, 0), Effect.MOBSPAWNER_FLAMES, 0);\n                }\n            }\n        };\n        \n        chargeTasks.put(playerId, chargeTask);\n        chargeTask.runTaskTimer(plugin, chargeIntervalTicks, chargeIntervalTicks);\n    }\n    \n    private boolean hasAbilityItemInHand(Player player) {\n        org.bukkit.inventory.ItemStack itemInHand = player.getItemInHand();\n        if (itemInHand == null || !itemInHand.hasItemMeta()) {\n            return false;\n        }\n        \n        org.bukkit.inventory.meta.ItemMeta meta = itemInHand.getItemMeta();\n        java.util.List<String> lore = meta.getLore();\n        \n        if (lore != null) {\n            for (String line : lore) {\n                if (line.contains(\"Usos restantes:\")) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // M√©todos est√°ticos para acceder a la energ√≠a\n    public static int getEnergyLevel(UUID playerId) {\n        return energyLevels.getOrDefault(playerId, 0);\n    }\n    \n    public static boolean hasMaxEnergy(UUID playerId, int maxEnergy) {\n        return energyLevels.getOrDefault(playerId, 0) >= maxEnergy;\n    }\n    \n    public static void consumeEnergy(UUID playerId) {\n        energyLevels.remove(playerId);\n        chargeStartTime.remove(playerId);\n        \n        // Cancelar tarea de carga si existe\n        BukkitRunnable task = chargeTasks.get(playerId);\n        if (task != null) {\n            task.cancel();\n            chargeTasks.remove(playerId);\n        }\n    }\n    \n    public static void stopCharging(UUID playerId) {\n        BukkitRunnable task = chargeTasks.get(playerId);\n        if (task != null) {\n            task.cancel();\n            chargeTasks.remove(playerId);\n        }\n    }\n    \n    public static long getChargeTime(UUID playerId) {\n        Long startTime = chargeStartTime.get(playerId);\n        return startTime != null ? System.currentTimeMillis() - startTime : 0;\n    }\n    \n    public static void clearPlayerData(UUID playerId) {\n        energyLevels.remove(playerId);\n        chargeStartTime.remove(playerId);\n        stopCharging(playerId);\n    }\n}","size_bytes":6778},"src/main/java/com/hyser/hysercore/abilities/actions/EnergyReleaseAction.java":{"content":"package com.hyser.hysercore.abilities.actions;\n\nimport com.hyser.hysercore.abilities.AbilityAction;\nimport org.bukkit.ChatColor;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.LivingEntity;\nimport org.bukkit.entity.Player;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.util.Vector;\nimport org.bukkit.Sound;\nimport org.bukkit.Effect;\nimport org.bukkit.Location;\n\nimport java.util.List;\nimport java.util.UUID;\n\npublic class EnergyReleaseAction extends AbilityAction {\n    private double radius;\n    private double knockbackForce;\n    private double damageAmount;\n    private int requiredEnergy;\n    private boolean affectPlayers;\n    private boolean affectMobs;\n    private boolean createEffects;\n    private String releaseMessage;\n    \n    public EnergyReleaseAction(String type, ConfigurationSection config) {\n        super(type, config);\n        this.radius = config.getDouble(\"radius\", 5.0);\n        this.knockbackForce = config.getDouble(\"knockback_force\", 2.5);\n        this.damageAmount = config.getDouble(\"damage\", 0.0);\n        this.requiredEnergy = config.getInt(\"required_energy\", 100);\n        this.affectPlayers = config.getBoolean(\"affect_players\", true);\n        this.affectMobs = config.getBoolean(\"affect_mobs\", true);\n        this.createEffects = config.getBoolean(\"create_effects\", true);\n        this.releaseMessage = config.getString(\"release_message\", \"&c‚ö° ¬°EXPLOSI√ìN DE ENERG√çA! ‚ö°\");\n    }\n    \n    @Override\n    public void execute(Player player) {\n        UUID playerId = player.getUniqueId();\n        \n        // Verificar que el jugador tiene suficiente energ√≠a\n        int currentEnergy = EnergyChargeAction.getEnergyLevel(playerId);\n        if (currentEnergy < requiredEnergy) {\n            player.sendMessage(ChatColor.RED + \"‚ö° Energ√≠a insuficiente: \" + currentEnergy + \"/\" + requiredEnergy);\n            return;\n        }\n        \n        Location playerLoc = player.getLocation();\n        \n        // Mensaje de liberaci√≥n\n        String message = ChatColor.translateAlternateColorCodes('&', releaseMessage);\n        player.sendMessage(message);\n        \n        // Efectos visuales y sonoros en el jugador\n        if (createEffects) {\n            player.playSound(playerLoc, Sound.EXPLODE, 2.0f, 0.8f);\n            player.playSound(playerLoc, Sound.ENDERDRAGON_GROWL, 1.5f, 1.2f);\n            \n            // Efectos de part√≠culas en el √°rea\n            for (int i = 0; i < 360; i += 30) {\n                double x = Math.cos(Math.toRadians(i)) * radius;\n                double z = Math.sin(Math.toRadians(i)) * radius;\n                Location effectLoc = playerLoc.clone().add(x, 0.5, z);\n                playerLoc.getWorld().playEffect(effectLoc, Effect.EXPLOSION_LARGE, 0);\n            }\n            \n            // Efecto central\n            playerLoc.getWorld().playEffect(playerLoc.add(0, 1, 0), Effect.EXPLOSION_HUGE, 0);\n        }\n        \n        // Obtener entidades cercanas\n        List<Entity> nearbyEntities = player.getNearbyEntities(radius, radius, radius);\n        int affectedCount = 0;\n        \n        for (Entity entity : nearbyEntities) {\n            if (!(entity instanceof LivingEntity)) {\n                continue;\n            }\n            \n            LivingEntity target = (LivingEntity) entity;\n            \n            // Filtrar por tipo\n            if (target instanceof Player && !affectPlayers) {\n                continue;\n            }\n            if (!(target instanceof Player) && !affectMobs) {\n                continue;\n            }\n            \n            // No afectar al usuario\n            if (target.equals(player)) {\n                continue;\n            }\n            \n            // Calcular direcci√≥n de knockback (desde el jugador hacia la entidad)\n            Vector direction = target.getLocation().toVector().subtract(playerLoc.toVector());\n            direction.setY(0); // Ignorar diferencia de altura inicialmente\n            direction = direction.normalize();\n            \n            // Aplicar knockback\n            Vector knockback = direction.multiply(knockbackForce);\n            knockback.setY(0.5); // Elevaci√≥n ligera\n            target.setVelocity(knockback);\n            \n            // Aplicar da√±o si est√° configurado\n            if (damageAmount > 0) {\n                target.damage(damageAmount, player);\n            }\n            \n            affectedCount++;\n            \n            // Efectos individuales en cada objetivo\n            if (createEffects && target instanceof Player) {\n                Player targetPlayer = (Player) target;\n                targetPlayer.sendMessage(ChatColor.RED + \"‚ö° ¬°Fuiste empujado por una explosi√≥n de energ√≠a!\");\n                targetPlayer.playSound(targetPlayer.getLocation(), Sound.HURT_FLESH, 1.0f, 0.8f);\n            }\n        }\n        \n        // Mensaje de resultado\n        if (affectedCount > 0) {\n            player.sendMessage(ChatColor.YELLOW + \"‚ö° Empujaste \" + affectedCount + \" enemigos\");\n        } else {\n            player.sendMessage(ChatColor.GRAY + \"‚ö° No hay enemigos en el √°rea\");\n        }\n        \n        // Consumir energ√≠a\n        EnergyChargeAction.consumeEnergy(playerId);\n        player.sendMessage(ChatColor.GRAY + \"‚ö° Energ√≠a consumida completamente\");\n    }\n}","size_bytes":5305},"src/main/java/com/hyser/hysercore/abilities/triggers/SequentialTrigger.java":{"content":"package com.hyser.hysercore.abilities.triggers;\n\nimport com.hyser.hysercore.abilities.AbilityTrigger;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.player.PlayerToggleSneakEvent;\nimport org.bukkit.configuration.ConfigurationSection;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class SequentialTrigger extends AbilityTrigger {\n    private static Map<UUID, Boolean> abilityUsed = new HashMap<>();\n    private static Map<UUID, Long> lastAbilityTime = new HashMap<>();\n    \n    private long sequenceTimeout; // Tiempo m√°ximo para completar la secuencia\n    private String sequenceType;\n    \n    public SequentialTrigger(String type, ConfigurationSection config) {\n        super(type, config);\n        this.sequenceTimeout = config.getLong(\"sequence_timeout\", 5000); // 5 segundos por defecto\n        this.sequenceType = type.toLowerCase();\n    }\n    \n    @Override\n    public boolean matches(Event event, Player player) {\n        UUID playerId = player.getUniqueId();\n        long currentTime = System.currentTimeMillis();\n        \n        // Solo procesar si tiene objeto de ability en mano\n        if (!hasAbilityItemInHand(player)) {\n            return false;\n        }\n        \n        switch (sequenceType) {\n            case \"ability_then_double_shift\":\n                return handleAbilityThenDoubleShift(event, player, playerId, currentTime);\n            default:\n                return false;\n        }\n    }\n    \n    private boolean handleAbilityThenDoubleShift(Event event, Player player, UUID playerId, long currentTime) {\n        // Verificar si el evento es un doble shift\n        if (!(event instanceof PlayerToggleSneakEvent)) {\n            return false;\n        }\n        \n        PlayerToggleSneakEvent sneakEvent = (PlayerToggleSneakEvent) event;\n        if (!sneakEvent.isSneaking()) {\n            return false;\n        }\n        \n        // Verificar si el jugador us√≥ una ability recientemente\n        if (!abilityUsed.containsKey(playerId)) {\n            return false;\n        }\n        \n        Long lastUseTime = lastAbilityTime.get(playerId);\n        if (lastUseTime == null || (currentTime - lastUseTime) > sequenceTimeout) {\n            // Tiempo expirado, limpiar datos\n            abilityUsed.remove(playerId);\n            lastAbilityTime.remove(playerId);\n            return false;\n        }\n        \n        // Secuencia completada, limpiar datos\n        abilityUsed.remove(playerId);\n        lastAbilityTime.remove(playerId);\n        \n        return true;\n    }\n    \n    private boolean hasAbilityItemInHand(Player player) {\n        org.bukkit.inventory.ItemStack itemInHand = player.getItemInHand();\n        if (itemInHand == null || !itemInHand.hasItemMeta()) {\n            return false;\n        }\n        \n        org.bukkit.inventory.meta.ItemMeta meta = itemInHand.getItemMeta();\n        java.util.List<String> lore = meta.getLore();\n        \n        if (lore != null) {\n            for (String line : lore) {\n                if (line.contains(\"Usos restantes:\")) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // M√©todos est√°ticos para registrar uso de ability\n    public static void registerAbilityUse(UUID playerId) {\n        abilityUsed.put(playerId, true);\n        lastAbilityTime.put(playerId, System.currentTimeMillis());\n    }\n    \n    public static boolean isWaitingForSequence(UUID playerId) {\n        return abilityUsed.containsKey(playerId);\n    }\n    \n    public static void clearPlayerData(UUID playerId) {\n        abilityUsed.remove(playerId);\n        lastAbilityTime.remove(playerId);\n    }\n    \n    public static long getRemainingTime(UUID playerId, long timeout) {\n        Long lastUse = lastAbilityTime.get(playerId);\n        if (lastUse == null) {\n            return 0;\n        }\n        \n        long elapsed = System.currentTimeMillis() - lastUse;\n        return Math.max(0, timeout - elapsed);\n    }\n}","size_bytes":4016}},"version":1}